#!/usr/bin/python
import argparse
import logging, logging.config

from logger import setup_logging
from slcore.project import project_create, project_open, project_config, \
    project_rename, project_close, project_delete, project_show
from slcore.tools.scan_dtcb import project_scan_declare, project_scan_dtcb
from slcore.tools.scan_topology import project_scan_topology
from slcore.tools.scan_dt import project_unpack
from slcore.tools.dtinfo import project_show_dtinfo
from slcore.tools.batch import project_plugin_batch
from slcore.tools.source import project_source_analysis
from slcore.tools.machines import project_find_profile
from slcore.scheduler import project_standard_warmup, project_standard_wrapup, \
    run_static_analysis, run_diagnosis, run_model, run_dt_renderer

logger = logging.getLogger()


def __project_create(args):
    project_create(
        args.uuid, args.arch, args.endian,
        brand=args.brand, target=args.target, subtarget=args.subtarget,
        source=args.source, cross_compile=args.cross_compile, makeout=args.makeout)


def __project_config(args):
    project_config(
        uuid=args.uuid, arch=args.arch, endian=args.endian,
        brand=args.brand, target=args.target, subtarget=args.subtarget,
        source=args.source, cross_compile=args.cross_compile, makeout=args.makeout)


def __project_open(args):
    project_open(args.uuid)


def __project_rename(args):
    project_rename(args.uuid)


def __project_close(args):
    project_close()


def __project_delete(args):
    project_delete(args.uuid)


def __project_show(args):
    project_show()


def __scan_declare(args):
    project_scan_declare()


def __scan_dtcb(args):
    project_scan_dtcb(args.dtb)


def __scan_topology(args):
    project_scan_topology(args.dtb)


def __model_ict(args):
    # 1 standard_setup
    firmware = project_standard_warmup(args)
    # 2. analyze the source code
    status = run_model(firmware)
    # 3. take snapshots to save results
    return project_standard_wrapup(firmware)


def __analyze(args):
    # 1 standard_setup
    firmware = project_standard_warmup(args)
    # 2. analyze the source code
    status = run_static_analysis(firmware)
    # 3. take snapshots to save results
    return project_standard_wrapup(firmware)


def __diagnose(args):
    # 1 standard_setup
    firmware = project_standard_warmup(args)

    # 2. test the machine
    status = run_diagnosis(firmware)

    # 3. take snapshots to save results
    return project_standard_wrapup(firmware)


def __bootup(args):
    # 1 standard_setup
    firmware = project_standard_warmup(args)

    profile = project_find_profile(
        firmware.get_components(), url=args.url)
    if profile is None:
        return
    firmware = project_standard_warmup(args, profile=profile)

    # 2 diagnosis
    status = run_diagnosis(firmware)

    # 3. take snapshots to save results
    return project_standard_wrapup(firmware)


def __generate(args):
    # 1 standard_setup
    firmware = project_standard_warmup(args)

    # 2 generate code from dtb
    status = run_dt_renderer(firmware)

    # 3. take snapshots to save results
    return project_standard_wrapup(firmware)


def __unpack(args):
    project_unpack(args.firmware)


def __batch(args):
    project_plugin_batch(args)


def __dtinfo(args):
    project_show_dtinfo(args.dtb, mmio=args.mmio, flash=args.flash)


def __source(args):
    project_source_analysis(args.entry_point)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument('-r', '--rerun', action='store_true', default=False,
                        help='ingore save and restore and rerun all analysis')
    parser.add_argument('-d', '--debug', action='store_true', help='show verbose logs')
    parser.set_defaults(func=__analyze)
    commands = parser.add_subparsers(title='salamander commands')
    # 1 project
    # 1.1 create
    pproject_create = commands.add_parser('create', conflict_handler='resolve',
                                          help='Config - Create a project',
                                          description='Salamander is a project-style tool. '
                                          'A project is a global information center and will be used '
                                          'in every future step implicitly. The project is quite useful '
                                          'saving you from long and forgettable command lines. ')
    pproject_create.add_argument('-u', '--uuid', type=str, required=True,
                                 help='A uuid for this project. It can be any string you like. But don\'t use \'-\', use \'_\' instead.')
    pproject_create.add_argument('-a', '--arch', choices=['arm', 'arm64', 'mips'], required=True,
                                 help='The architecture. We only support arm, arm64, and mips.')
    pproject_create.add_argument('-e', '--endian', choices=['b', 'l'], required=True,
                                 help='The endianness. ARMEB is not supported, other combinations are OK.')
    pproject_create.add_argument('-b', '--brand', choices=['openwrt'], required=False,
                                 help='Optional. Say openwrt(lower case of OpenWRT).')
    pproject_create.add_argument('-t', '--target', required=False,
                                 help='Brand related. Say ath79 in OpenWRT.')
    pproject_create.add_argument('-st', '--subtarget', required=False,
                                 help='Brand related. Say generic is a subtarget of the target ath79 in OpenWRT.')
    pproject_create.add_argument('-s', '--source', metavar='path/to/source', required=False,
                                 help='Optional. The source code you\'d like to analyze. BTW, you have to '
                                      'compile your source first. See --makeout for more infomation.')
    pproject_create.add_argument('-cc', '--cross_compile', metavar='path/to/cc_prefix', required=False,
                                 help='Source related. The cross compiler prefix.')
    pproject_create.add_argument('-m', '--makeout', metavar='path/to/makeout', required=False,
                                 help='Source related. When you compile your source, remember to save the output. '
                                      'For Linux, the command can be make ARCH=xxx, CROSS_COMPILE=xxx V=1 >makeout.txt 2>&1.')
    pproject_create.set_defaults(func=__project_create)
    # 1.1.1 config, sometimes we'd like to configure arguments which are not passed through create
    pproject_config = commands.add_parser('config', help='Config - Config the project', conflict_handler='resolve',
                                          description='Config the project you created/opened. The arguments are the same as create.')
    pproject_config.add_argument('-u', '--uuid', type=str, required=False)
    pproject_config.add_argument('-a', '--arch', choices=['arm', 'arm64', 'mips'], required=False)
    pproject_config.add_argument('-e', '--endian', choices=['b', 'l'], required=False)
    pproject_config.add_argument('-b', '--brand', choices=['openwrt'], required=False)
    pproject_config.add_argument('-t', '--target', required=False)
    pproject_config.add_argument('-st', '--subtarget', required=False)
    pproject_config.add_argument('-s', '--source', metavar='path/to/source', required=False)
    pproject_config.add_argument('-cc', '--cross_compile', metavar='path/to/cc_prefix', required=False)
    pproject_config.add_argument('-m', '--makeout', metavar='path/to/makeout', required=False)
    pproject_config.set_defaults(func=__project_config)
    # 1.2 project open
    pproject_open = commands.add_parser('open', help='Config - Open a project', conflict_handler='resolve')
    pproject_open.add_argument('-u', '--uuid', type=str, required=True)
    pproject_open.set_defaults(func=__project_open)
    # 1.3 project rename
    pproject_rename = commands.add_parser('rename', help='Config - Rename the project', conflict_handler='resolve')
    pproject_rename.add_argument('-u', '--uuid', type=str, required=True)
    pproject_rename.set_defaults(func=__project_rename)
    # 1.4 project close
    pproject_close = commands.add_parser('close', help='Config - Close the project', conflict_handler='resolve')
    pproject_close.set_defaults(func=__project_close)
    # 1.4 project delete
    pproject_delete = commands.add_parser('delete', help='Config - Delete a project', conflict_handler='resolve')
    pproject_delete.add_argument('-u', '--uuid', type=str, required=True)
    pproject_delete.set_defaults(func=__project_delete)
    # 1.5 project show
    pproject_close = commands.add_parser('show', help='Config - Show the project', conflict_handler='resolve')
    pproject_close.set_defaults(func=__project_show)
    # 2 plugins
    # 2.1 scan_declare
    pscan_declare = commands.add_parser('declare', help='Plugin - Find new peripherals in the source')
    pscan_declare.set_defaults(func=__scan_declare)
    # 2.2 scan_dtcb
    pscan_dtcb = commands.add_parser('dtcb', help='Plugin - Find callbacks w.s.t compatibles in a device tree')
    pscan_dtcb.add_argument('dtb')
    pscan_dtcb.set_defaults(func=__scan_dtcb)
    # 2.4 scan_topology
    pscan_topology = commands.add_parser('topology', help='Plugin - Find interrupt topology in a device tree')
    pscan_topology.add_argument('dtb')
    pscan_topology.set_defaults(func=__scan_topology)
    # 2.3 model_ict
    pmodel_ict = commands.add_parser('ictm', help='model intc/clk/timer in current project')
    pmodel_ict.set_defaults(func=__model_ict)
    # 2.5 unpack
    punpack = commands.add_parser('unpack', help='Plugin - Unpack an image')
    punpack.add_argument('firmware', metavar='IMAGE',
                         help='We extend Binwalk to identify more image headers '
                              'and can extract the Linux kernel in the image.')
    punpack.set_defaults(func=__unpack)
    # 2.6 batch processing
    pbatch = commands.add_parser('batch', help='Plugin - Batch processing')
    pbatch.add_argument('-a', '--add', required=False, metavar='PATH_TO_IMAGE', nargs='+',
                        help='Add(skip if exists) an image or images to current project by image paths.')
    pbatch.add_argument('-e', '--extend', required=False, metavar='DIR_TO_IMAGES',
                        help='Add(skip if exists) an image or images to current project by images directory.')
    pbatch.add_argument('-ad', '--add_dtb', required=False, metavar='PATH_TO_DTB', nargs='+',
                        help='Add(skip if exists) a dtb or dtbs to current project by dtb paths.')
    pbatch.add_argument('-ed', '--extend_dtb', required=False, metavar='DIR_TO_DTBS',
                        help='Add(skip if exists) a dtb or dtbs to current project by dtbs directory.')
    pbatch.add_argument('-dt', '--dt', required=False, action='store_true', default=True,
                        help='Add images with device tree, only effecting -e, True by default.')
    pbatch.add_argument('-c', '--count', required=False, type=int, default=10,
                        help='Limit how many images to be added to current project, only effecting -e, 10 by default.')
    pbatch.add_argument('-s', '--show', required=False, action='store_true', default=False,
                        help='Show images/dtbs of current project. Similar to ./salamander show.')
    pbatch.set_defaults(func=__batch)
    # 2.7 device tree info
    pdtinfo = commands.add_parser('dtinfo', help='Plugin - Disclose device tree blob')
    pdtinfo.add_argument('dtb', help='Show details in this device tree blob.')
    pdtinfo.add_argument('-m', '--mmio', required=False, action='store_true', default=True,
                         help='Show MMIO regions in the device tree blob.')
    pdtinfo.add_argument('-f', '--flash', required=False, action='store_true', default=True,
                         help='Show FLASH chips in the device tree blob.')
    pdtinfo.set_defaults(func=__dtinfo)
    # 2.8 source code analysis
    psource = commands.add_parser('source', help='Plugin - Analyze source code')
    psource.add_argument('-e', '--entry_point', required=True,
                         help='Find the file contains the entry point of data or function and preprocess the file.')
    psource.set_defaults(func=__source)
    # 3 cores
    # 3.1 analyze
    panalyze = commands.add_parser('analyze', help='RUN - Analyze the source code')
    panalyze.set_defaults(func=__analyze)
    # 3.2 generate
    pgenerate = commands.add_parser('generate', help='RUN - Test the device tree in current project')
    pgenerate.add_argument('-dtb', '--dtb', required=False)
    pgenerate.add_argument('-nc', '--nocompilation', action='store_true', default=False, help='set this for multi-tasks')
    pgenerate.set_defaults(func=__generate)
    # 3.3 diagnose
    pdiagnose = commands.add_parser('diagnose', help='Run - Test the models in current project')
    pdiagnose.add_argument('-f', '--firmware', required=False, metavar='IMAGE',
                           help='Use the IMAGE to diagnose your models. If not set, use the last valid image, '
                           'otherwise, use the first image in your current project(./samander batch -s). '
                           'If there is no valid image and there is no image in your project, you must provide a image.')
    pdiagnose.add_argument('-dtb', '--dtb', required=False,
                           help='If the image you provide has no device tree blob, you can provide a device tree blob, otherwise, ignored.')
    pdiagnose.set_defaults(func=__diagnose)
    # 3.4 bootup
    pbootup = commands.add_parser('bootup', help='Run - Boot up your image in current project')
    pbootup.add_argument('-f', '--firmware', required=False, metavar='IMAGE')
    pbootup.add_argument('-l', '--url', required=False, help='will be removed in the future')
    pbootup.add_argument('-nc', '--nocompilation', action='store_true', default=False, help='set this for multi-tasks')
    pbootup.set_defaults(func=__bootup)

    args = parser.parse_args()
    if args.debug:
        setup_logging(default_level=logging.DEBUG)
    else:
        setup_logging(default_level=logging.INFO)

    args.func(args)

