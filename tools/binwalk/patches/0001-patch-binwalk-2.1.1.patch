From c258f2082b8e0baa94beee6472b9447a1a8c1475 Mon Sep 17 00:00:00 2001
From: cyrus <cyruscyliu@gmail.com>
Date: Mon, 21 Oct 2019 12:24:59 +0800
Subject: [PATCH] patch binwalk-2.1.1

---
 src/binwalk/core/exceptions.py       |   25 +
 src/binwalk/core/magic.py            |  326 +++++---
 src/binwalk/magic/firmware           | 1435 +++++++++++++++++-----------------
 src/binwalk/modules/extractor.py     |   13 +-
 src/binwalk/modules/general.py       |   44 +-
 src/binwalk/plugins/trxextract.py    |   25 +
 src/binwalk/plugins/uimageextract.py |   23 +
 src/scripts/extract_uimage.py        |   11 +
 8 files changed, 1047 insertions(+), 855 deletions(-)
 create mode 100644 src/binwalk/core/exceptions.py
 create mode 100644 src/binwalk/plugins/trxextract.py
 create mode 100644 src/binwalk/plugins/uimageextract.py
 create mode 100644 src/scripts/extract_uimage.py

diff --git a/src/binwalk/core/exceptions.py b/src/binwalk/core/exceptions.py
new file mode 100644
index 0000000..a032c39
--- /dev/null
+++ b/src/binwalk/core/exceptions.py
@@ -0,0 +1,25 @@
+class ParserException(Exception):
+
+    '''
+    Exception thrown specifically for signature file parsing errors.
+    '''
+    pass
+
+
+class ModuleException(Exception):
+
+    '''
+    Module exception class.
+    Nothing special here except the name.
+    '''
+    pass
+
+
+class IgnoreFileException(Exception):
+
+    '''
+    Special exception class used by the load_file plugin method
+    to indicate that the file that we are attempting to load
+    should be ignored.
+    '''
+    pass
\ No newline at end of file
diff --git a/src/binwalk/core/magic.py b/src/binwalk/core/magic.py
index 0c398a4..a7a0757 100644
--- a/src/binwalk/core/magic.py
+++ b/src/binwalk/core/magic.py
@@ -9,17 +9,14 @@ import struct
 import datetime
 import binwalk.core.common
 import binwalk.core.compat
+from binwalk.core.exceptions import ParserException
 
-class ParserException(Exception):
-    '''
-    Exception thrown specifically for signature file parsing errors.
-    '''
-    pass
 
 class SignatureResult(binwalk.core.module.Result):
     '''
     Container class for signature results.
     '''
+
     def __init__(self, **kwargs):
         # These are set by signature keyword tags.
         # Keyword tags can also set any other object attributes,
@@ -32,6 +29,7 @@ class SignatureResult(binwalk.core.module.Result):
         self.invalid = False
         self.once = False
         self.overlap = False
+        self.end = False
 
         # These are set by code internally
         self.id = 0
@@ -41,6 +39,7 @@ class SignatureResult(binwalk.core.module.Result):
 
         self.valid = (not self.invalid)
 
+
 class SignatureLine(object):
     '''
     Responsible for parsing signature lines from magic signature files.
@@ -106,16 +105,19 @@ class SignatureLine(object):
                 self.operator = operator
 
                 # Try to convert the operator value into an integer. This works for
-                # simple operator values, but not for complex types (e.g., '(4.l+12)').
+                # simple operator values, but not for complex types (e.g.,
+                # '(4.l+12)').
                 try:
                     self.opvalue = int(self.opvalue, 0)
                 except ValueError as e:
                     pass
 
-                # Only one operator type is supported, so break as soon as one is found
+                # Only one operator type is supported, so break as soon as one
+                # is found
                 break
 
-        # If the specified type starts with 'u' (e.g., 'ubelong'), then it is unsigned; else, it is signed
+        # If the specified type starts with 'u' (e.g., 'ubelong'), then it is
+        # unsigned; else, it is signed
         if self.type[0] == 'u':
             self.signed = False
             self.type = self.type[1:]
@@ -123,16 +125,17 @@ class SignatureLine(object):
             self.signed = True
 
         # Big endian values start with 'be' ('belong'), little endian values start with 'le' ('lelong').
-        # The struct module uses '>' to denote big endian and '<' to denote little endian.
+        # The struct module uses '>' to denote big endian and '<' to denote
+        # little endian.
         if self.type.startswith('be'):
             self.type = self.type[2:]
-            self.endianess = '>'
+            self.endianness = '>'
         elif self.type.startswith('le'):
-            self.endianess = '<'
+            self.endianness = '<'
             self.type = self.type[2:]
-        # Assume big endian if no endianess was explicitly specified
+        # Assume big endian if no endianness was explicitly specified
         else:
-            self.endianess = '>'
+            self.endianness = '>'
 
         # Check the comparison value for the type of comparison to be performed (e.g.,
         # '=0x1234', '>0x1234', etc). If no operator is specified, '=' is implied.
@@ -146,9 +149,11 @@ class SignatureLine(object):
         # If this is a wildcard value, explicitly set self.value to None
         if self.value == 'x':
             self.value = None
-        # String values need to be decoded, as they may contain escape characters (e.g., '\x20')
+        # String values need to be decoded, as they may contain escape
+        # characters (e.g., '\x20')
         elif self.type == 'string':
-            # String types support multiplication to easily match large repeating byte sequences
+            # String types support multiplication to easily match large
+            # repeating byte sequences
             if '*' in self.value:
                 try:
                     p = self.value.split('*')
@@ -158,7 +163,8 @@ class SignatureLine(object):
                 except KeyboardInterrupt as e:
                     raise e
                 except Exception as e:
-                    raise ParserException("Failed to expand string '%s' with integer '%s' in line '%s'" % (self.value, n, line))
+                    raise ParserException(
+                        "Failed to expand string '%s' with integer '%s' in line '%s'" % (self.value, n, line))
             try:
                 self.value = binwalk.core.compat.string_decode(self.value)
             except ValueError as e:
@@ -180,26 +186,32 @@ class SignatureLine(object):
             except ValueError as e:
                 raise ParserException("Failed to convert value '%s' to an integer on line '%s'" % (self.value, line))
 
-        # Sanity check to make sure the first line of a signature has an explicit value
+        # Sanity check to make sure the first line of a signature has an
+        # explicit value
         if self.level == 0 and self.value is None:
             raise ParserException("First element of a signature must specify a non-wildcard value: '%s'" % (line))
 
         # Set the size and struct format value for the specified data type.
-        # This must be done, obviously, after the value has been parsed out above.
+        # This must be done, obviously, after the value has been parsed out
+        # above.
         if self.type == 'string':
-            # Strings don't have a struct format value, since they don't have to be unpacked
+            # Strings don't have a struct format value, since they don't have
+            # to be unpacked
             self.fmt = None
 
-            # If a string type has a specific value, set the comparison size to the length of that string
+            # If a string type has a specific value, set the comparison size to
+            # the length of that string
             if self.value:
                 self.size = len(self.value)
             # Else, truncate the string to self.MAX_STRING_SIZE
             else:
                 self.size = self.MAX_STRING_SIZE
         elif self.type == 'regex':
-            # Regular expressions don't have a struct format value, since they don't have to be unpacked
+            # Regular expressions don't have a struct format value, since they
+            # don't have to be unpacked
             self.fmt = None
-            # The size of a matching regex is unknown until it is applied to some data
+            # The size of a matching regex is unknown until it is applied to
+            # some data
             self.size = self.MAX_STRING_SIZE
         elif self.type == 'byte':
             self.fmt = 'b'
@@ -210,10 +222,12 @@ class SignatureLine(object):
         elif self.type == 'quad':
             self.fmt = 'q'
             self.size = 8
-        # Assume 4 byte length for all other data types
-        else:
+        # Assume 4 byte length for all other supported data types
+        elif self.type in ['long', 'date']:
             self.fmt = 'i'
             self.size = 4
+        else:
+            raise ParserException("Unknown data type '%s' in line '%s'" % (self.type, line))
 
         # The struct module uses the same characters for specifying signed and unsigned data types,
         # except that signed data types are upper case. The above if-else code sets self.fmt to the
@@ -222,9 +236,9 @@ class SignatureLine(object):
             self.fmt = self.fmt.upper()
 
         # If a struct format was identified, create a format string to be passed to struct.unpack
-        # which specifies the endianess and data type format.
+        # which specifies the endianness and data type format.
         if self.fmt:
-            self.pkfmt = '%c%c' % (self.endianess, self.fmt)
+            self.pkfmt = '%c%c' % (self.endianness, self.fmt)
         else:
             self.pkfmt = None
 
@@ -241,7 +255,8 @@ class SignatureLine(object):
                 # Get rid of the curly braces.
                 tag = match.group().replace('{', '').replace('}', '')
 
-                # If the tag specifies a value, it will be colon delimited (e.g., '{name:%s}')
+                # If the tag specifies a value, it will be colon delimited
+                # (e.g., '{name:%s}')
                 if ':' in tag:
                     (n, v) = tag.split(':', 1)
                 else:
@@ -256,22 +271,23 @@ class SignatureLine(object):
         else:
             self.format = ""
 
+
 class Signature(object):
     '''
     Class to hold signature data and generate signature regular expressions.
     '''
 
-    def __init__(self, id, first_line):
+    def __init__(self, sid, first_line):
         '''
         Class constructor.
 
-        @id         - A ID value to uniquely identify this signature.
+        @sid        - A ID value to uniquely identify this signature.
         @first_line - The first SignatureLine of the signature (subsequent
                       SignatureLines should be added via self.append).
 
         Returns None.
         '''
-        self.id = id
+        self.id = sid
         self.lines = [first_line]
         self.title = first_line.format
         self.offset = first_line.offset
@@ -294,7 +310,7 @@ class Signature(object):
 
         # Strings and single byte signatures are taken at face value;
         # multi-byte integer values are turned into regex strings based
-        # on their data type size and endianess.
+        # on their data type size and endianness.
         if line.type == 'regex':
             # Regex types are already compiled expressions.
             # Note that since re.finditer is used, unless the specified
@@ -305,40 +321,40 @@ class Signature(object):
         elif line.size == 1:
             restr = chr(line.value)
         elif line.size == 2:
-            if line.endianess == '<':
+            if line.endianness == '<':
                 restr = chr(line.value & 0xFF) + chr(line.value >> 8)
-            elif line.endianess == '>':
+            elif line.endianness == '>':
                 restr = chr(line.value >> 8) + chr(line.value & 0xFF)
         elif line.size == 4:
-            if line.endianess == '<':
-                restr =          (chr(line.value & 0xFF) +
-                                  chr((line.value >> 8) & 0xFF) +
-                                  chr((line.value >> 16) & 0xFF) +
-                                  chr(line.value >> 24))
-            elif line.endianess == '>':
-                restr =          (chr(line.value >> 24) +
-                                  chr((line.value >> 16) & 0xFF) +
-                                  chr((line.value >> 8) & 0xFF) +
-                                  chr(line.value & 0xFF))
+            if line.endianness == '<':
+                restr = (chr(line.value & 0xFF) +
+                         chr((line.value >> 8) & 0xFF) +
+                         chr((line.value >> 16) & 0xFF) +
+                         chr(line.value >> 24))
+            elif line.endianness == '>':
+                restr = (chr(line.value >> 24) +
+                         chr((line.value >> 16) & 0xFF) +
+                         chr((line.value >> 8) & 0xFF) +
+                         chr(line.value & 0xFF))
         elif line.size == 8:
-            if line.endianess == '<':
-                restr =          (chr(line.value & 0xFF) +
-                                  chr((line.value >> 8) & 0xFF) +
-                                  chr((line.value >> 16) & 0xFF) +
-                                  chr((line.value >> 24) & 0xFF) +
-                                  chr((line.value >> 32) & 0xFF) +
-                                  chr((line.value >> 40) & 0xFF) +
-                                  chr((line.value >> 48) & 0xFF) +
-                                  chr(line.value >> 56))
-            elif line.endianess == '>':
-                restr =          (chr(line.value >> 56) +
-                                  chr((line.value >> 48) & 0xFF) +
-                                  chr((line.value >> 40) & 0xFF) +
-                                  chr((line.value >> 32) & 0xFF) +
-                                  chr((line.value >> 24) & 0xFF) +
-                                  chr((line.value >> 16) & 0xFF) +
-                                  chr((line.value >> 8) & 0xFF) +
-                                  chr(line.value & 0xFF))
+            if line.endianness == '<':
+                restr = (chr(line.value & 0xFF) +
+                         chr((line.value >> 8) & 0xFF) +
+                         chr((line.value >> 16) & 0xFF) +
+                         chr((line.value >> 24) & 0xFF) +
+                         chr((line.value >> 32) & 0xFF) +
+                         chr((line.value >> 40) & 0xFF) +
+                         chr((line.value >> 48) & 0xFF) +
+                         chr(line.value >> 56))
+            elif line.endianness == '>':
+                restr = (chr(line.value >> 56) +
+                         chr((line.value >> 48) & 0xFF) +
+                         chr((line.value >> 40) & 0xFF) +
+                         chr((line.value >> 32) & 0xFF) +
+                         chr((line.value >> 24) & 0xFF) +
+                         chr((line.value >> 16) & 0xFF) +
+                         chr((line.value >> 8) & 0xFF) +
+                         chr(line.value & 0xFF))
 
         # Since re.finditer is used on a per-signature basis, signatures should be crafted carefully
         # to ensure that they aren't potentially self-overlapping (e.g., a signature of "ABCDAB" could
@@ -350,7 +366,7 @@ class Signature(object):
         # spit out a warning about any self-overlapping signatures.
         if not binwalk.core.compat.has_key(line.tags, 'overlap'):
             for i in range(1, line.size):
-                if restr[i:] == restr[0:(line.size-i)]:
+                if restr[i:] == restr[0:(line.size - i)]:
                     binwalk.core.common.warning("Signature '%s' is a self-overlapping signature!" % line.text)
                     break
 
@@ -364,9 +380,11 @@ class Signature(object):
 
         Returns None.
         '''
-        # This method is kind of useless, but may be a nice wrapper for future code.
+        # This method is kind of useless, but may be a nice wrapper for future
+        # code.
         self.lines.append(line)
 
+
 class Magic(object):
     '''
     Primary class for loading signature files and scanning
@@ -383,11 +401,14 @@ class Magic(object):
 
         Returns None.
         '''
-        # Used to save the block of data passed to self.scan (see additional comments in self.scan)
+        # Used to save the block of data passed to self.scan (see additional
+        # comments in self.scan)
         self.data = ""
-        # A list of Signature class objects, populated by self.parse (see also: self.load)
+        # A list of Signature class objects, populated by self.parse (see also:
+        # self.load)
         self.signatures = []
-        # A set of signatures with the 'once' keyword that have already been displayed once
+        # A set of signatures with the 'once' keyword that have already been
+        # displayed once
         self.display_once = set()
         self.dirty = True
 
@@ -406,6 +427,9 @@ class Magic(object):
         # Regex rule to find periods (see self._do_math)
         self.period = re.compile("\.")
 
+    def reset(self):
+        self.display_once = set()
+
     def _filtered(self, text):
         '''
         Tests if a string should be filtered out or not.
@@ -443,7 +467,7 @@ class Magic(object):
 
         return filtered
 
-    def _do_math(self, offset, expression):
+    def _do_math(self, offset, expression, previous_line_start):
         '''
         Parses and evaluates complex expressions, e.g., "(4.l+12)", "(6*32)", etc.
 
@@ -457,53 +481,66 @@ class Magic(object):
             replacements = {}
 
             for period in [match.start() for match in self.period.finditer(expression)]:
-                # Separate the offset field into the integer offset and type values (o and t respsectively)
+                # Separate the offset field into the integer offset and type
+                # values (o and t respsectively)
                 s = expression[:period].rfind('(') + 1
-                # The offset address may be an evaluatable expression, such as '(4+0.L)', typically the result
-                # of the original offset being something like '(&0.L)'.
-                o = binwalk.core.common.MathExpression(expression[s:period]).value
-                t = expression[period+1]
+                if s == period:
+                    # The > in >.L indicates the current offset.
+                    # It must follow a normal signature which handles the value at the same offset.
+                    # >(8.L)+8+8          ubelong   x           offset to name %d
+                    # >(12.L)+(>.L)       string    x           %s
+                    o = previous_line_start
+                else:
+                    # The offset address may be an evaluatable expression, such as '(4+0.L)', typically the result
+                    # of the original offset being something like '(&0.L)'.
+                    o = binwalk.core.common.MathExpression(expression[s:period]).value
+                t = expression[period + 1]
 
                 # Re-build just the parsed offset portion of the expression
                 text = "%s.%c" % (expression[s:period], t)
 
-                # Have we already evaluated this offset expression? If so, skip it.
+                # Have we already evaluated this offset expression? If so, skip
+                # it.
                 if binwalk.core.common.has_key(replacements, text):
                     continue
 
-                # The offset specified in the expression is relative to the starting offset inside self.data
+                # The offset specified in the expression is relative to the
+                # starting offset inside self.data
                 o += offset
 
                 # Read the value from self.data at the specified offset
                 try:
                     # Big and little endian byte format
                     if t in ['b', 'B']:
-                        v = struct.unpack('b', binwalk.core.compat.str2bytes(self.data[o:o+1]))[0]
+                        v = struct.unpack('b', binwalk.core.compat.str2bytes(self.data[o:o + 1]))[0]
                     # Little endian short format
                     elif t == 's':
-                        v = struct.unpack('<h', binwalk.core.compat.str2bytes(self.data[o:o+2]))[0]
+                        v = struct.unpack('<h', binwalk.core.compat.str2bytes(self.data[o:o + 2]))[0]
                     # Little endian long format
                     elif t == 'l':
-                        v = struct.unpack('<i', binwalk.core.compat.str2bytes(self.data[o:o+4]))[0]
+                        v = struct.unpack('<i', binwalk.core.compat.str2bytes(self.data[o:o + 4]))[0]
                     # Big endian short format
                     elif t == 'S':
-                        v = struct.unpack('>h', binwalk.core.compat.str2bytes(self.data[o:o+2]))[0]
+                        v = struct.unpack('>h', binwalk.core.compat.str2bytes(self.data[o:o + 2]))[0]
                     # Bit endian long format
                     elif t == 'L':
-                        v = struct.unpack('>i', binwalk.core.compat.str2bytes(self.data[o:o+4]))[0]
-                # struct.error is thrown if there is not enough bytes in self.data for the specified format type
+                        v = struct.unpack('>i', binwalk.core.compat.str2bytes(self.data[o:o + 4]))[0]
+                # struct.error is thrown if there is not enough bytes in
+                # self.data for the specified format type
                 except struct.error as e:
                     v = 0
 
                 # Keep track of all the recovered values from self.data
                 replacements[text] = v
 
-            # Finally, replace all offset expressions with their corresponding text value
+            # Finally, replace all offset expressions with their corresponding
+            # text value
             v = expression
             for (text, value) in binwalk.core.common.iterator(replacements):
                 v = v.replace(text, "%d" % value)
 
-        # If no offset, then it's just an evaluatable math expression (e.g., "(32+0x20)")
+        # If no offset, then it's just an evaluatable math expression (e.g.,
+        # "(32+0x20)")
         else:
             v = expression
 
@@ -522,18 +559,22 @@ class Magic(object):
         Returns a dictionary of tags parsed from the data.
         '''
         description = []
-        tag_strlen = None
         max_line_level = 0
         previous_line_end = 0
-        tags = {'id' : signature.id, 'offset' : offset, 'invalid' : False, 'once' : False}
+        previous_line_size = 0
+        non_printable_char = False
+        tags = {'id': signature.id, 'offset':
+            offset, 'invalid': False, 'once': False}
 
-        # Apply each line of the signature to self.data, starting at the specified offset
+        # Apply each line of the signature to self.data, starting at the
+        # specified offset
         for n in range(0, len(signature.lines)):
             line = signature.lines[n]
 
             # Ignore indentation levels above the current max indent level
             if line.level <= max_line_level:
-                # If the relative offset of this signature line is just an integer value, use it
+                # If the relative offset of this signature line is just an
+                # integer value, use it
                 if isinstance(line.offset, int):
                     line_offset = line.offset
                 # Else, evaluate the complex expression
@@ -546,7 +587,7 @@ class Magic(object):
                     # replace both with the ple text.
                     line_offset_text = line.offset.replace('&+', ple).replace('&', ple)
                     # Evaluate the expression
-                    line_offset = self._do_math(offset, line_offset_text)
+                    line_offset = self._do_math(offset, line_offset_text, previous_line_end - previous_line_size)
 
                 # Sanity check
                 if not isinstance(line_offset, int):
@@ -561,7 +602,8 @@ class Magic(object):
                 if line.pkfmt:
                     try:
                         dvalue = struct.unpack(line.pkfmt, binwalk.core.compat.str2bytes(self.data[start:end]))[0]
-                    # Not enough bytes left in self.data for the specified format size
+                    # Not enough bytes left in self.data for the specified
+                    # format size
                     except struct.error as e:
                         dvalue = 0
                 # Else, this is a string
@@ -570,22 +612,27 @@ class Magic(object):
                     if line.value is None:
                         # Check to see if this is a string whose size is known and has been specified on a previous
                         # signature line.
-                        if binwalk.core.compat.has_key(tags, 'strlen') and binwalk.core.compat.has_key(line.tags, 'string'):
-                            dvalue = self.data[start:(start+tags['strlen'])]
-                        # Else, just terminate the string at the first newline, carriage return, or NULL byte
+                        if binwalk.core.compat.has_key(tags, 'strlen') and binwalk.core.compat.has_key(line.tags,
+                                                                                                       'string'):
+                            dvalue = self.data[start:(start + tags['strlen'])]
+                            non_printable_char = True
+                        # Else, just terminate the string at the first newline,
+                        # carriage return, or NULL byte
                         else:
                             dvalue = self.data[start:end].split('\x00')[0].split('\r')[0].split('\n')[0]
-                    # Non-wildcard strings have a known length, specified in the signature line
+                    # Non-wildcard strings have a known length, specified in
+                    # the signature line
                     else:
                         dvalue = self.data[start:end]
 
                 # Some integer values have special operations that need to be performed on them
                 # before comparison (e.g., "belong&0x0000FFFF"). Complex math expressions are
                 # supported here as well.
-                #if isinstance(dvalue, int) and line.operator:
+                # if isinstance(dvalue, int) and line.operator:
                 if line.operator:
                     try:
-                        # If the operator value of this signature line is just an integer value, use it
+                        # If the operator value of this signature line is just
+                        # an integer value, use it
                         if isinstance(line.opvalue, int) or isinstance(line.opvalue, long):
                             opval = line.opvalue
                         # Else, evaluate the complex expression
@@ -612,25 +659,36 @@ class Magic(object):
                     except KeyboardInterrupt as e:
                         raise e
                     except Exception as e:
-                        raise ParserException("Operation '" + str(dvalue) + " " + str(line.operator) + "= " + str(line.opvalue) + "' failed: " + str(e))
+                        raise ParserException("Operation '" +
+                                              str(dvalue) +
+                                              " " +
+                                              str(line.operator) +
+                                              "= " +
+                                              str(line.opvalue) +
+                                              "' failed: " + str(e))
 
                 # Does the data (dvalue) match the specified comparison?
                 if ((line.value is None) or
-                    (line.regex and line.value.match(dvalue)) or
-                    (line.condition == '=' and dvalue == line.value) or
-                    (line.condition == '>' and dvalue > line.value) or
-                    (line.condition == '<' and dvalue < line.value) or
-                    (line.condition == '!' and dvalue != line.value) or
-                    (line.condition == '~' and (dvalue == ~line.value)) or
-                    (line.condition == '^' and (dvalue ^ line.value)) or
-                    (line.condition == '&' and (dvalue & line.value)) or
-                    (line.condition == '|' and (dvalue | line.value))):
+                        (line.regex and line.value.match(dvalue)) or
+                        (line.condition == '=' and dvalue == line.value) or
+                        (line.condition == '>' and dvalue > line.value) or
+                        (line.condition == '<' and dvalue < line.value) or
+                        (line.condition == '!' and dvalue != line.value) or
+                        (line.condition == '~' and (dvalue == ~line.value)) or
+                        (line.condition == '^' and (dvalue ^ line.value)) or
+                        (line.condition == '&' and (dvalue & line.value)) or
+                        (line.condition == '|' and (dvalue | line.value))):
 
                     # Up until this point, date fields are treated as integer values,
                     # but we want to display them as nicely formatted strings.
                     if line.type == 'date':
-                        ts = datetime.datetime.utcfromtimestamp(dvalue)
-                        dvalue = ts.strftime("%Y-%m-%d %H:%M:%S")
+                        try:
+                            ts = datetime.datetime.utcfromtimestamp(dvalue)
+                            dvalue = ts.strftime("%Y-%m-%d %H:%M:%S")
+                        except KeyboardInterrupt as e:
+                            raise e
+                        except Exception:
+                            dvalue = "invalid timestamp"
 
                     # Generate the tuple for the format string
                     dvalue_tuple = ()
@@ -640,12 +698,14 @@ class Magic(object):
                     # Format the description string
                     desc = line.format % dvalue_tuple
 
-                    # If there was any description string, append it to the list of description string parts
+                    # If there was any description string, append it to the
+                    # list of description string parts
                     if desc:
                         description.append(desc)
 
                     # Process tag keywords specified in the signature line. These have already been parsed out of the
-                    # original format string so that they can be processed separately from the printed description string.
+                    # original format string so that they can be processed
+                    # separately from the printed description string.
                     for (tag_name, tag_value) in binwalk.core.compat.iterator(line.tags):
                         # If the tag value is a string, try to format it
                         if isinstance(tag_value, str):
@@ -660,9 +720,13 @@ class Magic(object):
                         else:
                             tags[tag_name] = tag_value
 
-                        # Some tag values are intended to be integer values, so try to convert them as such
+                        # Some tag values are intended to be integer values, so
+                        # try to convert them as such.
+                        # Use eval() to support arithmetic operators to tagged metadata.
                         try:
-                            tags[tag_name] = int(tags[tag_name], 0)
+                            tags[tag_name] = eval(tags[tag_name])
+                        except SyntaxError:
+                            tags[tag_name] = 0
                         except KeyboardInterrupt as e:
                             raise e
                         except Exception as e:
@@ -670,7 +734,8 @@ class Magic(object):
 
                     # Abort processing soon as this signature is marked invalid, unless invalid results
                     # were explicitly requested. This means that the sooner invalid checks are made in a
-                    # given signature, the faster the scan can filter out false positives.
+                    # given signature, the faster the scan can filter out false
+                    # positives.
                     if not self.show_invalid and tags['invalid']:
                         break
 
@@ -679,16 +744,19 @@ class Magic(object):
                     # so that subsequent lines can use the '>>&0' offset syntax to specify relative offsets
                     # from previous lines.
                     try:
-                        next_line = signature.lines[n+1]
+                        next_line = signature.lines[n + 1]
                         if next_line.level > line.level:
                             if line.type == 'string':
                                 previous_line_end = line_offset + len(dvalue)
+                                previous_line_size = len(dvalue)
                             else:
                                 previous_line_end = line_offset + line.size
+                                previous_line_size = line.size
                     except IndexError as e:
                         pass
 
-                    # If this line satisfied its comparison, +1 the max indentation level
+                    # If this line satisfied its comparison, +1 the max
+                    # indentation level
                     max_line_level = line.level + 1
                 else:
                     # No match on the first line, abort
@@ -699,7 +767,8 @@ class Magic(object):
                         # indentation levels will not be accepted.
                         max_line_level = line.level
 
-        # Join the formatted description strings and remove backspace characters (plus the preceeding character as well)
+        # Join the formatted description strings and remove backspace
+        # characters (plus the preceeding character as well)
         tags['description'] = self.bspace.sub('', " ".join(description))
 
         # This should never happen
@@ -707,8 +776,11 @@ class Magic(object):
             tags['display'] = False
             tags['invalid'] = True
 
-        # If the formatted string contains non-printable characters, consider it invalid
-        if self.printable.match(tags['description']).group() != tags['description']:
+        # If the formatted string contains non-printable characters, consider it invalid.
+        if non_printable_char:
+            tags['description'] = tags['description'].replace('\0', '')
+
+        if not non_printable_char and self.printable.match(tags['description']).group() != tags['description']:
             tags['invalid'] = True
 
         return tags
@@ -745,18 +817,20 @@ class Magic(object):
             dlen = len(data)
 
         for signature in self.signatures:
-            # Use regex to search the data block for potential signature matches (fast)
+            # Use regex to search the data block for potential signature
+            # matches (fast)
             for match in signature.regex.finditer(data):
                 # Take the offset of the start of the signature into account
                 offset = match.start() - signature.offset
 
                 # Signatures are ordered based on the length of their magic bytes (largest first).
                 # If this offset has already been matched to a previous signature, ignore it unless
-                # self.show_invalid has been specified. Also ignore obviously invalid offsets (<1)
+                # self.show_invalid has been specified. Also ignore obviously invalid offsets (<0)
                 # as well as those outside the specified self.data range (dlen).
                 if (offset not in matched_offsets or self.show_invalid) and offset >= 0 and offset < dlen:
-                #if offset >= 0 and offset < dlen:
-                    # Analyze the data at this offset using the current signature rule
+                    # if offset >= 0 and offset < dlen:
+                    # Analyze the data at this offset using the current
+                    # signature rule
                     tags = self._analyze(signature, offset)
 
                     # Generate a SignatureResult object and append it to the results list if the
@@ -806,7 +880,8 @@ class Magic(object):
         signature = None
 
         for line in lines:
-            # Split at the first comment delimiter (if any) and strip the result
+            # Split at the first comment delimiter (if any) and strip the
+            # result
             line = line.split('#')[0].strip()
             # Ignore blank lines and lines that are nothing but comments.
             # We also don't support the '!mime' style line entries.
@@ -826,10 +901,11 @@ class Magic(object):
                     signature = Signature(len(self.signatures), sigline)
                 # Else, just append this line to the existing signature
                 elif signature:
-                    #signature.append(sigline)
+                    # signature.append(sigline)
                     signature.lines.append(sigline)
                 # If this is not the first line of a signature entry and there is no other
-                # existing signature entry, something is very wrong with the signature file.
+                # existing signature entry, something is very wrong with the
+                # signature file.
                 else:
                     raise ParserException("Invalid signature line: '%s'" % line)
 
@@ -838,6 +914,6 @@ class Magic(object):
             if not self._filtered(signature.lines[0].format):
                 self.signatures.append(signature)
 
-        # Sort signatures by confidence (aka, length of their magic bytes), largest first
+        # Sort signatures by confidence (aka, length of their magic bytes),
+        # largest first
         self.signatures.sort(key=lambda x: x.confidence, reverse=True)
-
diff --git a/src/binwalk/magic/firmware b/src/binwalk/magic/firmware
index 53fc9cc..9587ca6 100644
--- a/src/binwalk/magic/firmware
+++ b/src/binwalk/magic/firmware
@@ -1,702 +1,733 @@
-
-#--------------------------Firmware Formats---------------------------
-
-# uImage file     
-# From: Craig Heffner, U-Boot image.h header definitions file
-0      belong    0x27051956     uImage header, header size: 64 bytes,
->4     ubelong   x              header CRC: 0x%X,
->8     bedate    x              created: %s,
->12    belong    <1             {invalid}
->12    ubelong   x              image size: %d bytes,
->16    ubelong   x              Data Address: 0x%X,
->20    ubelong   x              Entry Point: 0x%X,
->24    ubelong   x              data CRC: 0x%X,
->28    byte      0              OS: {invalid}invalid OS,
->28    byte      1              OS: OpenBSD,
->28    byte      2              OS: NetBSD,
->28    byte      3              OS: FreeBSD,
->28    byte      4              OS: 4.4BSD,
->28    byte      5              OS: Linux,
->28    byte      6              OS: SVR4,
->28    byte      7              OS: Esix,
->28    byte      8              OS: Solaris,
->28    byte      9              OS: Irix,
->28    byte      10             OS: SCO,
->28    byte      11             OS: Dell,
->28    byte      12             OS: NCR,
->28    byte      13             OS: LynxOS,
->28    byte      14             OS: VxWorks,
->28    byte      15             OS: pSOS,
->28    byte      16             OS: QNX,
->28    byte      17             OS: Firmware,
->28    byte      18             OS: RTEMS,
->28    byte      19             OS: ARTOS,
->28    byte      20             OS: Unity OS,
->29    byte      0              CPU: {invalid}invalid CPU,
->29    byte      1              CPU: Alpha,
->29    byte      2              CPU: ARM,
->29    byte      3              CPU: Intel x86,
->29    byte      4              CPU: IA64,
->29    byte      5              CPU: MIPS,
->29    byte      6              CPU: MIPS 64 bit,
->29    byte      7              CPU: PowerPC,
->29    byte      8              CPU: IBM S390,
->29    byte      9              CPU: SuperH,
->29    byte      10             CPU: Sparc,
->29    byte      11             CPU: Sparc 64 bit,
->29    byte      12             CPU: M68K,
->29    byte      13             CPU: Nios-32,
->29    byte      14             CPU: MicroBlaze,
->29    byte      15             CPU: Nios-II,
->29    byte      16             CPU: Blackfin,
->29    byte      17             CPU: AVR,
->29    byte      18             CPU: STMicroelectronics ST200,
-#>30    byte    x        image type: %d,
->30    byte      0              image type: {invalid} Image,
->30    byte      1              image type: Standalone Program,
->30    byte      2              image type: OS Kernel Image,
->30    byte      3              image type: RAMDisk Image,
->30    byte      4              image type: Multi-File Image,
->30    byte      5              image type: Firmware Image,
->30    byte      6              image type: Script file,
->30    byte      7              image type: Filesystem Image,
->30    byte      8              image type: Binary Flat Device Tree Blob
->31    byte      0              compression type: none,
->31    byte      1              compression type: gzip,
->31    byte      2              compression type: bzip2,
->31    byte      3              compression type: lzma,
->32    string    x              image name: "%s"
-
-#IMG0 header, found in VxWorks-based Mercury router firmware
-0       string        IMG0    IMG0 (VxWorks) header,
->4      belong        <1      {invalid}
->4      belong        x       size: %d
-
-#Mediatek bootloader signature
-#From xp-dev.com
-0    string        BOOTLOADER!    Mediatek bootloader
-
-#CSYS header formats
-0    string        CSYS\x00    CSYS header, little endian, 
->8   lelong        x           size: %d
-
-0    string        CSYS\x80    CSYS header, big endian,
->8   belong        x           size: %d
-
-# wrgg firmware image
-0       string        wrgg02    WRGG firmware header,
->6      string        x         name: "%s",
->48     string        x         root device: "%s"
-
-# trx image file
-0       string        HDR0    TRX firmware header, little endian,
->4      lelong        <1      {invalid}
->4      ulelong       x       image size: %d bytes,
->8      ulelong       x       CRC32: 0x%X,
->12     uleshort      x       flags: 0x%X,
->14     uleshort      !1
->>14    uleshort      !2      {invalid}
->14     uleshort      2       version: %d, header size: 32 bytes,
->>16    ulelong       x       loader offset: 0x%X,
->>20    ulelong       x       linux kernel offset: 0x%X,
->>24    ulelong       x       rootfs offset: 0x%X,
->>28    ulelong       x       bin-header offset: 0x%X
->14     uleshort      1       version: %d, header size: 28 bytes,
->>16    ulelong       x       loader offset: 0x%X,
->>20    ulelong       x       linux kernel offset: 0x%X,
->>24    ulelong       x       rootfs offset: 0x%X
-
-14      string        U2ND      BIN-Header,
->4      ulelong       !0        {invalid}
->22     string        !\x00*10  {invalid}
->0      string        x         board ID: %.4s,
->18     ubyte         0         hardware version: 4702,
->18     ubyte         1         hardware version: 4712,
->18     ubyte         2         hardware version: 4712L,
->18     ubyte         3         hardware version: 4704,
->18     ubyte         >3        hardware version: unknown (code: 0x%.2X),
->11     ubyte         x         firmware version: %d.
->12     ubyte         x         \b%d.
->12     ubyte         x         \b%d,
->8      ubyte         <80
->>8     ubyte         x         build date: 20%.2d-
->8      ubyte         >79
->>8     ubyte         x         build date: 19%.2d-
->9      ubyte         x         \b%.2d-
->10     ubyte         x         \b%.2d
-
-# Ubicom firmware image
-0       belong    0xFA320080    Ubicom firmware header,
->12     ubelong   x             checksum: 0x%X,
->24     belong    <0            {invalid}
->24     belong    x             image size: %d
-
-# The ROME bootloader is used by several RealTek-based products.
-# Unfortunately, the magic bytes are specific to each product, so
-# separate signatures must be created for each one.
-
-# Netgear KWGR614 ROME image
-0     string         G614          Realtek firmware header, ROME bootloader,
->4    beshort        0xd92f        image type: KFS,
->4    beshort        0xb162        image type: RDIR,
->4    beshort        0xea43        image type: BOOT,
->4    beshort        0x8dc9        image type: RUN,
->4    beshort        0x2a05        image type: CCFG,
->4    beshort        0x6ce8        image type: DCFG,
->4    beshort        0xc371        image type: LOG,
->6    byte           x             header version: %d,
->10   ubyte          >12           {invalid} month
->12   ubyte          >31           {invalid} day
->8    ubyte          >3000         {invalid} year
-#month
->10   byte           x             created: %d/
-#day    
->12   byte           x             \b%d/
-#year
->8    beshort        x             \b%d,
->16   belong         x             image size: %d bytes,
->22   ubyte          x             body checksum: 0x%X,
->23   ubyte          x             header checksum: 0x%X
-
-# Linksys WRT54GX ROME image
-0       belong          0x59a0e842      Realtek firmware header, ROME bootloader,
->4      ubeshort        0xd92f          image type: KFS,
->4      ubeshort        0xb162          image type: RDIR,
->4      ubeshort        0xea43          image type: BOOT,
->4      ubeshort        0x8dc9          image type: RUN,
->4      ubeshort        0x2a05          image type: CCFG,
->4      ubeshort        0x6ce8          image type: DCFG,
->4      ubeshort        0xc371          image type: LOG,
->6      byte            x               header version: %d,
->10     ubyte           >12             {invalid}invalid month
->12     ubyte           >31             {invalid}invalid day
->8      ubyte           >3000           {invalid}invalid year
-#month
->10     byte            x               created: %d/
-#day    
->12     byte            x               \b%d/
-#year
->8      beshort         x               \b%d,
->16     belong          x               image size: %d bytes,
->22     ubyte           x               body checksum: 0x%X,
->23     ubyte           x               header checksum: 0x%X
-
-# PackImg tag, somtimes used as a delimiter between the kernel and rootfs in firmware images.
-0       string        --PaCkImGs      PackImg section delimiter tag,
->10     string        !--             {invalid}
-# If the size in both big and little endian is greater than 512MB, consider this a false positive
->16     ulelong       >0x20000000
->>16    ubelong       >0x20000000    {invalid}
->16     lelong        <0
->>16    belong        <0             {invalid}
->16     lelong        >0
->>16    lelong        x              little endian size: %d bytes;
->16     belong        >0        
->>16    belong        x              big endian size: %d bytes
-
-
-#------------------------------------------------------------------------------
-# Broadcom header format
-#
-0       string          BCRM            Broadcom header,
->4      lelong          <0              {invalid}
->4      lelong          x               number of sections: %d,
->>8     lelong          18              first section type: flash
->>8     lelong          19              first section type: disk
->>8     lelong          21              first section type: tag
-
-
-# Berkeley Lab Checkpoint Restart (BLCR) checkpoint context files
-# http://ftg.lbl.gov/checkpoint
-0       string  Ck0\0\0R\0\0\0  BLCR
->16     lelong  0               {invalid}
->16     ulelong >7              {invalid}
->16     lelong  1               x86
->16     lelong  3               alpha
->16     lelong  5               x86-64
->16     lelong  7               ARM
->8      lelong  x               context data (little endian, version %d)
-
-0       string  \0\0\0C\0\0\0R  BLCR
->16     lelong  <2              {invalid}
->16     ulelong >8              {invalid}
->16     belong  2               SPARC
->16     belong  4               ppc
->16     belong  6               ppc64
->16     belong  7               ARMEB
->16     belong  8               SPARC64
->8      belong  x               context data (big endian, version %d)
-
-# Aculab VoIP firmware
-# From: Mark Brown <broonie@sirena.org.uk>
-0       string  VoIP\x20Startup\x20and      Aculab VoIP firmware
->35     string  x                           format "%s"
-
-#------------------------------------------------------------------------------
-# HP LaserJet 1000 series downloadable firmware file
-0       string  \xbe\xefABCDEFGH        HP LaserJet 1000 series downloadable firmware
-
-# From Albert Cahalan <acahalan@gmail.com>
-# really le32 operation,destination,payloadsize (but quite predictable)
-# 01 00 00 00 00 00 00 c0 00 02 00 00
-0       string          \1\0\0\0\0\0\0\300\0\2\0\0      Marvell Libertas firmware
-
-#---------------------------------------------------------------------------
-# The following entries have been tested by Duncan Laurie <duncan@sun.com> (a
-# lead Sun/Cobalt developer) who agrees that they are good and worthy of
-# inclusion.
-
-# Boot ROM images for Sun/Cobalt Linux server appliances
-0       string  Cobalt\x20Networks\x20Inc.\nFirmware\x20v     Paged COBALT boot rom
->38     string  x                                             V%.4s
-
-# New format for Sun/Cobalt boot ROMs is annoying, it stores the version code
-# at the very end where file(1) can't get it.
-0       string CRfs     COBALT boot rom data (Flat boot rom or file system)
-
-#
-# Motorola S-Records, from Gerd Truschinski <gt@freebsd.first.gmd.de>
-# Useless until forther improvements can be made to the signature.
-#0   string      S0          Motorola S-Record; binary data in text format
-
-#Windows CE Binary Image Data Format aka B000FF
-#More information on the format:
-#http://msdn.microsoft.com/en-us/library/ms924510.aspx
-#http://forum.xda-developers.com/showthread.php?t=801167
-0    string    B000FF    Windows CE image header,
->7   ulelong   x         image start: 0x%X,
->11  ulelong   x         image length: %d
-
-
-#Windows CE RomImage
-63    string    \x00ECEC     Windows CE memory segment header,
->4    ulelong   x            TOC address: 0x%X
-
-
-# --------------------------------
-# ZynOS ROM header format
-# From openwrt zynos.h.
-6      string      SIG          ZynOS header, header size: 48 bytes,
->3     byte        <0x7F        rom image type:
->>3    byte        <1           {invalid},
->>3    byte        >7           {invalid},
->>3    byte        1            ROMIMG,
->>3    byte        2            ROMBOOT,
->>3    byte        3            BOOTEXT,
->>3    byte        4            ROMBIN,
->>3    byte        5            ROMDIR,
->>3    byte        6            6,
->>3    byte        7            ROMMAP,
->3     byte        >0x7F        ram image type:
->>3    byte        >0x82        {invalid},
->>3    byte        0x80         RAM,
->>3    byte        0x81         RAMCODE,
->>3    byte        0x82         RAMBOOT,
->4     ubelong     >0x40000000  {invalid}
->4     belong      <0           {invalid}
->4     belong      0            {invalid}
->4     belong      x            uncompressed size: %d,
->8     belong      >0x40000000  {invalid}
->8     belong      <0           {invalid}
->8     belong      0            {invalid}
->8     belong      x            compressed size: %d,
->14    ubeshort    x            uncompressed checksum: 0x%X,
->16    ubeshort    x            compressed checksum: 0x%X,
->12    ubyte       x            flags: 0x%X,
->12    byte        &0x40        uncompressed checksum is valid,
->12    ubyte       &0x80        the binary is compressed,
->>12   byte        &0x20        compressed checksum is valid,
->35    ubelong     x            memory map table address: 0x%X
-
-# Firmware header used by some VxWorks-based Cisco products
-0      string        CI032.00       Cisco VxWorks firmware header,
->8     lelong        >1024          {invalid}
->8     lelong        <0             {invalid}
->8     lelong        x              header size: %d bytes,
->32    lelong        >1024          {invalid}
->32    lelong        <0             {invalid}
->32    lelong        x              number of files: %d,
->48    lelong        <0             {invalid}
->48    lelong        x              image size: %d,
->64    string        x              firmware version: "%s"
-
-# Simple VxWorks reference strings
-#0    string        VxWorks        VxWorks string referece:
-#>0    string        x            "%s"
-#0    string        vxworks        VxWorks string referece:
-#>0    string        x            "%s"
-#0    string        VXWORKS        VxWorks string referece:
-#>0    string        x            "%s"
-
-# Firmware header used by some TV's
-0      string        FNIB     ZBOOT firmware header, header size: 32 bytes,
->8     ulelong       x        load address: 0x%.8X,
->12    ulelong       x        start address: 0x%.8X,
->16    ulelong       x        checksum: 0x%.8X,
->20    ulelong       x        version: 0x%.8X,
->24    lelong        <1       {invalid}
->24    ulelong       x        image size: %d bytes
-
-# Firmware header used by several D-Link routers (and probably others)
-0               string  \x5e\xa3\xa4\x17        DLOB firmware header,{jump:108}
->(7.b+12)       string  !\x5e\xa3\xa4\x17       {invalid},
-#>>12           string  x                       %s,
->(7.b+40)       string  x                       boot partition: "%s"
-
-# TP-Link firmware header structure; thanks to Jonathan McGowan for reversing and documenting this format
-4          string          TP-LINK\x20Technologies TP-Link firmware header,
-#>-4    lelong          x                       header version: %d,
->0x94      beshort         x                       firmware version: %d.
->0x96      beshort         x                       \b%d.
->0x98      beshort         x                       \b%d,
->0x18      string          x                       image version: "%s",
-#>0x74  belong          x                       image size: %d bytes,
->0x3C      belong          x                       product ID: 0x%X,
->0x40      belong          x                       product version: %d,
->0x70      ubelong         x                       kernel load address: 0x%X,
->0x74      ubelong         x                       kernel entry point: 0x%X,
->0x7C      ubelong         x                       kernel offset: %d,
->0x80      ubelong         x                       kernel length: %d,
->0x84      ubelong         x                       rootfs offset: %d,
->0x88      ubelong         x                       rootfs length: %d,
->0x8C      ubelong         x                       bootloader offset: %d,
->0x90      ubelong         x                       bootloader length: %d
-
-# Header format from: http://skaya.enix.org/wiki/FirmwareFormat
-0       string        \x36\x00\x00\x00          Broadcom 96345 firmware header, header size: 256,
->4      string        !Broadcom
->>4     string        !\x20\x20\x20\x20         {invalid}
->41     beshort       !0x2020
->>41    beshort       !0x0000
->>>41   string        x                         firmware version: "%.4s",
->45     beshort       !0x0202
->>45    beshort       !0x0000
->>>45   string        x                         board id: "%s",
->236    ubelong       x                         ~CRC32 header checksum: 0x%X,
->216    ubelong       x                         ~CRC32 data checksum: 0x%X
-
-# Xerox MFP DLM signatures
-0       string        %%XRXbegin                Xerox DLM firmware start of header
-0       string        %%OID_ATT_DLM_NAME        Xerox DLM firmware name:
->19     string        x                         "%s"
-0       string        %%OID_ATT_DLM_VERSION     Xerox DLM firmware version:
->22     string        x                         "%s"
-0       string        %%XRXend                  Xerox DLM firmware end of header
-
-# Generic copyright signature
-0       string      Copyright        Copyright string:
->9      byte        0                {invalid}
->0      string      x                "%s"
-
-0       string      copyright        Copyright string:
->9      byte        0                {invalid}
->0      string      x                "%s"
-
-# Sercomm firmware header
-0       string         sErCoMm          Sercomm firmware signature,
->7      leshort        x                version control: %d,
->9      leshort        x                download control: %d,
->11     string         x                hardware ID: "%s",
->44     uleshort       x                hardware version: 0x%X,
->58     uleshort       x                firmware version: 0x%X,
->60     uleshort       x                starting code segment: 0x%X,
->62     uleshort       x                code size: 0x%X
-
-# NPK firmware header, used by Mikrotik
-0           belong        0x1EF1D0BA   NPK firmware header,
->4          lelong        <0           {invalid}
->4          lelong        x            image size: %d,
->14         string        x            image name: "%s",
->(48.l+58)  string        x            description: "%s"
-
-# Ubiquiti firmware signatures
-0       string      UBNT        Ubiquiti firmware header, header size: 264 bytes,
->0x108  belong      !0          {invalid},
->0x104  ubelong     x           ~CRC32: 0x%X,
->4      byte        0           {invalid},
->4      string      x           version: "%s"
-
-0       string      GEOS        Ubiquiti firmware header, header size: 264 bytes,
->0x108  belong      !0          {invalid},
->0x104  ubelong     x           ~CRC32: 0x%X,
->4      byte        0           {invalid},
->4      string      x           version: "%s"
-
-0       string      OPEN        Ubiquiti firmware header, third party,
->0x108  belong      !0          {invalid},
->0x104  ubelong     x           ~CRC32: 0x%X,
->4      byte        0           {invalid},
->4      string      x           version: "%s"
-
-4   string      \x00\x00\x00\x00PART    Ubiquiti partition header,
->0  byte        x                       header size: 56 bytes,
->8  byte        0                       {invalid}
->8  string      x                       name: "%s",
->44 ubelong     x                       base address: 0x%.8X,
->52 belong      x                       data size: %d bytes{size:%d}
-
-4   string      \x00\x00\x00\x00END\x2e Ubiquiti end header, header size: 12 bytes,
->12 belong      !0                      {invalid},
->8  ubelong     x                       cumulative ~CRC32: 0x%.8X
-
-
-# Found in DIR-100 firmware
-0       string      AIH0N       AIH0N firmware header, header size: 48,
->12     belong      x           size: %d,
->8      belong      !0          executable code,
->>8     belong      x           load address: 0x%X,
->32     string      x           version: "%s"
-
-0       belong      0x5EA3A417      SEAMA firmware header, big endian,
->4      beshort     !0              {invalid}
->6      beshort     x               meta size: %d,
->8      belong      <1              {invalid}
->8      belong      x               image size: %d
-
-0       lelong      0x5EA3A417      SEAMA firmware header, little endian,
->4      leshort     !0              {invalid}
->6      leshort     x               meta size: %d,
->8      lelong      <1              {invalid}
->8      lelong      x               image size: %d
-
-0       belong      0x4D544443      NSP firmware header, big endian,
->16     belong      <1              {invalid}
->16     belong      x               header size: %d,
->20     belong      <1              {invalid}
->20     belong      x               image size: %d,
->20     belong      x               {size:%d}
->4      belong      <1              {invalid}
->4      ubelong     x               kernel offset: %d,
->12     belong      <1              {invalid}
->12     belong      x               header version: %d,
-
-0       lelong      0x4D544443      NSP firmware header, little endian,
->16     lelong      <1              {invalid}
->16     lelong      x               header size: %d,
->20     lelong      <1              {invalid}
->20     lelong      x               image size: %d,
->20     lelong      x               {size:%d}
->4      lelong      <1              {invalid}
->4      ulelong     x               kernel offset: %d,
->12     lelong      <1              {invalid}
->12     lelong      x               header version: %d,
-
-# http://www.openwiz.org/wiki/Firmware_Layout#Beyonwiz_.wrp_header_structure
-0       string        WizFwPkgl    Beyonwiz firmware header,
->20     string        x            version: "%s"
-
-0       string      BLI223WJ0   Thompson/Alcatel encoded firmware,
->32     byte        x           version: %d.
->33     byte        x           \b%d.
->34     byte        x           \b%d.
->35     byte        x           \b%d,
->44     belong      x           size: %d,
->48     ubelong     x           crc: 0x%.8X,
->35     byte        x           try decryption tool from:
->35     byte        x           http://download.modem-help.co.uk/mfcs-A/Alcatel/Modems/Misc/
-
-16    string        \xd9\x54\x93\x7a\x68\x04\x4a\x44\x81\xce\x0b\xf6\x17\xd8\x90\xdf    UEFI PI firmware volume
-
-# http://android.stackexchange.com/questions/23357/\
-# is-there-a-way-to-look-inside-and-modify-an-adb-backup-created-file/\
-# 23608#23608
-0       string  ANDROID\040BACKUP\n     Android Backup
->15     string  1\n                     \b, version 1
->17     string  0\n                     \b, uncompressed
->17     string  1\n                     \b, compressed
->19     string  none\n                  \b, unencrypted
->19     string  AES-256\n               \b, encrypted AES-256
-
-# http://forum.xda-developers.com/showthread.php?p=47818657
-8    string    imgARMcC         Roku aimage SB
-
-# Boot ROM images for Sun/Cobalt Linux server appliances
-0       string    Cobalt\ Networks\ Inc.\nFirmware\ v    Paged Sun/COBALT boot rom,
->38     string    x                        version: "%.4s"
-
-# Simple eCos string signatures
-0        string    ecos                    eCos RTOS string reference:
->0       string    x                       "%s"
-0        string    eCos                    eCos RTOS string reference:
->0       string    x                       "%s"
-0        string    ECOS                    eCos RTOS string reference:
->0       string    x                       "%s"
-
-# ZyXEL config signatures
-6           string      dbgarea                  ZyXEL rom-0 configuration block, name: "%s",
->16         ubeshort    x                        compressed size: %d,
->14         ubeshort    x                        uncompressed size: %d,
->18         ubeshort+16 x                        data offset from start of block: %d
-
-6           string      spt.dat                  ZyXEL rom-0 configuration block, name: "%s",
->16         ubeshort    x                        compressed size: %d,
->14         ubeshort    x                        uncompressed size: %d,
->18         ubeshort+16 x                        data offset from start of block: %d
-
-6           string      autoexec.net             ZyXEL rom-0 configuration block, name: "%s",
->16         ubeshort    x                        compressed size: %d,
->14         ubeshort    x                        uncompressed size: %d,
->18         ubeshort+16 x                        data offset from start of block: %d
-
-# Obfuscated Arcadyan firmware
-0x68    string  \x00\xD5\x08                    Obfuscated Arcadyan firmware,
->0x6B   byte    !0                              {invalid} signature trailing byte [0x%X],{invalid}
-# None of the known Arcadyan signatures bytes have a NULL byte
->0      byte    0                               {invalid}
->1      byte    0                               {invalid}
->2      byte    0                               {invalid}
->3      byte    0                               {invalid}
->0      ubelong x                               signature bytes: 0x%X,
->0x70   string  !\x00\x00\x00\x00\x00\x00       {invalid} padding bytes{invalid}
-
-# Digi firmware images
-0xC0            string  Digi            Digi International firmware,
->0xC8           beshort !0x4253
->>0xC8          beshort !0x4950
->>>0xC8         beshort !0x4944
->>>>0xC8        beshort !0x444f
->>>>>0xC8       beshort !0x4443
->>>>>>0xC8      beshort !0x4f53
->>>>>>>0xC8     beshort !0x4f43
->>>>>>>>0xC8    beshort !0x4646
->>>>>>>>>0xC8   beshort !0x5350         {invalid}invalid header,
->0xD4           ubelong x               load address: 0x%.8X,
->0xDC           ubelong x               entry point: 0x%.8X,
-
-# Lancom firmware signatures, courtesy of christophvw
-0    string            ELSF              LANCOM firmware header,
->22  string            x                 model: "%s",
->18  string            x                 firmware version: "%.4s",
->12  ubyte             255               Rel,
->12  ubyte             253               alpha,
->12  ubyte             220               PR,
->12  ubyte             >0
->>12 ubyte             <220              RC%d,
->12  ubyte             >220
->>12 ubyte-220         <237              RU%d,
->12  ubyte             0                 dev
->17  ubyte             >0
->>17 ubyte             x                 build %d
-#get build date
->7   ubyte             !63
-#date is stored as string
->>7  string            x                 ("%.8s")
-
-0    string            ELSO              LANCOM OEM file
-
-0    string            ELSB              LANCOM firmware loader,
->22  string            x                 model: "%s",
->18  string            x                 loader version: "%.4s",
-
-
-0    string            ELSC              LANCOM WWAN firmware
->4   ubyte             3
->>5  beshort           0
->>7  string            x                 \b, "%s"
-
-0               string      ELSP                    LANCOM file entry
->(198.L+202)    belong      !2
->>(198.L+202)   belong      !3                      {invalid}
->202            string      @(RECENT_FIRMWARE)/     \b, file name:
->>221           string      x                       "%s"
->>221           string      x                       \b{name:%s}
->(198.L+202)    belong      2
->>(198.L+206)   belong      <1                      {invalid}
->>(198.L+206)   belong      x                       \b, file size: %d bytes
->>(198.L+206)   belong      x                       \b{size:%d}
->(198.L+202)    belong      3
->>&4            string      @(RECENT_FIRMWARE)/     \b, alias:
->>&23           string      x                       "%s"
->>(&0.L+4)      belong      x                       \b, file size: %d bytes
-
-# Another Broadcom firmware header...
-# The header seems to be always 0x100 bytes length and there is more information than the one displayed (not sure about the meaning).
-# Used for example in the EchoLife HG556a router
-0x0	string 	\x38\x00\x00\x00	Broadcom firmware header
->0x4	string	!Broadcom Corporatio	{invalid}
->0x18	string	x			%s.
->0x8E	string	x			Model: %s.
->0xA2	string	x			Firmware version: %s.
-
-# QNAP encrypted firmware
-0       string       icpnas                  QNAP encrypted firmware footer
->10     string       x                       , model: %s
->26     string       x                       , version: %s
->42     uleshort     !0
->>42    string       x                       , date: %s
-
-# Mediatek
-0   string  SF_BOOT\x00\x00\x00\x00\x00  Mediatek Serial Flash Image
->12 lelong <1 {invalid}
->12 lelong >1 {invalid}
->12 lelong x  Version %d
-0   string  EMMC_BOOT\x00\x00\x00    Mediatek EMMC Flash Image
->12 lelong <1 {invalid}
->12 lelong >1 {invalid}
->12 lelong x  Version %d
-0   string  NOR_BOOT\x00\x00\x00\x00 Mediatek NOR Flash Image
->12 lelong <1 {invalid}
->12 lelong >1 {invalid}
->12 lelong x  Version %d
-
-0  string BRLYT\x00\x00\x00 Mediatek Boot Header
->8 lelong <1 {invalid}
->8 lelong >1 {invalid}
->8 lelong x Version %d
-
-0 string BBBB Boot section{overlap}
->8 lelong x Start 0x%X
->12 lelong x End 0x%X
->16 lelong &0x1 Load-by-Bootrom
->16 lelong &0x80000000 Internal-RAM
->16 lelong &0x7ffffff0 {invalid}
-
-0 string FILE_INFO\x00\x00\x00 Mediatek File Info
->12 lelong <1 {invalid}
->12 lelong >1 {invalid}
->16 leshort 0 File Type: NONE
->16 leshort 1 File Type: ARM-Bootloader 
->16 leshort 2 File Type: ARM-External-Bootloader
->16 leshort 10 File Type: Root-Certificate
->16 leshort 256 File Type: Primary-MAUI
->16 leshort 264 File Type: VIVA
->16 leshort 769 File Type: SECURE_RO_ME
->18 byte 0 Flash Type: NONE
->18 byte 1 Flash Type: NOR Flash
->18 byte 2 Flash Type: NAND Sequential Flash
->18 byte 3 Flash Type: NAND_TTBL
->18 byte 4 Flash Type: NAND_FDM50
->18 byte 5 EMMC-Boot-Region
->18 byte 6 EMMC-Data-Region
->18 byte 7 Flash Type: Serial Flash
->18 byte 255 Flash Type: Device-End
->18 byte >20 {invalid}
->19 byte 0 No Signature
->19 byte 1 Signature Type: PHASH
->19 byte 2 Signature Type: SINGLE
->19 byte 3 Signature Type: SINGLE and PHASH
->19 byte 4 Signature Type: MULTI
->19 byte 5 Signature Type: TYPE_NUM
->19 byte 255 Signature Type: TYE_END
->19 byte >20 {invalid}
->20 lelong x Load Address: 0x%X
->24 lelong x File Length: %d
->28 lelong x Maximum Size: %d
->32 lelong x Content Offset: 0x%X
->36 lelong x Signature Lenght: %d
->40 lelong x Jump Offset: %d
->44 lelong &0x1 POST_BUILD_DONE
->44 lelong &0x2 XIP (Execute In Place)
->44 lelong &0x4 SLT
->44 lelong &0xffffff00 {invalid}
-
-# Android bootimg
-# https://android.googlesource.com/platform/system/core.git/+/master/mkbootimg/bootimg.h
-0     string     ANDROID!      Android bootimg
->8    ulelong    x             \b, kernel size: %d bytes
->12   ulelong    x             \b, kernel addr: 0x%X
->16   ulelong    x             \b, ramdisk size: %d bytes
->20   ulelong    x             \b, ramdisk addr: 0x%X
->48   string     x             \b, product name: "%s"
-
-
+
+#--------------------------Firmware Formats---------------------------
+
+# uImage file     
+# From: Craig Heffner, U-Boot image.h header definitions file
+0      belong    0x27051956     uImage header, header size: 64 bytes,
+>4     ubelong   x              # header CRC: 0x%X,
+>8     bedate    x              created: %s,
+>12    belong    <1             {invalid}
+>12    ubelong   x              image size: %d bytes,
+>12    ubelong   x              {size:%d+64}
+>16    ubelong   x              Data Address: 0x%X,
+>20    ubelong   x              Entry Point: 0x%X,
+>24    ubelong   x              # data CRC: 0x%X,
+>28    byte      0              OS: {invalid}invalid OS,
+>28    byte      1              OS: OpenBSD,
+>28    byte      2              OS: NetBSD,
+>28    byte      3              OS: FreeBSD,
+>28    byte      4              OS: 4.4BSD,
+>28    byte      5              OS: Linux,
+>28    byte      6              OS: SVR4,
+>28    byte      7              OS: Esix,
+>28    byte      8              OS: Solaris,
+>28    byte      9              OS: Irix,
+>28    byte      10             OS: SCO,
+>28    byte      11             OS: Dell,
+>28    byte      12             OS: NCR,
+>28    byte      13             OS: LynxOS,
+>28    byte      14             OS: VxWorks,
+>28    byte      15             OS: pSOS,
+>28    byte      16             OS: QNX,
+>28    byte      17             OS: Firmware,
+>28    byte      18             OS: RTEMS,
+>28    byte      19             OS: ARTOS,
+>28    byte      20             OS: Unity OS,
+>29    byte      0              CPU: {invalid}invalid CPU,
+>29    byte      1              CPU: Alpha,
+>29    byte      2              CPU: ARM,
+>29    byte      3              CPU: Intel x86,
+>29    byte      4              CPU: IA64,
+>29    byte      5              CPU: MIPS,
+>29    byte      6              CPU: MIPS 64 bit,
+>29    byte      7              CPU: PowerPC,
+>29    byte      8              CPU: IBM S390,
+>29    byte      9              CPU: SuperH,
+>29    byte      10             CPU: Sparc,
+>29    byte      11             CPU: Sparc 64 bit,
+>29    byte      12             CPU: M68K,
+>29    byte      13             CPU: Nios-32,
+>29    byte      14             CPU: MicroBlaze,
+>29    byte      15             CPU: Nios-II,
+>29    byte      16             CPU: Blackfin,
+>29    byte      17             CPU: AVR,
+>29    byte      18             CPU: STMicroelectronics ST200,
+>30    byte      0              # image type: {invalid} Image,
+>30    byte      1              # image type: Standalone Program,
+>30    byte      2              # image type: OS Kernel Image,
+>30    byte      3              # image type: RAMDisk Image,
+>30    byte      4              # image type: Multi-File Image,
+>30    byte      5              # image type: Firmware Image,
+>30    byte      6              # image type: Script file,
+>30    byte      7              # image type: Filesystem Image,
+>30    byte      8              # image type: Binary Flat Device Tree Blob
+>31    byte      0              # compression type: none,
+>31    byte      1              # compression type: gzip,
+>31    byte      2              # compression type: bzip2,
+>31    byte      3              # compression type: lzma,
+>32    string    x              image name: "%s"
+
+#IMG0 header, found in VxWorks-based Mercury router firmware
+0       string        IMG0    IMG0 (VxWorks) header,
+>4      belong        <1      {invalid}
+>4      belong        x       size: %d
+
+#Mediatek bootloader signature
+#From xp-dev.com
+0    string        BOOTLOADER!    Mediatek bootloader
+
+#CSYS header formats
+0    string        CSYS\x00    CSYS header, little endian, 
+>8   lelong        x           size: %d
+
+0    string        CSYS\x80    CSYS header, big endian,
+>8   belong        x           size: %d
+
+# wrgg firmware image
+0       string        wrgg02    WRGG firmware header,
+>6      string        x         name: "%s",
+>48     string        x         root device: "%s"
+
+# trx image file
+0       string        HDR0    TRX firmware header, little endian,
+>4      lelong        <1      {invalid}
+>4      ulelong       x       # image size: %d bytes,
+>8      ulelong       x       # CRC32: 0x%X,
+>12     uleshort      x       # flags: 0x%X,
+>14     uleshort      !1
+>>14    uleshort      !2      {invalid}
+>14     uleshort      2       version: %d, header size: 32 bytes,
+>>16    ulelong       x       loader offset: 0x%X,
+>>20    ulelong       x       linux kernel offset: 0x%X,
+>>20    ulelong       x       {stub0:%d}
+>>24    ulelong       x       rootfs offset: 0x%X,
+>>24    ulelong       x       {stub1:%d}
+>>28    ulelong       x       # bin-header offset: 0x%X
+>14     uleshort      1       version: %d, header size: 28 bytes,
+>>16    ulelong       x       # loader offset: 0x%X,
+>>20    ulelong       x       linux kernel offset: 0x%X,
+>>20    ulelong       x       {stub0:%d}
+>>24    ulelong       x       rootfs offset: 0x%X
+>>24    ulelong       x       {stub1:%d}
+
+14      string        U2ND      BIN-Header,
+>4      ulelong       !0        {invalid}
+>22     string        !\x00*10  {invalid}
+>0      string        x         board ID: %.4s,
+>18     ubyte         0         hardware version: 4702,
+>18     ubyte         1         hardware version: 4712,
+>18     ubyte         2         hardware version: 4712L,
+>18     ubyte         3         hardware version: 4704,
+>18     ubyte         >3        hardware version: unknown (code: 0x%.2X),
+>11     ubyte         x         firmware version: %d.
+>12     ubyte         x         \b%d.
+>12     ubyte         x         \b%d,
+>8      ubyte         <80
+>>8     ubyte         x         build date: 20%.2d-
+>8      ubyte         >79
+>>8     ubyte         x         build date: 19%.2d-
+>9      ubyte         x         \b%.2d-
+>10     ubyte         x         \b%.2d
+
+# Ubicom firmware image
+0       belong    0xFA320080    Ubicom firmware header,
+>12     ubelong   x             checksum: 0x%X,
+>24     belong    <0            {invalid}
+>24     belong    x             image size: %d
+
+# The ROME bootloader is used by several RealTek-based products.
+# Unfortunately, the magic bytes are specific to each product, so
+# separate signatures must be created for each one.
+
+# Netgear KWGR614 ROME image
+0     string         G614          Realtek firmware header, ROME bootloader,
+>4    beshort        0xd92f        image type: KFS,
+>4    beshort        0xb162        image type: RDIR,
+>4    beshort        0xea43        image type: BOOT,
+>4    beshort        0x8dc9        image type: RUN,
+>4    beshort        0x2a05        image type: CCFG,
+>4    beshort        0x6ce8        image type: DCFG,
+>4    beshort        0xc371        image type: LOG,
+>6    byte           x             header version: %d,
+>10   ubyte          >12           {invalid} month
+>12   ubyte          >31           {invalid} day
+>8    ubyte          >3000         {invalid} year
+#month
+>10   byte           x             created: %d/
+#day    
+>12   byte           x             \b%d/
+#year
+>8    beshort        x             \b%d,
+>16   belong         x             image size: %d bytes,
+>22   ubyte          x             body checksum: 0x%X,
+>23   ubyte          x             header checksum: 0x%X
+
+# Linksys WRT54GX ROME image
+0       belong          0x59a0e842      Realtek firmware header, ROME bootloader,
+>4      ubeshort        0xd92f          image type: KFS,
+>4      ubeshort        0xb162          image type: RDIR,
+>4      ubeshort        0xea43          image type: BOOT,
+>4      ubeshort        0x8dc9          image type: RUN,
+>4      ubeshort        0x2a05          image type: CCFG,
+>4      ubeshort        0x6ce8          image type: DCFG,
+>4      ubeshort        0xc371          image type: LOG,
+>6      byte            x               header version: %d,
+>10     ubyte           >12             {invalid}invalid month
+>12     ubyte           >31             {invalid}invalid day
+>8      ubyte           >3000           {invalid}invalid year
+#month
+>10     byte            x               created: %d/
+#day    
+>12     byte            x               \b%d/
+#year
+>8      beshort         x               \b%d,
+>16     belong          x               image size: %d bytes,
+>22     ubyte           x               body checksum: 0x%X,
+>23     ubyte           x               header checksum: 0x%X
+
+# PackImg tag, somtimes used as a delimiter between the kernel and rootfs in firmware images.
+0       string        --PaCkImGs      PackImg section delimiter tag,
+>10     string        !--             {invalid}
+# If the size in both big and little endian is greater than 512MB, consider this a false positive
+>16     ulelong       >0x20000000
+>>16    ubelong       >0x20000000    {invalid}
+>16     lelong        <0
+>>16    belong        <0             {invalid}
+>16     lelong        >0
+>>16    lelong        x              little endian size: %d bytes;
+>16     belong        >0        
+>>16    belong        x              big endian size: %d bytes
+
+
+#------------------------------------------------------------------------------
+# Broadcom header format
+#
+0       string          BCRM            Broadcom header,
+>4      lelong          <0              {invalid}
+>4      lelong          x               number of sections: %d,
+>>8     lelong          18              first section type: flash
+>>8     lelong          19              first section type: disk
+>>8     lelong          21              first section type: tag
+
+
+# Berkeley Lab Checkpoint Restart (BLCR) checkpoint context files
+# http://ftg.lbl.gov/checkpoint
+0       string  Ck0\0\0R\0\0\0  BLCR
+>16     lelong  0               {invalid}
+>16     ulelong >7              {invalid}
+>16     lelong  1               x86
+>16     lelong  3               alpha
+>16     lelong  5               x86-64
+>16     lelong  7               ARM
+>8      lelong  x               context data (little endian, version %d)
+
+0       string  \0\0\0C\0\0\0R  BLCR
+>16     lelong  <2              {invalid}
+>16     ulelong >8              {invalid}
+>16     belong  2               SPARC
+>16     belong  4               ppc
+>16     belong  6               ppc64
+>16     belong  7               ARMEB
+>16     belong  8               SPARC64
+>8      belong  x               context data (big endian, version %d)
+
+# Aculab VoIP firmware
+# From: Mark Brown <broonie@sirena.org.uk>
+0       string  VoIP\x20Startup\x20and      Aculab VoIP firmware
+>35     string  x                           format "%s"
+
+#------------------------------------------------------------------------------
+# HP LaserJet 1000 series downloadable firmware file
+0       string  \xbe\xefABCDEFGH        HP LaserJet 1000 series downloadable firmware
+
+# From Albert Cahalan <acahalan@gmail.com>
+# really le32 operation,destination,payloadsize (but quite predictable)
+# 01 00 00 00 00 00 00 c0 00 02 00 00
+0       string          \1\0\0\0\0\0\0\300\0\2\0\0      Marvell Libertas firmware
+
+#---------------------------------------------------------------------------
+# The following entries have been tested by Duncan Laurie <duncan@sun.com> (a
+# lead Sun/Cobalt developer) who agrees that they are good and worthy of
+# inclusion.
+
+# Boot ROM images for Sun/Cobalt Linux server appliances
+0       string  Cobalt\x20Networks\x20Inc.\nFirmware\x20v     Paged COBALT boot rom
+>38     string  x                                             V%.4s
+
+# New format for Sun/Cobalt boot ROMs is annoying, it stores the version code
+# at the very end where file(1) can't get it.
+0       string CRfs     COBALT boot rom data (Flat boot rom or file system)
+
+#
+# Motorola S-Records, from Gerd Truschinski <gt@freebsd.first.gmd.de>
+# Useless until forther improvements can be made to the signature.
+#0   string      S0          Motorola S-Record; binary data in text format
+
+#Windows CE Binary Image Data Format aka B000FF
+#More information on the format:
+#http://msdn.microsoft.com/en-us/library/ms924510.aspx
+#http://forum.xda-developers.com/showthread.php?t=801167
+0    string    B000FF    Windows CE image header,
+>7   ulelong   x         image start: 0x%X,
+>11  ulelong   x         image length: %d
+
+
+#Windows CE RomImage
+63    string    \x00ECEC     Windows CE memory segment header,
+>4    ulelong   x            TOC address: 0x%X
+
+
+# --------------------------------
+# ZynOS ROM header format
+# From openwrt zynos.h.
+6      string      SIG          ZynOS header, header size: 48 bytes,
+>3     byte        <0x7F        rom image type:
+>>3    byte        <1           {invalid},
+>>3    byte        >7           {invalid},
+>>3    byte        1            ROMIMG,
+>>3    byte        2            ROMBOOT,
+>>3    byte        3            BOOTEXT,
+>>3    byte        4            ROMBIN,
+>>3    byte        5            ROMDIR,
+>>3    byte        6            6,
+>>3    byte        7            ROMMAP,
+>3     byte        >0x7F        ram image type:
+>>3    byte        >0x82        {invalid},
+>>3    byte        0x80         RAM,
+>>3    byte        0x81         RAMCODE,
+>>3    byte        0x82         RAMBOOT,
+>4     ubelong     >0x40000000  {invalid}
+>4     belong      <0           {invalid}
+>4     belong      0            {invalid}
+>4     belong      x            uncompressed size: %d,
+>8     belong      >0x40000000  {invalid}
+>8     belong      <0           {invalid}
+>8     belong      0            {invalid}
+>8     belong      x            compressed size: %d,
+>14    ubeshort    x            uncompressed checksum: 0x%X,
+>16    ubeshort    x            compressed checksum: 0x%X,
+>12    ubyte       x            flags: 0x%X,
+>12    byte        &0x40        uncompressed checksum is valid,
+>12    ubyte       &0x80        the binary is compressed,
+>>12   byte        &0x20        compressed checksum is valid,
+>35    ubelong     x            memory map table address: 0x%X
+
+# Firmware header used by some VxWorks-based Cisco products
+0      string        CI032.00       Cisco VxWorks firmware header,
+>8     lelong        >1024          {invalid}
+>8     lelong        <0             {invalid}
+>8     lelong        x              header size: %d bytes,
+>32    lelong        >1024          {invalid}
+>32    lelong        <0             {invalid}
+>32    lelong        x              number of files: %d,
+>48    lelong        <0             {invalid}
+>48    lelong        x              image size: %d,
+>64    string        x              firmware version: "%s"
+
+# Simple VxWorks reference strings
+#0    string        VxWorks        VxWorks string referece:
+#>0    string        x            "%s"
+#0    string        vxworks        VxWorks string referece:
+#>0    string        x            "%s"
+#0    string        VXWORKS        VxWorks string referece:
+#>0    string        x            "%s"
+
+# Firmware header used by some TV's
+0      string        FNIB     ZBOOT firmware header, header size: 32 bytes,
+>8     ulelong       x        load address: 0x%.8X,
+>12    ulelong       x        start address: 0x%.8X,
+>16    ulelong       x        checksum: 0x%.8X,
+>20    ulelong       x        version: 0x%.8X,
+>24    lelong        <1       {invalid}
+>24    ulelong       x        image size: %d bytes
+
+# Firmware header used by several D-Link routers (and probably others)
+0               string  \x5e\xa3\xa4\x17        DLOB firmware header,{jump:108}
+>(7.b+12)       string  !\x5e\xa3\xa4\x17       {invalid},
+#>>12           string  x                       %s,
+>(7.b+40)       string  x                       boot partition: "%s"
+
+# TP-Link firmware header structure; thanks to Jonathan McGowan for reversing and documenting this format
+4          string          TP-LINK\x20Technologies TP-Link firmware header,
+#>-4    lelong          x                       header version: %d,
+>0x94      beshort         x                       firmware version: %d.
+>0x96      beshort         x                       \b%d.
+>0x98      beshort         x                       \b%d,
+>0x18      string          x                       image version: "%s",
+#>0x74  belong          x                       image size: %d bytes,
+>0x3C      belong          x                       product ID: 0x%X,
+>0x40      belong          x                       product version: %d,
+>0x70      ubelong         x                       kernel load address: 0x%X,
+>0x74      ubelong         x                       kernel entry point: 0x%X,
+>0x7C      ubelong         x                       kernel offset: %d,
+>0x80      ubelong         x                       kernel length: %d,
+>0x84      ubelong         x                       rootfs offset: %d,
+>0x88      ubelong         x                       rootfs length: %d,
+>0x8C      ubelong         x                       bootloader offset: %d,
+>0x90      ubelong         x                       bootloader length: %d
+
+# Header format from: http://skaya.enix.org/wiki/FirmwareFormat
+0       string        \x36\x00\x00\x00          Broadcom 96345 firmware header, header size: 256,
+>4      string        !Broadcom
+>>4     string        !\x20\x20\x20\x20         {invalid}
+>41     beshort       !0x2020
+>>41    beshort       !0x0000
+>>>41   string        x                         firmware version: "%.4s",
+>45     beshort       !0x0202
+>>45    beshort       !0x0000
+>>>45   string        x                         board id: "%s",
+>236    ubelong       x                         ~CRC32 header checksum: 0x%X,
+>216    ubelong       x                         ~CRC32 data checksum: 0x%X
+
+# Xerox MFP DLM signatures
+0       string        %%XRXbegin                Xerox DLM firmware start of header
+0       string        %%OID_ATT_DLM_NAME        Xerox DLM firmware name:
+>19     string        x                         "%s"
+0       string        %%OID_ATT_DLM_VERSION     Xerox DLM firmware version:
+>22     string        x                         "%s"
+0       string        %%XRXend                  Xerox DLM firmware end of header
+
+# Generic copyright signature
+0       string      Copyright        Copyright string:
+>9      byte        0                {invalid}
+>0      string      x                "%s"
+
+0       string      copyright        Copyright string:
+>9      byte        0                {invalid}
+>0      string      x                "%s"
+
+# Sercomm firmware header
+0       string         sErCoMm          Sercomm firmware signature,
+>7      leshort        x                version control: %d,
+>9      leshort        x                download control: %d,
+>11     string         x                hardware ID: "%s",
+>44     uleshort       x                hardware version: 0x%X,
+>58     uleshort       x                firmware version: 0x%X,
+>60     uleshort       x                starting code segment: 0x%X,
+>62     uleshort       x                code size: 0x%X
+
+# NPK firmware header, used by Mikrotik
+0           belong        0x1EF1D0BA   NPK firmware header,
+>4          lelong        <0           {invalid}
+>4          lelong        x            image size: %d,
+>14         string        x            image name: "%s",
+>(48.l+58)  string        x            description: "%s"
+
+# Ubiquiti firmware signatures
+0       string      UBNT        Ubiquiti firmware header, header size: 264 bytes,
+>0x108  belong      !0          {invalid},
+>0x104  ubelong     x           ~CRC32: 0x%X,
+>4      byte        0           {invalid},
+>4      string      x           version: "%s"
+
+0       string      GEOS        Ubiquiti firmware header, header size: 264 bytes,
+>0x108  belong      !0          {invalid},
+>0x104  ubelong     x           ~CRC32: 0x%X,
+>4      byte        0           {invalid},
+>4      string      x           version: "%s"
+
+0       string      OPEN        Ubiquiti firmware header, third party,
+>0x108  belong      !0          {invalid},
+>0x104  ubelong     x           ~CRC32: 0x%X,
+>4      byte        0           {invalid},
+>4      string      x           version: "%s"
+
+4   string      \x00\x00\x00\x00PART    Ubiquiti partition header,
+>0  byte        x                       header size: 56 bytes,
+>8  byte        0                       {invalid}
+>8  string      x                       name: "%s",
+>44 ubelong     x                       base address: 0x%.8X,
+>52 belong      x                       data size: %d bytes{size:%d}
+
+4   string      \x00\x00\x00\x00END\x2e Ubiquiti end header, header size: 12 bytes,
+>12 belong      !0                      {invalid},
+>8  ubelong     x                       cumulative ~CRC32: 0x%.8X
+
+
+# Found in DIR-100 firmware
+0       string      AIH0N       AIH0N firmware header, header size: 48,
+>12     belong      x           size: %d,
+>8      belong      !0          executable code,
+>>8     belong      x           load address: 0x%X,
+>32     string      x           version: "%s"
+
+0       belong      0x5EA3A417      SEAMA firmware header, big endian,
+>4      beshort     !0              {invalid}
+>6      beshort     x               meta size: %d,
+>8      belong      <1              {invalid}
+>8      belong      x               image size: %d
+
+0       lelong      0x5EA3A417      SEAMA firmware header, little endian,
+>4      leshort     !0              {invalid}
+>6      leshort     x               meta size: %d,
+>8      lelong      <1              {invalid}
+>8      lelong      x               image size: %d
+
+0       belong      0x4D544443      NSP firmware header, big endian,
+>16     belong      <1              {invalid}
+>16     belong      x               header size: %d,
+>20     belong      <1              {invalid}
+>20     belong      x               image size: %d,
+>20     belong      x               {size:%d}
+>4      belong      <1              {invalid}
+>4      ubelong     x               kernel offset: %d,
+>12     belong      <1              {invalid}
+>12     belong      x               header version: %d,
+
+0       lelong      0x4D544443      NSP firmware header, little endian,
+>16     lelong      <1              {invalid}
+>16     lelong      x               header size: %d,
+>20     lelong      <1              {invalid}
+>20     lelong      x               image size: %d,
+>20     lelong      x               {size:%d}
+>4      lelong      <1              {invalid}
+>4      ulelong     x               kernel offset: %d,
+>12     lelong      <1              {invalid}
+>12     lelong      x               header version: %d,
+
+# http://www.openwiz.org/wiki/Firmware_Layout#Beyonwiz_.wrp_header_structure
+0       string        WizFwPkgl    Beyonwiz firmware header,
+>20     string        x            version: "%s"
+
+0       string      BLI223WJ0   Thompson/Alcatel encoded firmware,
+>32     byte        x           version: %d.
+>33     byte        x           \b%d.
+>34     byte        x           \b%d.
+>35     byte        x           \b%d,
+>44     belong      x           size: %d,
+>48     ubelong     x           crc: 0x%.8X,
+>35     byte        x           try decryption tool from:
+>35     byte        x           http://download.modem-help.co.uk/mfcs-A/Alcatel/Modems/Misc/
+
+16    string        \xd9\x54\x93\x7a\x68\x04\x4a\x44\x81\xce\x0b\xf6\x17\xd8\x90\xdf    UEFI PI firmware volume
+
+# http://android.stackexchange.com/questions/23357/\
+# is-there-a-way-to-look-inside-and-modify-an-adb-backup-created-file/\
+# 23608#23608
+0       string  ANDROID\040BACKUP\n     Android Backup
+>15     string  1\n                     \b, version 1
+>17     string  0\n                     \b, uncompressed
+>17     string  1\n                     \b, compressed
+>19     string  none\n                  \b, unencrypted
+>19     string  AES-256\n               \b, encrypted AES-256
+
+# http://forum.xda-developers.com/showthread.php?p=47818657
+8    string    imgARMcC         Roku aimage SB
+
+# Boot ROM images for Sun/Cobalt Linux server appliances
+0       string    Cobalt\ Networks\ Inc.\nFirmware\ v    Paged Sun/COBALT boot rom,
+>38     string    x                        version: "%.4s"
+
+# Simple eCos string signatures
+0        string    ecos                    eCos RTOS string reference:
+>0       string    x                       "%s"
+0        string    eCos                    eCos RTOS string reference:
+>0       string    x                       "%s"
+0        string    ECOS                    eCos RTOS string reference:
+>0       string    x                       "%s"
+
+# ZyXEL config signatures
+6           string      dbgarea                  ZyXEL rom-0 configuration block, name: "%s",
+>16         ubeshort    x                        compressed size: %d,
+>14         ubeshort    x                        uncompressed size: %d,
+>18         ubeshort+16 x                        data offset from start of block: %d
+
+6           string      spt.dat                  ZyXEL rom-0 configuration block, name: "%s",
+>16         ubeshort    x                        compressed size: %d,
+>14         ubeshort    x                        uncompressed size: %d,
+>18         ubeshort+16 x                        data offset from start of block: %d
+
+6           string      autoexec.net             ZyXEL rom-0 configuration block, name: "%s",
+>16         ubeshort    x                        compressed size: %d,
+>14         ubeshort    x                        uncompressed size: %d,
+>18         ubeshort+16 x                        data offset from start of block: %d
+
+# Obfuscated Arcadyan firmware
+0x68    string  \x00\xD5\x08                    Obfuscated Arcadyan firmware,
+>0x6B   byte    !0                              {invalid} signature trailing byte [0x%X],{invalid}
+# None of the known Arcadyan signatures bytes have a NULL byte
+>0      byte    0                               {invalid}
+>1      byte    0                               {invalid}
+>2      byte    0                               {invalid}
+>3      byte    0                               {invalid}
+>0      ubelong x                               signature bytes: 0x%X,
+>0x70   string  !\x00\x00\x00\x00\x00\x00       {invalid} padding bytes{invalid}
+
+# Digi firmware images
+0xC0            string  Digi            Digi International firmware,
+>0xC8           beshort !0x4253
+>>0xC8          beshort !0x4950
+>>>0xC8         beshort !0x4944
+>>>>0xC8        beshort !0x444f
+>>>>>0xC8       beshort !0x4443
+>>>>>>0xC8      beshort !0x4f53
+>>>>>>>0xC8     beshort !0x4f43
+>>>>>>>>0xC8    beshort !0x4646
+>>>>>>>>>0xC8   beshort !0x5350         {invalid}invalid header,
+>0xD4           ubelong x               load address: 0x%.8X,
+>0xDC           ubelong x               entry point: 0x%.8X,
+
+# Lancom firmware signatures, courtesy of christophvw
+0    string            ELSF              LANCOM firmware header,
+>22  string            x                 model: "%s",
+>18  string            x                 firmware version: "%.4s",
+>12  ubyte             255               Rel,
+>12  ubyte             253               alpha,
+>12  ubyte             220               PR,
+>12  ubyte             >0
+>>12 ubyte             <220              RC%d,
+>12  ubyte             >220
+>>12 ubyte-220         <237              RU%d,
+>12  ubyte             0                 dev
+>17  ubyte             >0
+>>17 ubyte             x                 build %d
+#get build date
+>7   ubyte             !63
+#date is stored as string
+>>7  string            x                 ("%.8s")
+
+0    string            ELSO              LANCOM OEM file
+
+0    string            ELSB              LANCOM firmware loader,
+>22  string            x                 model: "%s",
+>18  string            x                 loader version: "%.4s",
+
+
+0    string            ELSC              LANCOM WWAN firmware
+>4   ubyte             3
+>>5  beshort           0
+>>7  string            x                 \b, "%s"
+
+0               string      ELSP                    LANCOM file entry
+>(198.L+202)    belong      !2
+>>(198.L+202)   belong      !3                      {invalid}
+>202            string      @(RECENT_FIRMWARE)/     \b, file name:
+>>221           string      x                       "%s"
+>>221           string      x                       \b{name:%s}
+>(198.L+202)    belong      2
+>>(198.L+206)   belong      <1                      {invalid}
+>>(198.L+206)   belong      x                       \b, file size: %d bytes
+>>(198.L+206)   belong      x                       \b{size:%d}
+>(198.L+202)    belong      3
+>>&4            string      @(RECENT_FIRMWARE)/     \b, alias:
+>>&23           string      x                       "%s"
+>>(&0.L+4)      belong      x                       \b, file size: %d bytes
+
+# Another Broadcom firmware header...
+# The header seems to be always 0x100 bytes length and there is more information than the one displayed (not sure about the meaning).
+# Used for example in the EchoLife HG556a router
+0x0	string 	\x38\x00\x00\x00	Broadcom firmware header
+>0x4	string	!Broadcom Corporatio	{invalid}
+>0x18	string	x			%s.
+>0x8E	string	x			Model: %s.
+>0xA2	string	x			Firmware version: %s.
+
+# QNAP encrypted firmware
+0       string       icpnas                  QNAP encrypted firmware footer
+>10     string       x                       , model: %s
+>26     string       x                       , version: %s
+>42     uleshort     !0
+>>42    string       x                       , date: %s
+
+# Mediatek
+0   string  SF_BOOT\x00\x00\x00\x00\x00  Mediatek Serial Flash Image
+>12 lelong <1 {invalid}
+>12 lelong >1 {invalid}
+>12 lelong x  Version %d
+0   string  EMMC_BOOT\x00\x00\x00    Mediatek EMMC Flash Image
+>12 lelong <1 {invalid}
+>12 lelong >1 {invalid}
+>12 lelong x  Version %d
+0   string  NOR_BOOT\x00\x00\x00\x00 Mediatek NOR Flash Image
+>12 lelong <1 {invalid}
+>12 lelong >1 {invalid}
+>12 lelong x  Version %d
+
+0  string BRLYT\x00\x00\x00 Mediatek Boot Header
+>8 lelong <1 {invalid}
+>8 lelong >1 {invalid}
+>8 lelong x Version %d
+
+0 string BBBB Boot section{overlap}
+>8 lelong x Start 0x%X
+>12 lelong x End 0x%X
+>16 lelong &0x1 Load-by-Bootrom
+>16 lelong &0x80000000 Internal-RAM
+>16 lelong &0x7ffffff0 {invalid}
+
+0 string FILE_INFO\x00\x00\x00 Mediatek File Info
+>12 lelong <1 {invalid}
+>12 lelong >1 {invalid}
+>16 leshort 0 File Type: NONE
+>16 leshort 1 File Type: ARM-Bootloader 
+>16 leshort 2 File Type: ARM-External-Bootloader
+>16 leshort 10 File Type: Root-Certificate
+>16 leshort 256 File Type: Primary-MAUI
+>16 leshort 264 File Type: VIVA
+>16 leshort 769 File Type: SECURE_RO_ME
+>18 byte 0 Flash Type: NONE
+>18 byte 1 Flash Type: NOR Flash
+>18 byte 2 Flash Type: NAND Sequential Flash
+>18 byte 3 Flash Type: NAND_TTBL
+>18 byte 4 Flash Type: NAND_FDM50
+>18 byte 5 EMMC-Boot-Region
+>18 byte 6 EMMC-Data-Region
+>18 byte 7 Flash Type: Serial Flash
+>18 byte 255 Flash Type: Device-End
+>18 byte >20 {invalid}
+>19 byte 0 No Signature
+>19 byte 1 Signature Type: PHASH
+>19 byte 2 Signature Type: SINGLE
+>19 byte 3 Signature Type: SINGLE and PHASH
+>19 byte 4 Signature Type: MULTI
+>19 byte 5 Signature Type: TYPE_NUM
+>19 byte 255 Signature Type: TYE_END
+>19 byte >20 {invalid}
+>20 lelong x Load Address: 0x%X
+>24 lelong x File Length: %d
+>28 lelong x Maximum Size: %d
+>32 lelong x Content Offset: 0x%X
+>36 lelong x Signature Lenght: %d
+>40 lelong x Jump Offset: %d
+>44 lelong &0x1 POST_BUILD_DONE
+>44 lelong &0x2 XIP (Execute In Place)
+>44 lelong &0x4 SLT
+>44 lelong &0xffffff00 {invalid}
+
+# Android bootimg
+# https://android.googlesource.com/platform/system/core.git/+/master/mkbootimg/bootimg.h
+0     string     ANDROID!      Android bootimg
+>8    ulelong    x             \b, kernel size: %d bytes
+>12   ulelong    x             \b, kernel addr: 0x%X
+>16   ulelong    x             \b, ramdisk size: %d bytes
+>20   ulelong    x             \b, ramdisk addr: 0x%X
+>48   string     x             \b, product name: "%s"
+
+# flattened image tree
+# won't see me if you enlarge block size
+0                   ubelong   0xd00dfeed  flattened image tree, # fit_header
+>4                  ubelong   x           total size: %d bytes,
+>4                  ubelong   x           {size:%d}
+>(8.L)              ubelong   0           {invalid}
+# >8                ubelong   x           offset to dt_struct: 0x%x,
+>(12.L)             ubelong   0           {invalid} # enlarge block size and try again, default=0x100000 (1M)
+# >12               ubelong   x           offset to strings: 0x%x,
+>(16.L)             ubelong   !0          {invalid}
+# >16               ubelong   x           offset to memory reserve map: 0x%x,
+# >20               ubelong   x           version: %d,
+# >24               ubelong   x           last compatiable version: %d,
+# >28               ubelong   x           booting on CPU %d,
+>(32.L)             ubelong   0           {invalid}
+# >32               ubelong   x           size of the strings block: %d bytes,
+>(36.L)             ubelong   0           {invalid}
+# >36               ubelong   x           size of the structure block: %d bytes,
+>(8.L)+0            ubelong   !1          {invalid} # fit_structure->root_node_header
+>(8.L)+8+0          ubelong   !3          {invalid} # fit_structure->root_timestamp
+>(8.L)+8+8          ubelong   x           # offset to name,
+>(12.L)+(>.L)       string    !timestamp  {invalid}
+>(8.L)+8+12         ubedate   x           timestamp: %s,
+>(8.L)+24+0         ubelong   3           # fit_structure->root_description
+>>(8.L)+24+4        ubelong   x           {strlen:(%d+3)&~3}
+>>(8.L)+24+8        ubelong   x           # offset to name,
+>>(12.L)+(>.L)      string    x           %s:
+>>(8.L)+24+12       string    x           {string}%s
diff --git a/src/binwalk/modules/extractor.py b/src/binwalk/modules/extractor.py
index 16c6f00..51e829a 100644
--- a/src/binwalk/modules/extractor.py
+++ b/src/binwalk/modules/extractor.py
@@ -622,14 +622,11 @@ class Extractor(Module):
                 fname = unique_file_name(default_bname, extension)
                 fdout = BlockFile(fname, 'w')
 
-            while total_size < size:
-                (data, dlen) = fdin.read_block()
-                if not data:
-                    break
-                else:
-                    fdout.write(str2bytes(data[adjust:dlen]))
-                    total_size += (dlen-adjust)
-                    adjust = 0
+            data = fdin.read(size)
+            if data:
+                fdout.write(str2bytes(data))
+                total_size += size
+                adjust = 0
 
             # Cleanup
             fdout.close()
diff --git a/src/binwalk/modules/general.py b/src/binwalk/modules/general.py
index 0549a97..49205c2 100644
--- a/src/binwalk/modules/general.py
+++ b/src/binwalk/modules/general.py
@@ -1,4 +1,5 @@
-# Module to process general user input options (scan length, starting offset, etc).
+# Module to process general user input options (scan length, starting
+# offset, etc).
 
 import io
 import os
@@ -12,6 +13,7 @@ import binwalk.core.settings
 from binwalk.core.compat import *
 from binwalk.core.module import Module, Option, Kwarg, show_help
 
+
 class General(Module):
 
     TITLE = "General"
@@ -23,77 +25,77 @@ class General(Module):
         Option(long='length',
                short='l',
                type=int,
-               kwargs={'length' : 0},
+               kwargs={'length': 0},
                description='Number of bytes to scan'),
         Option(long='offset',
                short='o',
                type=int,
-               kwargs={'offset' : 0},
+               kwargs={'offset': 0},
                description='Start scan at this file offset'),
         Option(long='base',
                short='O',
                type=int,
-               kwargs={'base' : 0},
+               kwargs={'base': 0},
                description='Add a base address to all printed offsets'),
         Option(long='block',
                short='K',
                type=int,
-               kwargs={'block' : 0},
+               kwargs={'block': 0},
                description='Set file block size'),
         Option(long='swap',
                short='g',
                type=int,
-               kwargs={'swap_size' : 0},
+               kwargs={'swap_size': 0},
                description='Reverse every n bytes before scanning'),
         Option(long='log',
                short='f',
                type=argparse.FileType,
-               kwargs={'log_file' : None},
+               kwargs={'log_file': None},
                description='Log results to file'),
         Option(long='csv',
                short='c',
-               kwargs={'csv' : True},
+               kwargs={'csv': True},
                description='Log results to file in CSV format'),
         Option(long='term',
                short='t',
-               kwargs={'format_to_terminal' : True},
+               kwargs={'format_to_terminal': True},
                description='Format output to fit the terminal window'),
         Option(long='quiet',
                short='q',
-               kwargs={'quiet' : True},
+               kwargs={'quiet': True},
                description='Suppress output to stdout'),
         Option(long='verbose',
                short='v',
-               kwargs={'verbose' : True},
+               kwargs={'verbose': True},
                description='Enable verbose output'),
         Option(short='h',
                long='help',
-               kwargs={'show_help' : True},
+               kwargs={'show_help': True},
                description='Show help output'),
         Option(short='a',
                long='finclude',
                type=str,
-               kwargs={'file_name_include_regex' : ""},
+               kwargs={'file_name_include_regex': ""},
                description='Only scan files whose names match this regex'),
         Option(short='p',
                long='fexclude',
                type=str,
-               kwargs={'file_name_exclude_regex' : ""},
+               kwargs={'file_name_exclude_regex': ""},
                description='Do not scan files whose names match this regex'),
         Option(short='s',
                long='status',
                type=int,
-               kwargs={'status_server_port' : 0},
+               kwargs={'status_server_port': 0},
                description='Enable the status server on the specified port'),
         Option(long=None,
                short=None,
                type=binwalk.core.common.BlockFile,
-               kwargs={'files' : []}),
+               kwargs={'files': []}),
 
         # Hidden, API-only arguments
         Option(long="string",
                hidden=True,
-               kwargs={'subclass' : binwalk.core.common.StringFile}),
+               kwargs={'subclass': binwalk.core.common.StringFile}),
     ]
 
     KWARGS = [
@@ -160,7 +162,8 @@ class General(Module):
         Must be called after self._test_target_files so that self.target_files is properly set.
         '''
         # If more than one target file was specified, enable verbose mode; else, there is
-        # nothing in some outputs to indicate which scan corresponds to which file.
+        # nothing in some outputs to indicate which scan corresponds to which
+        # file.
         if len(self.target_files) > 1 and not self.verbose:
             self.verbose = True
 
@@ -190,6 +193,8 @@ class General(Module):
             offset = self.offset
         if swap is None:
             swap = self.swap_size
+        if self.block != 0:
+            block = self.block
 
         return binwalk.core.common.BlockFile(fname,
                                              subclass=self.subclass,
@@ -216,5 +221,4 @@ class General(Module):
                 except KeyboardInterrupt as e:
                     raise e
                 except Exception as e:
-                    self.error(description="Cannot open file : %s" % str(e))
-
+                    self.error(description="Cannot open file %s (CWD: %s) : %s" % (tfile, os.getcwd(), str(e)))
diff --git a/src/binwalk/plugins/trxextract.py b/src/binwalk/plugins/trxextract.py
new file mode 100644
index 0000000..d8477e9
--- /dev/null
+++ b/src/binwalk/plugins/trxextract.py
@@ -0,0 +1,25 @@
+import binwalk.core.plugin
+
+
+class TRXExtractPlugin(binwalk.core.plugin.Plugin):
+    """
+    uImage extractor plugin.
+    """
+    MODULES = ['Signature']
+
+    def init(self):
+        if self.module.extractor.enabled:
+            self.module.extractor.add_rule(txtrule=None,
+                                           regex='^trx',
+                                           extension='trx',
+                                           cmd=self.extractor)
+
+    def extractor(self, fname):
+        pass
+
+    def scan(self, result):
+        if result.description.lower().startswith('trx'):
+            kernel_start = result.stub0 + result.offset
+            kernel_end = result.stub1 + result.offset
+            result.offset = kernel_start
+            result.size = kernel_end - kernel_start
diff --git a/src/binwalk/plugins/uimageextract.py b/src/binwalk/plugins/uimageextract.py
new file mode 100644
index 0000000..d703a25
--- /dev/null
+++ b/src/binwalk/plugins/uimageextract.py
@@ -0,0 +1,23 @@
+import os
+import binwalk.core.plugin
+
+
+class uImageExtractPlugin(binwalk.core.plugin.Plugin):
+    """
+    uImage extractor plugin.
+    """
+    MODULES = ['Signature']
+
+    def init(self):
+        if self.module.extractor.enabled:
+            self.module.extractor.add_rule(txtrule=None,
+                                           regex='^uimage',
+                                           extension='uimage',
+                                           cmd=self.extractor)
+            self.module.extractor.add_rule(txtrule=None,
+                                           regex='^flattened image tree',
+                                           extension='uimage.fit',
+                                           cmd=self.extractor)
+
+    def extractor(self, fname):
+        pass
diff --git a/src/scripts/extract_uimage.py b/src/scripts/extract_uimage.py
new file mode 100644
index 0000000..3a1f657
--- /dev/null
+++ b/src/scripts/extract_uimage.py
@@ -0,0 +1,11 @@
+#!/usr/bin/env python
+
+import sys
+import binwalk
+
+for module in binwalk.scan(*sys.argv[1:], signature=True, quit=False, extract=False):
+    print('%s Results:' % module.name)
+    # for result in module.results:
+    #     if result.file.path in module.extractor.output:
+    #         if module.extractor.output[result.file.path].extracted.has_key(result.offset):
+    #             pass
-- 
2.7.4

