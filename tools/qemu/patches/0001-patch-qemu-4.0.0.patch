From 3b963e191111cef2f2dc7bc2dfb628bb7bc140e4 Mon Sep 17 00:00:00 2001
From: cyrus <cyruscyliu@gmail.com>
Date: Sat, 12 Oct 2019 22:23:19 +0800
Subject: [PATCH] patch qemu-4.0.0

---
 accel/tcg/cpu-exec.c | 146 +++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 146 insertions(+)

diff --git a/accel/tcg/cpu-exec.c b/accel/tcg/cpu-exec.c
index 45ef41e..b0180a9 100644
--- a/accel/tcg/cpu-exec.c
+++ b/accel/tcg/cpu-exec.c
@@ -16,6 +16,10 @@
  * You should have received a copy of the GNU Lesser General Public
  * License along with this library; if not, see <http://www.gnu.org/licenses/>.
  */
+#include <stdio.h>
+#include <stdlib.h>
+#include <inttypes.h>
+#include <capstone/capstone.h>
 #include "qemu/osdep.h"
 #include "cpu.h"
 #include "trace.h"
@@ -29,6 +33,7 @@
 #include "exec/tb-hash.h"
 #include "exec/tb-lookup.h"
 #include "exec/log.h"
+#include "exec/address-spaces.h"
 #include "qemu/main-loop.h"
 #if defined(TARGET_I386) && !defined(CONFIG_USER_ONLY)
 #include "hw/i386/apic.h"
@@ -36,6 +41,32 @@
 #include "sysemu/cpus.h"
 #include "sysemu/replay.h"
 
+typedef struct Record {
+    uint32_t n_regs;
+    uint32_t *regs;
+    uint32_t code_size;
+    uint8_t *code;
+} Record;
+
+/* output */
+FILE *output;
+
+/* capstone */
+csh handle;
+bool init_capstone_done = false;
+
+static bool init_capstone(CPUState *cs)
+{
+    CPUArchState *env = (CPUArchState *) cs->env_ptr;
+    cs_arch arch = CS_ARCH_ARM;
+    cs_mode mode = env->thumb ? CS_MODE_THUMB : CS_MODE_ARM;
+    if (cs_open(arch, mode, &handle) != CS_ERR_OK) {
+        cs_close(&handle);
+        return false;
+    }
+    return true;
+}
+
 /* -icount align implementation. */
 
 typedef struct SyncClocks {
@@ -54,6 +85,8 @@ typedef struct SyncClocks {
 #define MAX_DELAY_PRINT_RATE 2000000000LL
 #define MAX_NB_PRINTS 100
 
+bool panda_please_flush_tb = true;
+
 static void align_clocks(SyncClocks *sc, const CPUState *cpu)
 {
     int64_t cpu_icount;
@@ -135,6 +168,113 @@ static void init_delay_params(SyncClocks *sc, const CPUState *cpu)
 }
 #endif /* CONFIG USER ONLY */
 
+static inline int panda_physical_memory_rw(hwaddr addr, uint8_t *buf, int len,
+                                           bool is_write)
+{
+    hwaddr l = len;
+    hwaddr addr1;
+    MemoryRegion *mr = address_space_translate(&address_space_memory, addr,
+                                               &addr1, &l, is_write, MEMTXATTRS_UNSPECIFIED);
+
+    if (!memory_access_is_direct(mr, is_write)) {
+        // fail for MMIO regions of physical address space
+        return MEMTX_ERROR;
+    }
+    void *ram_ptr = qemu_map_ram_ptr(mr->ram_block, addr1);
+
+    if (is_write) {
+        memcpy(ram_ptr, buf, len);
+    } else {
+        memcpy(buf, ram_ptr, len);
+    }
+    return MEMTX_OK;
+}
+
+static inline int panda_virtual_memory_rw(CPUState *env, target_ulong addr,
+                                          uint8_t *buf, int len, bool is_write)
+{
+    int l;
+    int ret;
+    hwaddr phys_addr;
+    target_ulong page;
+
+    while (len > 0) {
+        page = addr & TARGET_PAGE_MASK;
+        phys_addr = cpu_get_phys_page_debug(env, page);
+        if (phys_addr == -1) {
+            // no physical page mapped
+            return -1;
+        }
+        l = (page + TARGET_PAGE_SIZE) - addr;
+        if (l > len) {
+            l = len;
+        }
+        phys_addr += (addr & ~TARGET_PAGE_MASK);
+        ret = panda_physical_memory_rw(phys_addr, buf, l, is_write);
+        if (ret != MEMTX_OK) {
+            return ret;
+        }
+        len -= l;
+        buf += l;
+        addr += l;
+    }
+    return 0;
+}
+
+static size_t disassemble_block(CPUState *cs, TranslationBlock *tb, uint8_t **code)
+{
+    size_t count, length = 0;
+    cs_insn *insn;
+    uint8_t *mem = (uint8_t *) malloc(10240 * sizeof(uint8_t));
+
+    panda_virtual_memory_rw(cs, tb->pc, mem, tb->size, false);
+    count = cs_disasm(handle, mem, tb->size, tb->pc, 0, &insn);
+    for (size_t i = 0; i < count; i++) {
+        length += sprintf(
+                (char *) mem + length,
+                "0x%x :%s\t\t%s\n", (unsigned int) insn[i].address, insn[i].mnemonic, insn[i].op_str
+        );
+    }
+    *code = (uint8_t *) malloc(length * sizeof(uint8_t));
+    memcpy(*code, mem, length);
+    free(mem);
+    cs_free(insn, count);
+    return length;
+}
+
+static int before_block_exec(CPUState *cs, TranslationBlock *tb)
+{
+    CPUArchState *env = (CPUArchState *) cs->env_ptr;
+    Record record; 
+    if (!output) {
+        output = fopen("/tmp/log", "w");
+        if (!output) {
+            exit(-1);
+        }
+    }
+    if (!init_capstone_done) {
+        if (!init_capstone(cs)) return -1;
+        init_capstone_done = true;
+    }
+    record.n_regs = 18;
+    // add r0 to r12, sp(r13), lr(r14), pc(r15)
+    record.regs = (uint32_t *)malloc(record.n_regs * sizeof(uint32_t));
+    for (size_t i = 0; i < 16; i++) {
+        record.regs[i] = env->regs[i];
+    }
+    // add others
+    record.regs[16] = cpsr_read(env);
+    record.regs[17] = xpsr_read(env);
+    fwrite(&record.n_regs, sizeof(uint32_t), 1, output);
+    fwrite(record.regs, record.n_regs * sizeof(uint32_t), 1, output);
+    record.code_size = disassemble_block(cs, tb, &record.code);
+    fwrite(&record.code_size, sizeof(uint32_t), 1, output);
+    fwrite(record.code, record.code_size, 1, output);
+    free(record.regs);
+    free(record.code);
+    return 0;
+}
+
 /* Execute a TB, and fix up the CPU state afterwards if necessary */
 static inline tcg_target_ulong cpu_tb_exec(CPUState *cpu, TranslationBlock *itb)
 {
@@ -168,6 +308,7 @@ static inline tcg_target_ulong cpu_tb_exec(CPUState *cpu, TranslationBlock *itb)
 #endif /* DEBUG_DISAS */
 
     cpu->can_do_io = !use_icount;
+    before_block_exec(cpu, itb);
     ret = tcg_qemu_tb_exec(env, tb_ptr);
     cpu->can_do_io = 1;
     last_tb = (TranslationBlock *)(ret & ~TB_EXIT_MASK);
@@ -725,6 +866,11 @@ int cpu_exec(CPUState *cpu)
                 cpu->cflags_next_tb = -1;
             }
 
+            if (panda_please_flush_tb) {
+                tb_flush(first_cpu);
+                panda_please_flush_tb = false;
+            }
+
             tb = tb_find(cpu, last_tb, tb_exit, cflags);
             cpu_loop_exec_tb(cpu, tb, &last_tb, &tb_exit);
             /* Try to align the host and virtual clocks
-- 
2.7.4

