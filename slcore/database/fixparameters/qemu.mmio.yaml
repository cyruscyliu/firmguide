plxtech,nas782x-plla:
      # [MMIO] base 0x44e001f0 size 0x00000010 of /plla@44e001f0/['plxtech,nas782x-plla']
    0:
        - {offset: 0x0, size: 0x4, value: 0x8000}
        - {offset: 0x4, size: 0x4, value: 0x8000}
plxtech,nand-nas782x:
      #  while (!(chip->read_byte(mtd) & NAND_STATUS_READY))
    0:
        - {offset: 0x0, size: 0x4, value: 0x40, path: drivers/mtd/nand/nand_base.c, function: nand_command}
qca,ar7100-reset:
      # /root/openwrt-build-docker/share/19.07.1-ath79-generic/openwrt-19.07.1/bin/targets/ath79/ \
      # generic/openwrt-19.07.1-ath79-generic-buffalo_bhr-4grv-squashfs-sysupgrade.bin
      # id = __raw_readl(base + 0x90); id &= 0xfff0;
      # _prom_putchar=prom_putchar_ar71xx:0x00a0,0x00c0,0x0100,0x1100,0x00b0,0x0120,0x1120,0x2120,0x0140,0x0160,0x0130,0x1130,0x0150,0x1150
      # _prom_putchar=prom_putchar_ar933x:0x0110,0x1110
      # _prom_putchar=prom_putchar_dummy:others
    0:
        - {offset: 0x74, size: 0x4, value: 0x00b0, path: arch/mips/ath79/early_printk.c, function: prom_putchar_init}
      # /root/openwrt-build-docker/share/19.07.1-ath79-generic/openwrt-19.07.1/bin/targets/ath79/generic/openwrt-19.07.1-ath79-generic-librerouter_librerouter-v1-initramfs-kernel.bin
      # bootstrap = ath79_reset_rr(0xb0);
      # if (bootstrap & (1UL << (4))) ref_rate = 40 * 1000 * 1000; else ref_rate = 25 * 1000 * 1000;
    0:
        - {offset: 0x94, size: 0x4, value: 0x0010, path: arch/mips/ath79/clock.i, function: qca955x_clocks_init}
qca,qca9550-pll:
      # if (of_device_is_compatible(np, "qca,ar7240-pll") || of_device_is_compatible(np, "qca,ar9130-pll"))
      #     ar724x_clocks_init(pll_base);
      # ref_rate = 4000000;
      # pll = ath79_pll_rr(0x00); mul = ((pll >> 0) & 0x3ff); div = ((pll > 10) & 0xf) * 2
      # 4000000 * ((pll >> 0) & 0x3ff) / (((pll > 10 & 0xf)) * 2)
      # 4000000 * ((0x1010 >> 0) & 0x3ff) / (((0x1010 > 10 & 0xf)) * 2) = 80M
    0:
        - {offset: 0x0, size: 0x4, value: 0x0810, path: arch/mips/ath79/clock.c, function: ar724x_clocks_init}
qca,qca9550-eth:
      # err = of_mdiobus_register(mii_bus, np);
      # [#0] 0xffffffff802d87f0 → ag71xx_mdio_wait_busy(am=<optimized out>, am=<optimized out>) <- USEE
      # [#1] 0xffffffff802d88c0 → ag71xx_mdio_mii_read(bus=0x804a0000, addr=0x0, reg=0x2)
      # [#2] 0xffffffff802c39e4 → mdiobus_read(bus=0x8fd35000, addr=0x0, regnum=0x2)
      # [#3] 0xffffffff802c35f4 → get_phy_id(c45_ids=<optimized out>, is_c45=<optimized out>, phy_id=<optimized out>, addr=<optimized out>, bus=<optimized out>)
      # [#4] 0xffffffff802c35f4 → get_phy_device(bus=0x8fd35000, addr=0x0, is_c45=0x0)
      # [#5] 0xffffffff802f161c → of_mdiobus_register_phy(mdio=0x8fd35000, child=0x81003f60, addr=0x0)
      # [#6] 0xffffffff802f1ccc → of_mdiobus_register(mdio=0x8fd35000, np=0x81003ca4)
      # [#7] 0xffffffff802d8544 → ag71xx_mdio_probe(pdev=0x8fd92c00)
      # am->mii_bus = mii_bus; <- BEFORE ASSIGNMENT
    0:
        - {offset: 0x0, size: 0x4, value: 0x0000, path: drivers/net/ethernet/atheros/ag71xx/ag71xx_mdio.c, function: ag71xx_mdio_wait_busy}
qca,ar9340-gpio:
     # gpio_base = (void *)(((((int)(int)((0x18000000 + 0x00040000))) & 0x1fffffff) | 0xa0000000));
      # t = __raw_readl(gpio_base + 0x28);
      # t |= uart_en;
      # __raw_writel(t, gpio_base + 0x28);
    0:
        - {offset: 0x28, size: 0x4, value: 0x0000, path: arch/mips/ath79/early_printk, function: prom_enable_uart}
ralink,rt3050-sysc:
      # void *sysc = (void *) ((((int)(int)(0x10000000)) & 0x1fffffff) | 0xa0000000);
      # n0 = __raw_readl(sysc + 0x00); n1 = __raw_readl(sysc + 0x04); id = __raw_readl(sysc + 0x0c);
      # if (n0 == 0x38335452 && n1 == 0x20203338) {  soc_info->compatible = "ralink,rt3883-soc"; name = "RT3883";
      # } else {  panic("rt3883: unknown SoC, n0:%08x n1:%08x", n0, n1);}
    0:
        - {offset: 0x0, size: 0x4, value: 0x38335452, path: arch/mips/ralink/rt3883.c, function: prom_soc_init}
        - {offset: 0x4, size: 0x4, value: 0x20203338, path: arch/mips/ralink/rt3883.c ,function: prom_soc_init}
ralink,mt7620a-sysc:
      # n0 = __raw_readl(sysc + 0x00); n1 = __raw_readl(sysc + 0x04); rev = __raw_readl(sysc + 0x0c);
      # bga = (rev >> 16) & 0x1;
      # if (n0 == 0x3637544d && n1 == 0x20203032) {
      #     if (bga) { ralink_soc = MT762X_SOC_MT7620A; name = "MT7620A"; soc_info->compatible = "ralink,mt7620a-soc";
      #     } else { ralink_soc = MT762X_SOC_MT7620N; name = "MT7620N"; soc_info->compatible = "ralink,mt7620n-soc";
      #     }
      # } else if (n0 == 0x3637544d && n1 == 0x20203832) {
      #     u32 efuse = __raw_readl(sysc + 0x08);
      #     if (efuse & 0x100000) { ralink_soc = MT762X_SOC_MT7688; name = "MT7688";
      #     } else { ralink_soc = MT762X_SOC_MT7628AN; name = "MT7628AN"; }
      #     soc_info->compatible = "ralink,mt7628an-soc";
      # } else {
      #     panic("mt762x: unknown SoC, n0:%08x n1:%08x\n", n0, n1); 
      # }
    0:
        - {offset: 0x0, size: 0x4, value: 0x3637544d, path: arch/mips/ralink/rt7620.c, function: prom_soc_init}
        - {offset: 0x4, size: 0x4, value: 0x20203832, path: arch/mips/ralink/rt7620.c ,function: prom_soc_init}
        - {offset: 0x8, size: 0x4, value: 0x00100000, path: arch/mips/ralink/rt7620.c ,function: prom_soc_init}
