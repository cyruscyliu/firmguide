plxtech,nas782x-plla:
      # [MMIO] base 0x44e001f0 size 0x00000010 of /plla@44e001f0/['plxtech,nas782x-plla']
    - {offset: 0x0, size: 0x4, value: 0x8000}
    - {offset: 0x4, size: 0x4, value: 0x8000}
plxtech,nand-nas782x:
      #  while (!(chip->read_byte(mtd) & NAND_STATUS_READY))
    - {offset: 0x0, size: 0x4, value: 0x40, path: drivers/mtd/nand/nand_base.c, function: nand_command}
mach-mvebu:
      # soc_dev_id = readl(pci_base + PCIE_DEV_ID_OFF) >> 16;
      # soc_rev = readl(pci_base + PCIE_DEV_REV_OFF) & SOC_REV_MASK;
      # - {base: 0xf1040000, size: 0x4, value: 0x0000, compatible: ['mach-mvebu-001'], path: arch/arm/mach-mvebu/mvebu-soc-id.c, function: get_soc_id_by_pci}
      # - {base: 0xf1040008, size: 0x4, value: 0x0000, compatible: ['mach-mvebu-002'], path: arch/arm/mach-mvebu/mvebu-soc-id.c, function: get_soc_id_by_pci}
      # pcie-mem-aperture = <0xE0000000 0x10000000>;
      # pcie-io-aperture  = <0xF2000000 0x00100000>;
      #  {base: 0xe0000000, size: 0x10000000, value: 0x0000, compatible: ['mach-mvebu-003'], path: drivers/bus/mvebu-mbus.c, function: mvebu_mbus_dt_init}
    - {base: 0xf2000000, size: 0x00100000, value: 0x0000, compatible: ['mach-mvebu-003'], path: drivers/bus/mvebu-mbus.c, function: mvebu_mbus_dt_init}
      # bridge->device = mvebu_readl(port, 0x0000) >> 16;
      # bridge->revision = mvebu_readl(port, 0x0008) & 0xff;
      # - {base: 0xf1044000, size: 0x10, value: 0x0, compatible: ['mach-mvebu-004'], path: drivers/pci/host/pci-mvebu.c, function: mvebu_sw_pci_bridge_init}
      # for (i = 1; i < 3; i++) {
      #     mvebu_writel(port, 0, (0x1804 + (((i) - 1) * 4)));                                                                                                                       36809   mvebu_writel(port, 0, (0x0010 + ((i) << 3)));
      #     mvebu_writel(port, 0, (0x0014 + ((i) << 3)));
      # }
    - {base: 0xf1040000, size: 0x0800, value: 0x0000, compatible: ['mach-mvebu-006'], path: drivers/pci/host/pci-mvebu.c, function: mvebu_pcie_setup_wins}
    - {base: 0xf1044000, size: 0x0800, value: 0x0000, compatible: ['mach-mvebu-006'], path: drivers/pci/host/pci-mvebu.c, function: mvebu_pcie_setup_wins}
      # new
    - {base: 0xf1048000, size: 0x0800, value: 0x0000, compatible: ['mach-mvebu-007'], path: drivers/pci/host/pci-mvebu.c, function: mvebu_pcie_setup_wins}
ath79:
      # /root/openwrt-build-docker/share/19.07.1-ath79-generic/openwrt-19.07.1/bin/targets/ath79/generic/openwrt-19.07.1-ath79-generic-buffalo_bhr-4grv-squashfs-sysupgrade.bin
      # id = __raw_readl(base + 0x90); id &= 0xfff0;
      # _prom_putchar=prom_putchar_ar71xx:0x00a0,0x00c0,0x0100,0x1100,0x00b0,0x0120,0x1120,0x2120,0x0140,0x0160,0x0130,0x1130,0x0150,0x1150
      # _prom_putchar=prom_putchar_ar933x:0x0110,0x1110
      # _prom_putchar=prom_putchar_dummy:others
    - {base: 0x18060090, size: 0x4, value: 0x00b0, path: arch/mips/ath79/early_printk.c, compatible: ['ath79-iv-001'], function: prom_putchar_init}
    - {base: 0x18060014, size: 0x4, value: 0x0000, path: drivers/irqchip/irq-ath79-misc.c, compatible: ['ath79-iv-002'], function: ath79_misc_intc_domain_init}
      # if (of_device_is_compatible(np, "qca,ar7240-pll") || of_device_is_compatible(np, "qca,ar9130-pll"))
      #     ar724x_clocks_init(pll_base);
      # ref_rate = 4000000;
      # pll = ath79_pll_rr(0x00); mul = ((pll >> 0) & 0x3ff); div = ((pll > 10) & 0xf) * 2
      # 4000000 * ((pll >> 0) & 0x3ff) / (((pll > 10 & 0xf)) * 2)
      # 4000000 * ((0x1010 >> 0) & 0x3ff) / (((0x1010 > 10 & 0xf)) * 2) = 80M
    - {base: 0x18050000, size: 0x4, value: 0x0810, path: arch/mips/ath79/clock.c, compatible: ['ath79-iv-003'], function: ar724x_clocks_init}
      # err = of_mdiobus_register(mii_bus, np);
      # [#0] 0xffffffff802d87f0 → ag71xx_mdio_wait_busy(am=<optimized out>, am=<optimized out>) <- USEE
      # [#1] 0xffffffff802d88c0 → ag71xx_mdio_mii_read(bus=0x804a0000, addr=0x0, reg=0x2)
      # [#2] 0xffffffff802c39e4 → mdiobus_read(bus=0x8fd35000, addr=0x0, regnum=0x2)
      # [#3] 0xffffffff802c35f4 → get_phy_id(c45_ids=<optimized out>, is_c45=<optimized out>, phy_id=<optimized out>, addr=<optimized out>, bus=<optimized out>)
      # [#4] 0xffffffff802c35f4 → get_phy_device(bus=0x8fd35000, addr=0x0, is_c45=0x0)
      # [#5] 0xffffffff802f161c → of_mdiobus_register_phy(mdio=0x8fd35000, child=0x81003f60, addr=0x0)
      # [#6] 0xffffffff802f1ccc → of_mdiobus_register(mdio=0x8fd35000, np=0x81003ca4)
      # [#7] 0xffffffff802d8544 → ag71xx_mdio_probe(pdev=0x8fd92c00)
      # am->mii_bus = mii_bus; <- BEFORE ASSIGNMENT
    - {base: 0x19000034, size: 0x4, value: 0x0000, path: drivers/net/ethernet/atheros/ag71xx/ag71xx_mdio.c, compatible: ['ath79-iv-004'], function: ag71xx_mdio_wait_busy}
      # /root/openwrt-build-docker/share/19.07.1-ath79-generic/openwrt-19.07.1/bin/targets/ath79/generic/openwrt-19.07.1-ath79-generic-librerouter_librerouter-v1-initramfs-kernel.bin
      # bootstrap = ath79_reset_rr(0xb0);
      # if (bootstrap & (1UL << (4))) ref_rate = 40 * 1000 * 1000; else ref_rate = 25 * 1000 * 1000;
    - {base: 0x180600B0, size: 0x4, value: 0x0010, path: arch/mips/ath79/clock.i, compatible: ['ath79-iv-005'], function: qca955x_clocks_init}
      # gpio_base = (void *)(((((int)(int)((0x18000000 + 0x00040000))) & 0x1fffffff) | 0xa0000000));
      # t = __raw_readl(gpio_base + 0x28);
      # t |= uart_en;
      # __raw_writel(t, gpio_base + 0x28);
    - {base: 0x18040028, size: 0x4, value: 0x0000, path: arch/mips/ath79/early_printk, compatible: ['ath79-iv-006'], function: prom_enable_uart}
ralink,rt3050-sysc:
      # void *sysc = (void *) ((((int)(int)(0x10000000)) & 0x1fffffff) | 0xa0000000);
      # n0 = __raw_readl(sysc + 0x00); n1 = __raw_readl(sysc + 0x04); id = __raw_readl(sysc + 0x0c);
      # if (n0 == 0x38335452 && n1 == 0x20203338) {  soc_info->compatible = "ralink,rt3883-soc"; name = "RT3883";
      # } else {  panic("rt3883: unknown SoC, n0:%08x n1:%08x", n0, n1);}
    - {offset: 0x0, size: 0x4, value: 0x38335452, path: arch/mips/ralink/rt3883.c, function: prom_soc_init}
    - {offset: 0x4, size: 0x4, value: 0x20203338, path: arch/mips/ralink/rt3883.c ,function: prom_soc_init}
