diff -rNu qemu-2.3.0.orig/configure qemu-2.3.0/configure
--- qemu-2.3.0.orig/configure	2015-04-27 14:08:23.000000000 +0000
+++ qemu-2.3.0/configure	2020-08-10 11:01:33.195346441 +0000
@@ -300,6 +300,7 @@
 blobs="yes"
 pkgversion=""
 pie=""
+autoboard="no"
 zero_malloc=""
 qom_cast_debug="yes"
 trace_backends="nop"
@@ -977,6 +978,8 @@
   ;;
   --disable-pie) pie="no"
   ;;
+  --enable-autoboard) autoboard="yes"
+  ;;
   --enable-werror) werror="yes"
   ;;
   --disable-werror) werror="no"
@@ -1339,6 +1342,7 @@
   --disable-guest-base     disable GUEST_BASE support
   --enable-pie             build Position Independent Executables
   --disable-pie            do not build Position Independent Executables
+  --enable-autoboard       enable autoboard interrupt controller and timer
   --fmod-lib               path to FMOD library
   --fmod-inc               path to FMOD includes
   --oss-lib                path to OSS library
@@ -4387,6 +4391,7 @@
 echo "Documentation     $docs"
 echo "GUEST_BASE        $guest_base"
 echo "PIE               $pie"
+echo "autoboard         $autoboard"
 echo "vde support       $vde"
 echo "netmap support    $netmap"
 echo "Linux AIO support $linux_aio"
@@ -5286,6 +5291,9 @@
 if test "$target_bigendian" = "yes" ; then
   echo "TARGET_WORDS_BIGENDIAN=y" >> $config_target_mak
 fi
+if test "$autoboard" = "yes" ; then
+  echo "CONFIG_AUTOBOARD=y" >> $config_target_mak
+fi
 if test "$target_softmmu" = "yes" ; then
   echo "CONFIG_SOFTMMU=y" >> $config_target_mak
 fi
diff -rNu qemu-2.3.0.orig/disas/mips.c qemu-2.3.0/disas/mips.c
--- qemu-2.3.0.orig/disas/mips.c	2015-04-27 14:08:23.000000000 +0000
+++ qemu-2.3.0/disas/mips.c	2020-08-10 11:04:15.698975591 +0000
@@ -4991,7 +4991,9 @@
 				     | INSN_LOAD_MEMORY_DELAY)) != 0)
 		info->insn_type = dis_dref;
 
-	      (*info->fprintf_func) (info->stream, "%s", op->name);
+	      (*info->fprintf_func) (info->stream, "%08" PRIx64, word);
+	      (*info->fprintf_func) (info->stream, " ");
+	      (*info->fprintf_func) (info->stream, " %s", op->name);
 
 	      d = op->args;
 	      if (d != NULL && *d != '\0')
diff -rNu qemu-2.3.0.orig/hw/char/serial.c qemu-2.3.0/hw/char/serial.c
--- qemu-2.3.0.orig/hw/char/serial.c	2015-04-27 14:08:23.000000000 +0000
+++ qemu-2.3.0/hw/char/serial.c	2020-08-10 11:47:40.717259339 +0000
@@ -300,12 +300,38 @@
     }
 }
 
+// ->7 UART_SCR (unmapped)
+//8->6 UART_MSR (otfrange)
+static const uint8_t au_io_map[8] = {
+    0,/*0->0 UART_RX  */
+    0,/*1->0 UART_TX  */
+    1,/*2->1 UART_IER */
+    2,/*3->2 UART_IIR */
+    2,/*4->2 UART_FCR */
+    3,/*5->3 UART_LCR */
+    4,/*6->4 UART_MCR */
+    5,/*7->5 UART_LSR */
+};
+
 static void serial_ioport_write(void *opaque, hwaddr addr, uint64_t val,
                                 unsigned size)
 {
     SerialState *s = opaque;
 
+    /* In a standard 16550 implementation, the DL is accessible as two 8-bit halves only.
+     * In the au1x00/rt288x implementation, the DL register is accessible as a single 16-bit entity only.
+     */
+    if (s->au && addr == 0xa) {
+        s->divider = val;
+        return;
+    }
+
     addr &= 7;
+
+    /* Au1x00/RT288x UART hardware has a weird register layout */
+    if (s->au)
+      addr = au_io_map[addr];
+
     DPRINTF("write addr=0x%" HWADDR_PRIx " val=0x%" PRIx64 "\n", addr, val);
     switch(addr) {
     default:
@@ -454,6 +480,11 @@
     uint32_t ret;
 
     addr &= 7;
+
+    /* Au1x00/RT288x UART hardware has a weird register layout */
+    if (s->au)
+        addr = au_io_map[addr];
+
     switch(addr) {
     default:
     case 0:
@@ -975,7 +1006,18 @@
     vmstate_register(NULL, base, &vmstate_serial, s);
 
     memory_region_init_io(&s->io, NULL, &serial_mm_ops[end], s,
-                          "serial", 8 << it_shift);
+                          "serial", 0x40 << it_shift);
     memory_region_add_subregion(address_space, base, &s->io);
     return s;
 }
+
+/* add Au1x00/RT288x UART support */
+SerialState *serial_mm_init_au(MemoryRegion *address_space,
+                               hwaddr base, int it_shift,
+                               qemu_irq irq, int baudbase,
+                               CharDriverState *chr, enum device_endian end)
+{
+    SerialState *s = serial_mm_init(address_space, base, it_shift, irq, baudbase, chr, end);
+    s->au = true;
+    return s;
+} 
diff -rNu qemu-2.3.0.orig/hw/core/loader.c qemu-2.3.0/hw/core/loader.c
--- qemu-2.3.0.orig/hw/core/loader.c	2015-04-27 14:08:23.000000000 +0000
+++ qemu-2.3.0/hw/core/loader.c	2020-08-10 11:51:22.364755652 +0000
@@ -933,6 +933,32 @@
     }
 }
 
+void rom_hotfix_reset(void *opaque)
+{
+   struct rom_hotfix_blob *blob = opaque;
+   Rom *rom;
+
+   if (!blob->as) {
+       blob->as = &address_space_memory;
+   }
+
+   QTAILQ_FOREACH(rom, &roms, next) {
+      if (rom->fw_file) {
+          continue;
+      }
+      if (rom->mr) {
+          continue;
+      }
+      // found the rom which is going to be modified
+      if ((blob->addr > rom->addr) && (blob->addr < rom->addr + rom->romsize)) {
+          if (blob->size + blob->offset < rom->romsize) {
+              memcpy(rom->data + blob->offset, blob->data, blob->size);
+          }
+          break;
+      }
+   }
+}
+
 int rom_load_all(void)
 {
     hwaddr addr = 0;
diff -rNu qemu-2.3.0.orig/hw/cpu/Makefile.objs qemu-2.3.0/hw/cpu/Makefile.objs
--- qemu-2.3.0.orig/hw/cpu/Makefile.objs	2015-04-27 14:08:24.000000000 +0000
+++ qemu-2.3.0/hw/cpu/Makefile.objs	2020-08-10 11:17:13.167451577 +0000
@@ -3,4 +3,5 @@
 obj-$(CONFIG_A9MPCORE) += a9mpcore.o
 obj-$(CONFIG_A15MPCORE) += a15mpcore.o
 obj-$(CONFIG_ICC_BUS) += icc_bus.o
+obj-$(CONFIG_AUTOBOARD) += autoboard_arm11mpcore.o
 
diff -rNu qemu-2.3.0.orig/hw/cpu/autoboard_arm11mpcore.c qemu-2.3.0/hw/cpu/autoboard_arm11mpcore.c
--- qemu-2.3.0.orig/hw/cpu/autoboard_arm11mpcore.c	1970-01-01 00:00:00.000000000 +0000
+++ qemu-2.3.0/hw/cpu/autoboard_arm11mpcore.c	2020-08-10 12:32:55.791005229 +0000
@@ -0,0 +1,190 @@
+/*
+ * ARM11MPCore internal peripheral emulation for autoboard.
+ *
+ * Written by Zhang Cen
+ *
+ * This code is licensed under the GPL.
+ */
+
+#include "qemu/osdep.h"
+#include "qapi/error.h"
+//#include "hw/cpu/arm11mpcore.h"
+#include "hw/cpu/autoboard_arm11mpcore.h"
+//#include "hw/intc/realview_gic.h"
+#include "hw/intc/autoboard_intc.h"
+
+
+static void mpcore_priv_set_irq(void *opaque, int irq, int level)
+{
+    AUTOBOARDARM11MPCorePriveState *s = (AUTOBOARDARM11MPCorePriveState *)opaque;
+
+    qemu_set_irq(qdev_get_gpio_in(DEVICE(&s->aic), irq), level);
+}
+
+static void mpcore_priv_map_setup(AUTOBOARDARM11MPCorePriveState *s)
+{
+    int i;
+    SysBusDevice *scubusdev = SYS_BUS_DEVICE(&s->scu);
+    DeviceState *aicdev = DEVICE(&s->aic);
+    SysBusDevice *aicbusdev = SYS_BUS_DEVICE(&s->aic);
+    SysBusDevice *timerbusdev = SYS_BUS_DEVICE(&s->mptimer);
+    //SysBusDevice *wdtbusdev = SYS_BUS_DEVICE(&s->wdtimer);
+
+    memory_region_add_subregion(&s->container, 0,
+                                sysbus_mmio_get_region(scubusdev, 0));
+    /* GIC CPU interfaces: "current CPU" at 0x100, then specific CPUs
+     * at 0x200, 0x300...
+     */
+    //for (i = 0; i < (s->num_cpu + 1); i++) {
+    for (i = 0; i < s->num_cpu; i++) {
+        hwaddr offset = 0x100 + (i * 0x100);
+        memory_region_add_subregion(&s->container, offset,
+                                    sysbus_mmio_get_region(aicbusdev, i + 1));
+    }
+
+    /* Add the regions for timer and watchdog for "current CPU" and
+     * for each specific CPU.
+     */
+    //for (i = 0; i < (s->num_cpu + 1); i++) {
+    for (i = 0; i < s->num_cpu; i++) {
+        /* Timers at 0x600, 0x700, ...; watchdogs at 0x620, 0x720, ... */
+        hwaddr offset = 0x600 + i * 0x100;
+        memory_region_add_subregion(&s->container, offset,
+                                    sysbus_mmio_get_region(timerbusdev, i));
+        //memory_region_add_subregion(&s->container, offset + 0x20,
+        //                            sysbus_mmio_get_region(wdtbusdev, i));
+    }
+    memory_region_add_subregion(&s->container, 0x1000,
+                                sysbus_mmio_get_region(aicbusdev, 0));
+    /* Wire up the interrupt from each watchdog and timer.
+     * For each core the timer is PPI 29 and the watchdog PPI 30.
+     */
+    for (i = 0; i < s->num_cpu; i++) {
+        sysbus_connect_irq(timerbusdev, i,
+                           qdev_get_gpio_in(aicdev, 29));
+        //int ppibase = (s->num_irq - 32) + i * 32;
+        //sysbus_connect_irq(timerbusdev, i,
+        //                   qdev_get_gpio_in(aicdev, ppibase + 29));
+        //sysbus_connect_irq(wdtbusdev, i,
+        //                   qdev_get_gpio_in(aicdev, ppibase + 30));
+    }
+}
+
+static void mpcore_priv_realize(DeviceState *dev, Error **errp)
+{
+    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);
+    AUTOBOARDARM11MPCorePriveState *s = AUTOBOARDARM11MPCORE_PRIV(dev);
+    DeviceState *scudev = DEVICE(&s->scu);
+    //DeviceState *aicdev = DEVICE(&s->aic);
+    //DeviceState *mptimerdev = DEVICE(&s->mptimer);
+    //DeviceState *wdtimerdev = DEVICE(&s->wdtimer);
+    Error *err = NULL;
+
+    qdev_prop_set_uint32(scudev, "num-cpu", s->num_cpu);
+    object_property_set_bool(OBJECT(&s->scu), true, "realized", &err);
+    if (err != NULL) {
+        error_propagate(errp, err);
+        return;
+    }
+
+    //qdev_prop_set_uint32(aicdev, "num-cpu", s->num_cpu);
+    //qdev_prop_set_uint32(aicdev, "num-irq", s->num_irq);
+    //object_property_set_bool(OBJECT(&s->aic), true, "realized", &err);
+    //if (err != NULL) {
+    //    error_propagate(errp, err);
+    //    return;
+    //}
+    object_property_set_bool(OBJECT(&s->aic), true, "realized", &err);
+    if (err != NULL) {
+        error_propagate(errp, err);
+        return;
+    }
+
+    /* Pass through outbound IRQ lines from the GIC */
+    sysbus_pass_irq(sbd, SYS_BUS_DEVICE(&s->aic));
+
+    /* Pass through inbound GPIO lines to the GIC */
+    //qdev_init_gpio_in(dev, mpcore_priv_set_irq, s->num_irq - 32);
+    qdev_init_gpio_in(dev, mpcore_priv_set_irq, s->num_irq);
+
+    //qdev_prop_set_uint32(mptimerdev, "num-cpu", s->num_cpu);
+    //object_property_set_bool(OBJECT(&s->mptimer), true, "realized", &err);
+    //if (err != NULL) {
+    //    error_propagate(errp, err);
+    //    return;
+    //}
+    object_property_set_bool(OBJECT(&s->mptimer), true, "realized", &err);
+
+    //qdev_prop_set_uint32(wdtimerdev, "num-cpu", s->num_cpu);
+    //object_property_set_bool(OBJECT(&s->wdtimer), true, "realized", &err);
+    //if (err != NULL) {
+    //    error_propagate(errp, err);
+    //    return;
+    //}
+
+    mpcore_priv_map_setup(s);
+}
+
+static void mpcore_priv_initfn(Object *obj)
+{
+    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);
+    AUTOBOARDARM11MPCorePriveState *s = AUTOBOARDARM11MPCORE_PRIV(obj);
+
+    memory_region_init(&s->container, OBJECT(s),
+                       "mpcore-priv-container", 0x2000);
+    sysbus_init_mmio(sbd, &s->container);
+
+    object_initialize(&s->scu, sizeof(s->scu), TYPE_ARM11_SCU);
+    qdev_set_parent_bus(DEVICE(&s->scu), sysbus_get_default());
+
+    set_autoboard_intc_cfg(AUTOBOARD_INTC_OXNAS_GENERIC_GIC, "auto-gic");
+    object_initialize(&s->aic, sizeof(s->aic), TYPE_AUTOBOARD_INTC);
+    qdev_set_parent_bus(DEVICE(&s->aic), sysbus_get_default());
+
+    /* Request the legacy 11MPCore GIC behaviour: */
+    //qdev_prop_set_uint32(DEVICE(&s->gic), "revision", 0);
+
+    set_autoboard_timer_cfg(AUTOBOARD_TIMER_OXNAS_GENERIC_MPTIMER, "auto-mptimer");
+    object_initialize(&s->mptimer, sizeof(s->mptimer), TYPE_AUTOBOARD_TIMER);
+    qdev_set_parent_bus(DEVICE(&s->mptimer), sysbus_get_default());
+
+    //sysbus_init_child_obj(obj, "wdtimer", &s->wdtimer, sizeof(s->wdtimer),
+    //                      TYPE_ARM_MPTIMER);
+}
+
+static Property mpcore_priv_properties[] = {
+    DEFINE_PROP_UINT32("num-cpu", AUTOBOARDARM11MPCorePriveState, num_cpu, 1),
+    /* The ARM11 MPCORE TRM says the on-chip controller may have
+     * anything from 0 to 224 external interrupt IRQ lines (with another
+     * 32 internal). We default to 32+32, which is the number provided by
+     * the ARM11 MPCore test chip in the Realview Versatile Express
+     * coretile. Other boards may differ and should set this property
+     * appropriately. Some Linux kernels may not boot if the hardware
+     * has more IRQ lines than the kernel expects.
+     */
+    DEFINE_PROP_UINT32("num-irq", AUTOBOARDARM11MPCorePriveState, num_irq, 64),
+    DEFINE_PROP_END_OF_LIST(),
+};
+
+static void mpcore_priv_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+
+    dc->realize = mpcore_priv_realize;
+    dc->props = mpcore_priv_properties;
+}
+
+static const TypeInfo mpcore_priv_info = {
+    .name          = TYPE_AUTOBOARDARM11MPCORE_PRIV,
+    .parent        = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(AUTOBOARDARM11MPCorePriveState),
+    .instance_init = mpcore_priv_initfn,
+    .class_init    = mpcore_priv_class_init,
+};
+
+static void autoboardarm11mpcore_register_types(void)
+{
+    type_register_static(&mpcore_priv_info);
+}
+
+type_init(autoboardarm11mpcore_register_types)
diff -rNu qemu-2.3.0.orig/hw/intc/Makefile.objs qemu-2.3.0/hw/intc/Makefile.objs
--- qemu-2.3.0.orig/hw/intc/Makefile.objs	2015-04-27 14:08:24.000000000 +0000
+++ qemu-2.3.0/hw/intc/Makefile.objs	2020-08-10 11:26:57.967718318 +0000
@@ -27,3 +27,4 @@
 obj-$(CONFIG_ALLWINNER_A10_PIC) += allwinner-a10-pic.o
 obj-$(CONFIG_S390_FLIC) += s390_flic.o
 obj-$(CONFIG_S390_FLIC_KVM) += s390_flic_kvm.o
+obj-$(CONFIG_AUTOBOARD) += autoboard_intc_gen.o autoboard_intc.o autoboard_level_irq.o autoboard_eoi_lvl_irq.o autoboard_edge_irq.o autoboard_intc_utils.o
diff -rNu qemu-2.3.0.orig/hw/intc/autoboard_edge_irq.c qemu-2.3.0/hw/intc/autoboard_edge_irq.c
--- qemu-2.3.0.orig/hw/intc/autoboard_edge_irq.c	1970-01-01 00:00:00.000000000 +0000
+++ qemu-2.3.0/hw/intc/autoboard_edge_irq.c	2020-08-10 11:19:38.272721983 +0000
@@ -0,0 +1,361 @@
+/*
+ * autoboard edge irq stat machine implementation
+ */
+
+#include "qemu/osdep.h"
+
+#include "hw/intc/autoboard_intc_gen.h"
+#include "hw/intc/autoboard_edge_irq.h"
+#include "hw/intc/autoboard_intc_utils.h"
+#include "hw/misc/autoboard_utils.h"
+
+static bool edge_irq_is_acted(struct edge_irq_stat_mach *m)
+{
+    return (m->stat == EDGE_STAT_ACT);
+}
+
+static int edge_irq_dispatch(struct edge_irq_stat_mach *m, auto_trifle *at)
+{
+    int triggered;
+
+    if (at->type == TRIFLE_HW_EVT) {
+        // do act & do deact are mutually exclusive
+        if (at->hw_evt == EDGE_HW_EVT_DOACT) 
+            m->progs[EDGE_HW_EVT_DODEACT] = 0;
+        if (at->hw_evt == EDGE_HW_EVT_DODEACT)
+            m->progs[EDGE_HW_EVT_DOACT] = 0;
+    }
+
+    triggered = 0;
+
+    if (m->is_evt_off(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger off event for edge irq %d\n", m->irq_idx);
+        m->handle_event(m, EDGE_EVT_OFF);
+        triggered++;
+    }
+
+    if (m->is_evt_on(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger on event for edge irq %d\n", m->irq_idx);
+        m->handle_event(m, EDGE_EVT_ON);
+        triggered++;
+    }
+
+    if (m->is_evt_pulse(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger pulse event for edge irq %d\n", m->irq_idx);
+        m->handle_event(m, EDGE_EVT_PULSE);
+        triggered++;
+    }
+
+    if (m->is_evt_ack(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger ack event for edge irq %d\n", m->irq_idx);
+        m->handle_event(m, EDGE_EVT_ACK);
+        triggered++;
+    }
+
+    if (m->is_evt_msk(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger msk event for edge irq %d\n", m->irq_idx);
+        m->handle_event(m, EDGE_EVT_MSK);
+        triggered++;
+    }
+
+    if (m->is_evt_unmsk(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger unmsk event for edge irq %d\n", m->irq_idx);
+        m->handle_event(m, EDGE_EVT_UNMSK);
+        triggered++;
+    }
+
+    if (m->is_evt_reset(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger reset event for edge irq %d\n", m->irq_idx);
+        m->handle_event(m, EDGE_EVT_RESET);
+        triggered++;
+    }
+
+    if (m->is_evt_init(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger init event for edge irq %d\n", m->irq_idx);
+        m->handle_event(m, EDGE_EVT_INIT);
+        triggered++;
+    }
+
+    if (m->do_act(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger do act event for edge irq %d\n", m->irq_idx);
+        triggered++;
+    }
+
+    if (m->do_deact(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger do deact event for edge irq %d\n", m->irq_idx);
+        triggered++;
+    }
+
+    return triggered;
+}
+
+static void edge_irq_handle_event(edge_irq_stat_mach *m, edge_irq_event lie)
+{
+    switch (lie)
+    {
+    case EDGE_EVT_OFF:
+        m->stat = EDGE_STAT_OFF;
+        m->on = 0;
+
+        break;
+    
+    case EDGE_EVT_ON:
+        if (m->stat == EDGE_STAT_OFF) {
+            if (m->msk)
+                m->stat = EDGE_STAT_MSK;
+            else if (m->act) 
+                m->stat = EDGE_STAT_ACT;
+            else
+                m->stat = EDGE_STAT_IDLE;
+        }
+
+        m->on = 1;
+
+        break;
+    
+    case EDGE_EVT_INIT:
+        if (m->stat == EDGE_STAT_OFF) {
+            // when init, the irq is set as masked according to the kernel intc drivers' code we've seen
+            //m->stat = EDGE_STAT_IDLE;
+            m->stat = EDGE_STAT_MSK;
+            m->msk = 1;
+        }
+
+        m->on = 1;
+
+        break;
+
+    case EDGE_EVT_PULSE:
+        if (m->stat == EDGE_STAT_IDLE)
+            m->stat = EDGE_STAT_ACT;
+
+        m->act = 1;
+
+        break;
+    
+    case EDGE_EVT_ACK:
+        if (m->stat == EDGE_STAT_ACT)
+            m->stat = EDGE_STAT_IDLE;
+
+        m->act = 0;
+
+        break;
+    
+    case EDGE_EVT_MSK:
+        if (m->stat == EDGE_STAT_IDLE)
+            m->stat = EDGE_STAT_MSK;
+        else if (m->stat == EDGE_STAT_ACT)
+            m->stat = EDGE_STAT_MSK;
+
+        m->msk = 1;
+
+        break;
+    
+    case EDGE_EVT_UNMSK:
+        if (m->stat == EDGE_STAT_MSK) {
+            if (m->act) 
+                m->stat = EDGE_STAT_ACT;
+            else 
+                m->stat = EDGE_STAT_IDLE;
+        }
+
+        m->msk = 0;
+
+        break;
+    
+    case EDGE_EVT_RESET:
+        // TODO: here may need re-consider suitable reset logic
+        m->on = 1;
+        m->act = 0;
+        m->msk = 0;
+        m->stat = EDGE_STAT_IDLE;
+
+        break;
+    
+    default:
+        break;
+    }
+
+    return;
+}
+
+static uint8_t edge_irq_acu_func_flow(edge_irq_stat_mach *m, auto_config_action *aca, auto_trifle *at, uint8_t evt)
+{
+    uint32_t stat;
+    uint32_t *prog;
+    auto_config_unit *acu;
+
+    prog = &m->progs[evt];
+
+    do {
+        // continue the execution from the last time
+        acu = &aca->acus[*prog];
+        stat = intc_try_process_at_on_acu(m->s, acu, at);
+        if (stat == ACU_ST_NEXT) {
+            *prog = acu->next;
+        }
+    } while (ACU_IS_DO_REACT(acu->type) && stat == ACU_ST_NEXT);
+
+    // if done, means trigger
+    if (stat == ACU_ST_DONE) {
+        *prog = 0;
+        return stat;
+    }
+
+    // matching...
+    if (stat == ACU_ST_NEXT) {
+        return stat;
+    }
+
+    // if mismatch, re-match from the start again
+    if (stat == ACU_ST_MISMATCH) {
+        // TODO: for edge irq, maybe we shoule do cmp for specific hw evt 
+        //     when we have not start usage of hw evt
+        if ( (at->type == TRIFLE_HW_EVT && ACU_IS_DO_HW_WATCH(acu->type)) ||
+             ((at->type == TRIFLE_KER_READ || at->type == TRIFLE_KER_WRITE) && 
+                ACU_IS_DO_KER_WATCH(acu->type))
+           ) {
+            // if wait & come are same sources of event
+            //    then reset the prog & try match 1st thing again
+            if (*prog != 0) {
+                *prog = 0;
+                return edge_irq_acu_func_flow(m, aca, at, evt);
+            }
+        }
+
+        return stat;
+    }
+
+    assert(false && "shouldn't come to here in edge_irq_acu_func_flow");
+    return stat;
+}
+
+static uint8_t edge_irq_is_evt_off(edge_irq_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_off;
+    if (aca) 
+        return edge_irq_acu_func_flow(m, aca, at, EDGE_EVT_OFF);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t edge_irq_is_evt_on(edge_irq_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_on;
+    if (aca) 
+        return edge_irq_acu_func_flow(m, aca, at, EDGE_EVT_ON);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t edge_irq_is_evt_pulse(edge_irq_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_pulse;
+    if (aca) 
+        return edge_irq_acu_func_flow(m, aca, at, EDGE_EVT_PULSE);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t edge_irq_is_evt_ack(edge_irq_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_ack;
+    if (aca) 
+        return edge_irq_acu_func_flow(m, aca, at, EDGE_EVT_ACK);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t edge_irq_is_evt_msk(edge_irq_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_msk;
+    if (aca) 
+        return edge_irq_acu_func_flow(m, aca, at, EDGE_EVT_MSK);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t edge_irq_is_evt_unmsk(edge_irq_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_unmsk;
+    if (aca) 
+        return edge_irq_acu_func_flow(m, aca, at, EDGE_EVT_UNMSK);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t edge_irq_is_evt_reset(edge_irq_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_reset;
+    if (aca) 
+        return edge_irq_acu_func_flow(m, aca, at, EDGE_EVT_RESET);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t edge_irq_is_evt_init(edge_irq_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_init;
+    if (aca) 
+        return edge_irq_acu_func_flow(m, aca, at, EDGE_EVT_INIT);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t edge_irq_do_act(edge_irq_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->do_act;
+    if (aca) 
+        return edge_irq_acu_func_flow(m, aca, at, EDGE_HW_EVT_DOACT);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t edge_irq_do_deact(edge_irq_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->do_deact;
+    if (aca) 
+        return edge_irq_acu_func_flow(m, aca, at, EDGE_HW_EVT_DODEACT);
+
+    return ACU_ST_MISMATCH;
+}
+
+edge_irq_stat_mach *init_edge_irq_stat_mach(AUTOBOARD_INTCState *s, uint32_t cfg_idx)
+{
+    int i;
+    edge_irq_stat_mach *m;
+    assert(s->cfg->irq_cfgs[cfg_idx].irq_type == STAT_MACH_IRQ_EDGE);
+
+    m = calloc(1, sizeof(edge_irq_stat_mach));
+
+    m->s = s;
+    m->irq_idx = cfg_idx;
+    m->cfg = (edge_irq_cfg *)(s->cfg->irq_cfgs[cfg_idx].irq_stat_mach_cfg);
+
+    // at the very beginning, the intc is uninitialized & not activated & not masked
+    m->stat = EDGE_STAT_OFF;
+    m->on = 0;
+    m->act = 0;
+    m->msk = 0;
+
+    for (i = 0; i < EDGE_ALL_EVT_NUM; i++)
+        m->progs[i] = 0;
+
+    m->is_evt_off = edge_irq_is_evt_off;
+    m->is_evt_on = edge_irq_is_evt_on;
+    m->is_evt_pulse = edge_irq_is_evt_pulse;
+    m->is_evt_ack = edge_irq_is_evt_ack;
+    m->is_evt_msk = edge_irq_is_evt_msk;
+    m->is_evt_unmsk = edge_irq_is_evt_unmsk;
+    m->is_evt_reset = edge_irq_is_evt_reset;
+    m->is_evt_init = edge_irq_is_evt_init;
+
+    m->is_acted = edge_irq_is_acted;
+    m->do_act = edge_irq_do_act;
+    m->do_deact = edge_irq_do_deact;
+
+    m->handle_event = edge_irq_handle_event;
+    m->dispatch = edge_irq_dispatch;
+
+    return m;
+}
diff -rNu qemu-2.3.0.orig/hw/intc/autoboard_eoi_lvl_irq.c qemu-2.3.0/hw/intc/autoboard_eoi_lvl_irq.c
--- qemu-2.3.0.orig/hw/intc/autoboard_eoi_lvl_irq.c	1970-01-01 00:00:00.000000000 +0000
+++ qemu-2.3.0/hw/intc/autoboard_eoi_lvl_irq.c	2020-08-10 11:19:38.272721983 +0000
@@ -0,0 +1,385 @@
+/*
+ * autoboard level irq stat machine implementation
+ */
+
+#include "qemu/osdep.h"
+
+#include "hw/intc/autoboard_intc_gen.h"
+#include "hw/intc/autoboard_eoi_lvl_irq.h"
+#include "hw/intc/autoboard_intc_utils.h"
+#include "hw/misc/autoboard_utils.h"
+
+static bool eoi_lvl_irq_is_acted(struct eoi_lvl_irq_stat_mach *m)
+{
+    return (m->stat == EOI_LVL_STAT_ACT);
+}
+
+static int eoi_lvl_irq_dispatch(struct eoi_lvl_irq_stat_mach *m, auto_trifle *at)
+{
+    int triggered;
+
+    if (at->type == TRIFLE_HW_EVT) {
+        // do act & do deact are mutually exclusive
+        if (at->hw_evt == EOI_LVL_HW_EVT_DOACT || at->hw_evt == EOI_LVL_HW_EVT_DODEACT) {
+            m->progs[EOI_LVL_HW_EVT_DOACT] = 0;
+            m->progs[EOI_LVL_HW_EVT_DODEACT] = 0;
+        }
+    }
+
+    triggered = 0;
+
+    if (m->is_evt_off(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger off event for eoi lvl irq %d\n", m->irq_idx);
+        m->handle_event(m, EOI_LVL_EVT_OFF);
+        triggered++;
+    }
+
+    if (m->is_evt_on(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger on event for eoi lvl irq %d\n", m->irq_idx);
+        m->handle_event(m, EOI_LVL_EVT_ON);
+        triggered++;
+    }
+
+    if (m->is_evt_act(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger act event for eoi lvl irq %d\n", m->irq_idx);
+        m->handle_event(m, EOI_LVL_EVT_ACT);
+        triggered++;
+    }
+
+    if (m->is_evt_deact(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger deact event for eoi lvl irq %d\n", m->irq_idx);
+        m->handle_event(m, EOI_LVL_EVT_DEACT);
+        triggered++;
+    }
+
+    if (m->is_evt_eoi(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger eoi event for eoi lvl irq %d\n", m->irq_idx);
+        m->handle_event(m, EOI_LVL_EVT_EOI);
+        triggered++;
+    }
+
+    if (m->is_evt_msk(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger msk event for eoi lvl irq %d\n", m->irq_idx);
+        m->handle_event(m, EOI_LVL_EVT_MSK);
+        triggered++;
+    }
+
+    if (m->is_evt_unmsk(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger unmsk event for eoi lvl irq %d\n", m->irq_idx);
+        m->handle_event(m, EOI_LVL_EVT_UNMSK);
+        triggered++;
+    }
+
+    if (m->is_evt_reset(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger reset event for eoi lvl irq %d\n", m->irq_idx);
+        m->handle_event(m, EOI_LVL_EVT_RESET);
+        triggered++;
+    }
+
+    if (m->is_evt_init(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger init event for eoi lvl irq %d\n", m->irq_idx);
+        m->handle_event(m, EOI_LVL_EVT_INIT);
+        triggered++;
+    }
+
+    if (m->do_act(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger do act event for eoi lvl irq %d\n", m->irq_idx);
+        triggered++;
+    }
+
+    if (m->do_deact(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger do deact event for eoi lvl irq %d\n", m->irq_idx);
+        triggered++;
+    }
+
+    return triggered;
+}
+
+static void eoi_lvl_irq_handle_event(eoi_lvl_irq_stat_mach *m, eoi_lvl_irq_event lie)
+{
+    switch (lie)
+    {
+    case EOI_LVL_EVT_OFF:
+        m->stat = EOI_LVL_STAT_OFF;
+        m->on = 0;
+
+        break;
+    
+    case EOI_LVL_EVT_ON:
+        if (m->stat == EOI_LVL_STAT_OFF) {
+            if (m->msk)
+                m->stat = EOI_LVL_STAT_MSK;
+            else if (m->act) 
+                m->stat = EOI_LVL_STAT_ACT;
+            else
+                m->stat = EOI_LVL_STAT_IDLE;
+        }
+
+        m->on = 1;
+
+        break;
+    
+    case EOI_LVL_EVT_INIT:
+        if (m->stat == EOI_LVL_STAT_OFF) {
+            // when init, the irq is set as masked according to the kernel intc drivers' code we've seen
+            //m->stat = EOI_LVL_STAT_IDLE;
+            m->stat = EOI_LVL_STAT_MSK;
+            m->msk = 1;
+        }
+
+        m->on = 1;
+
+        break;
+
+    case EOI_LVL_EVT_ACT:
+        if (m->stat == EOI_LVL_STAT_IDLE)
+            m->stat = EOI_LVL_STAT_ACT;
+
+        m->act = 1;
+
+        break;
+    
+    case EOI_LVL_EVT_DEACT:
+        m->act = 0;
+
+        break;
+    
+    case EOI_LVL_EVT_EOI:
+        if (m->stat == EOI_LVL_STAT_ACT)
+            m->stat = EOI_LVL_STAT_IDLE;
+
+        // N.B. here we assume a normal eoi lvl device has deacted before we receive kernel's EOI
+        //      not very sure this is right or wrong
+
+        break;
+    
+    case EOI_LVL_EVT_MSK:
+        if (m->stat == EOI_LVL_STAT_IDLE)
+            m->stat = EOI_LVL_STAT_MSK;
+        else if (m->stat == EOI_LVL_STAT_ACT)
+            m->stat = EOI_LVL_STAT_MSK;
+
+        m->msk = 1;
+
+        break;
+    
+    case EOI_LVL_EVT_UNMSK:
+        if (m->stat == EOI_LVL_STAT_MSK) {
+            if (m->act) 
+                m->stat = EOI_LVL_STAT_ACT;
+            else 
+                m->stat = EOI_LVL_STAT_IDLE;
+        }
+
+        m->msk = 0;
+
+        break;
+    
+    case EOI_LVL_EVT_RESET:
+        // TODO: here may need re-consider suitable reset logic
+        m->on = 1;
+        m->act = 0;
+        m->msk = 0;
+        m->stat = EOI_LVL_STAT_IDLE;
+
+        break;
+    
+    default:
+        break;
+    }
+
+    return;
+}
+
+static uint8_t eoi_lvl_irq_acu_func_flow(eoi_lvl_irq_stat_mach *m, auto_config_action *aca, auto_trifle *at, uint8_t evt)
+{
+    uint32_t stat;
+    uint32_t *prog;
+    auto_config_unit *acu;
+
+    prog = &m->progs[evt];
+
+    do {
+        // continue the execution from the last time
+        acu = &aca->acus[*prog];
+        stat = intc_try_process_at_on_acu(m->s, acu, at);
+        if (stat == ACU_ST_NEXT) {
+            *prog = acu->next;
+        }
+    } while (ACU_IS_DO_REACT(acu->type) && stat == ACU_ST_NEXT);
+
+    // if done, means trigger
+    if (stat == ACU_ST_DONE) {
+        *prog = 0;
+        return stat;
+    }
+
+    // matching...
+    if (stat == ACU_ST_NEXT) {
+        return stat;
+    }
+
+    // if mismatch, re-match from the start again
+    if (stat == ACU_ST_MISMATCH) {
+        // for eoi lvl irq, we only have doact/dodeact now
+        // TODO: for eoi lvl irq, maybe we shoule do cmp for specific hw evt 
+        //     when we have not start usage of hw evt
+        if ( (at->type == TRIFLE_HW_EVT && ACU_IS_DO_HW_WATCH(acu->type)) ||
+             ((at->type == TRIFLE_KER_READ || at->type == TRIFLE_KER_WRITE) && 
+                ACU_IS_DO_KER_WATCH(acu->type))
+           ) {
+            // if wait & come are same sources of event
+            //    then reset the prog & try match 1st thing again
+            if (*prog != 0) {
+                *prog = 0;
+                return eoi_lvl_irq_acu_func_flow(m, aca, at, evt);
+            }
+        }
+
+        return stat;
+    }
+
+    assert(false && "shouldn't come to here in eoi_lvl_irq_acu_func_flow");
+    return stat;
+}
+
+static uint8_t eoi_lvl_irq_is_evt_off(eoi_lvl_irq_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_off;
+    if (aca) 
+        return eoi_lvl_irq_acu_func_flow(m, aca, at, EOI_LVL_EVT_OFF);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t eoi_lvl_irq_is_evt_on(eoi_lvl_irq_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_on;
+    if (aca) 
+        return eoi_lvl_irq_acu_func_flow(m, aca, at, EOI_LVL_EVT_ON);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t eoi_lvl_irq_is_evt_act(eoi_lvl_irq_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_act;
+    if (aca) 
+        return eoi_lvl_irq_acu_func_flow(m, aca, at, EOI_LVL_EVT_ACT);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t eoi_lvl_irq_is_evt_deact(eoi_lvl_irq_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_deact;
+    if (aca) 
+        return eoi_lvl_irq_acu_func_flow(m, aca, at, EOI_LVL_EVT_DEACT);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t eoi_lvl_irq_is_evt_eoi(eoi_lvl_irq_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_eoi;
+    if (aca) 
+        return eoi_lvl_irq_acu_func_flow(m, aca, at, EOI_LVL_EVT_EOI);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t eoi_lvl_irq_is_evt_msk(eoi_lvl_irq_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_msk;
+    if (aca) 
+        return eoi_lvl_irq_acu_func_flow(m, aca, at, EOI_LVL_EVT_MSK);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t eoi_lvl_irq_is_evt_unmsk(eoi_lvl_irq_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_unmsk;
+    if (aca) 
+        return eoi_lvl_irq_acu_func_flow(m, aca, at, EOI_LVL_EVT_UNMSK);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t eoi_lvl_irq_is_evt_reset(eoi_lvl_irq_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_reset;
+    if (aca) 
+        return eoi_lvl_irq_acu_func_flow(m, aca, at, EOI_LVL_EVT_RESET);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t eoi_lvl_irq_is_evt_init(eoi_lvl_irq_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_init;
+    if (aca) 
+        return eoi_lvl_irq_acu_func_flow(m, aca, at, EOI_LVL_EVT_INIT);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t eoi_lvl_irq_do_act(eoi_lvl_irq_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->do_act;
+    if (aca) 
+        return eoi_lvl_irq_acu_func_flow(m, aca, at, EOI_LVL_HW_EVT_DOACT);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t eoi_lvl_irq_do_deact(eoi_lvl_irq_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->do_deact;
+    if (aca) 
+        return eoi_lvl_irq_acu_func_flow(m, aca, at, EOI_LVL_HW_EVT_DODEACT);
+
+    return ACU_ST_MISMATCH;
+}
+
+eoi_lvl_irq_stat_mach *init_eoi_lvl_irq_stat_mach(AUTOBOARD_INTCState *s, uint32_t cfg_idx)
+{
+    int i;
+    eoi_lvl_irq_stat_mach *m;
+
+    assert(s->cfg->irq_cfgs[cfg_idx].irq_type == STAT_MACH_IRQ_EOI_LVL);
+
+    m = calloc(1, sizeof(eoi_lvl_irq_stat_mach));
+
+    m->s = s;
+    m->irq_idx = cfg_idx;
+    m->cfg = (eoi_lvl_irq_cfg *)(s->cfg->irq_cfgs[cfg_idx].irq_stat_mach_cfg);
+
+    // at the very beginning, the intc is uninitialized & not activated & not masked
+    m->stat = EOI_LVL_STAT_OFF;
+    m->on = 0;
+    m->act = 0;
+    m->msk = 0;
+
+    for (i = 0; i < EOI_LVL_ALL_EVT_NUM; i++)
+        m->progs[i] = 0;
+
+    m->is_evt_off = eoi_lvl_irq_is_evt_off;
+    m->is_evt_on = eoi_lvl_irq_is_evt_on;
+    m->is_evt_act = eoi_lvl_irq_is_evt_act;
+    m->is_evt_deact = eoi_lvl_irq_is_evt_deact;
+    m->is_evt_eoi = eoi_lvl_irq_is_evt_eoi;
+    m->is_evt_msk = eoi_lvl_irq_is_evt_msk;
+    m->is_evt_unmsk = eoi_lvl_irq_is_evt_unmsk;
+    m->is_evt_reset = eoi_lvl_irq_is_evt_reset;
+    m->is_evt_init = eoi_lvl_irq_is_evt_init;
+
+    m->is_acted = eoi_lvl_irq_is_acted;
+    m->do_act = eoi_lvl_irq_do_act;
+    m->do_deact = eoi_lvl_irq_do_deact;
+
+    m->handle_event = eoi_lvl_irq_handle_event;
+    m->dispatch = eoi_lvl_irq_dispatch;
+
+    return m;
+}
diff -rNu qemu-2.3.0.orig/hw/intc/autoboard_intc.c qemu-2.3.0/hw/intc/autoboard_intc.c
--- qemu-2.3.0.orig/hw/intc/autoboard_intc.c	1970-01-01 00:00:00.000000000 +0000
+++ qemu-2.3.0/hw/intc/autoboard_intc.c	2020-08-10 12:21:07.284666021 +0000
@@ -0,0 +1,527 @@
+/*
+ * autoboard intc implementation
+ */
+
+#include "qemu/osdep.h"
+#include "qemu-common.h"
+#include "qemu/log.h"
+#include "qapi/error.h"
+
+#include "hw/intc/autoboard_intc_utils.h"
+#include "hw/misc/autoboard_utils.h"
+#include "hw/intc/autoboard_intc_gen.h"
+#include "hw/intc/autoboard_edge_irq.h"
+#include "hw/intc/autoboard_level_irq.h"
+#include "hw/intc/autoboard_eoi_lvl_irq.h"
+#include "hw/intc/autoboard_intc.h"
+
+static autoboard_intc_cfg_id choosen_id = AUTOBOARD_INTC_INVALID;
+static const char *intc_name = "anonymous";
+
+void set_autoboard_intc_cfg(autoboard_intc_cfg_id id, const char *name)
+{
+    choosen_id = id; 
+    intc_name = name;
+}
+
+static uint32_t autoboard_mmio_read(autoboard_mmio *mmio, hwaddr off)
+{
+    // TODO: may need add lock here in future
+    return __u32_native(mmio->caches + off);
+}
+
+static uint32_t autoboard_mmio_write(autoboard_mmio *mmio, hwaddr off, uint64_t val)
+{
+    // TODO: may need add lock here in future
+    *((uint32_t *) (mmio->caches + off)) = (uint32_t) val;
+    return 0;
+}
+
+// check whether an irq is act or not, and do the act/deact action based on the arg 3
+static bool is_irq_act(AUTOBOARD_INTCState *s, int32_t irq_idx, int32_t action)
+{
+    uint8_t type;
+    auto_trifle at;
+
+    type = s->in_irqs[irq_idx].type;
+    switch(type) {
+    case STAT_MACH_IRQ_LEVEL:
+        {
+        level_irq_stat_mach *mach = s->in_irqs[irq_idx].stat_mach;
+        if (action == 1) {
+            //printf("[+] send do act lvl hwevt on irq %d\n", irq_idx);
+            at.type = TRIFLE_HW_EVT;
+            at.hw_evt = LVL_HW_EVT_DOACT;
+            mach->dispatch(mach, &at);
+        }
+        if (action == 2) {
+            //printf("[+] send do deact lvl hwevt on irq %d\n", irq_idx);
+            at.type = TRIFLE_HW_EVT;
+            at.hw_evt = LVL_HW_EVT_DODEACT;
+            mach->dispatch(mach, &at);
+        }
+
+        return mach->is_acted(mach);
+        }
+        break;
+    
+    case STAT_MACH_IRQ_EDGE:
+        {
+        edge_irq_stat_mach *mach = s->in_irqs[irq_idx].stat_mach;
+        if (action == 1) {
+            //printf("[+] send do act edge hwevt on irq %d\n", irq_idx);
+            at.type = TRIFLE_HW_EVT;
+            at.hw_evt = EDGE_HW_EVT_DOACT;
+            mach->dispatch(mach, &at);
+        }
+        if (action == 2) {
+            //printf("[+] send do deact edge hwevt on irq %d\n", irq_idx);
+            at.type = TRIFLE_HW_EVT;
+            at.hw_evt = EDGE_HW_EVT_DODEACT;
+            mach->dispatch(mach, &at);
+        }
+
+        return mach->is_acted(mach);
+        }
+        break;
+
+    case STAT_MACH_IRQ_EOI_LVL:
+        {
+        eoi_lvl_irq_stat_mach *mach = s->in_irqs[irq_idx].stat_mach;
+        if (action == 1) {
+            //printf("[+] send do act eoi lvl hwevt on irq %d\n", irq_idx);
+            at.type = TRIFLE_HW_EVT;
+            at.hw_evt = EOI_LVL_HW_EVT_DOACT;
+            mach->dispatch(mach, &at);
+        }
+        if (action == 2) {
+            //printf("[+] send do deact eoi lvl hwevt on irq %d\n", irq_idx);
+            at.type = TRIFLE_HW_EVT;
+            at.hw_evt = EOI_LVL_HW_EVT_DODEACT;
+            mach->dispatch(mach, &at);
+        }
+
+        return mach->is_acted(mach);
+        }
+        break;
+    case STAT_MACH_IRQ_EMPTY:
+        return false;
+        break;
+
+    default:
+        assert(false && "wierd irq type");
+        break;
+    }
+}
+
+// iterate all irqs beginning from start_idx, to find an act irq
+static int32_t find_next_act_irq_round_robin(AUTOBOARD_INTCState *s, int32_t start_idx)
+{
+    int32_t i, irq_idx;
+    uint8_t type;
+
+    for (i = 0; i < s->in_irq_num; i++) {
+        irq_idx = (start_idx + 1 + i) % (s->in_irq_num);
+        type = s->in_irqs[irq_idx].type;
+        switch(type) {
+        case STAT_MACH_IRQ_LEVEL:
+            {
+            level_irq_stat_mach *mach = s->in_irqs[irq_idx].stat_mach;
+            if (mach->is_acted(mach))
+                return irq_idx;
+            }
+            break;
+    
+        case STAT_MACH_IRQ_EDGE:
+            {
+            edge_irq_stat_mach *mach = s->in_irqs[irq_idx].stat_mach;
+            if (mach->is_acted(mach))
+                return irq_idx;
+            }
+            break;
+
+        case STAT_MACH_IRQ_EOI_LVL:
+            {
+            eoi_lvl_irq_stat_mach *mach = s->in_irqs[irq_idx].stat_mach;
+            if (mach->is_acted(mach))
+                return irq_idx;
+            }
+            break;
+
+        case STAT_MACH_IRQ_EMPTY:
+            break;
+
+        default:
+            assert(false && "wierd irq type");
+            break;
+        }
+    }
+
+    // found nothing
+    return -1;
+}
+
+static void autoboard_refresh_irq_lines(AUTOBOARD_INTCState *s)
+{
+    // we use round robin to activate irq
+    int32_t *act_irq = &(s->act_irq);
+    int32_t irq_idx;
+    
+    static int count = 0;
+    count++;
+
+    //printf("[+][%d] %s start refresh\n", count, s->name);
+
+    if (*act_irq != -1) {
+        if (is_irq_act(s, *act_irq, 0)) {
+            // still act, do nothing
+            is_irq_act(s, *act_irq, 1);
+            //printf("[+][%d] %s keep raise irq %d\n", count, s->name, *act_irq);
+            qemu_set_irq(s->irq, 1);
+            //printf("[+][%d] %s end 1 refresh\n", count, s->name);
+            return;
+        } else {
+            //printf("[+][%d] %s deact irq, irq %d\n", count, s->name, *act_irq);
+            is_irq_act(s, *act_irq, 2);
+        }
+    }
+
+    irq_idx = find_next_act_irq_round_robin(s, *act_irq);
+    if (irq_idx == -1) {
+        // no act irq
+        *act_irq = -1;
+        //printf("[+][%d] %s lower irq line off\n", count, s->name);
+        qemu_set_irq(s->irq, 0);
+    } else {
+        // act act_irq 
+        is_irq_act(s, irq_idx, 1);
+        *act_irq = irq_idx;
+        //printf("[+][%d] %s raise irq %d\n", count, s->name, irq_idx);
+        qemu_set_irq(s->irq, 1);
+    }
+
+    //printf("[+][%d] %s end 2 refresh\n", count, s->name);
+}
+
+static uint32_t dispatch_mmio_rw(AUTOBOARD_INTCState *s, auto_trifle *at)
+{
+    uint8_t type;
+    uint32_t irq_idx, triggered = 0;
+
+    // using mmio_rw_once to infer which irq is involved
+    for (irq_idx = 0; irq_idx < s->in_irq_num; irq_idx++) {
+        // TODO: here may add trigger series feature
+        type = s->in_irqs[irq_idx].type;
+        switch (type) {
+        case STAT_MACH_IRQ_LEVEL:
+            {
+            level_irq_stat_mach *mach = s->in_irqs[irq_idx].stat_mach;
+            triggered += mach->dispatch(mach, at);
+            }
+            break;
+    
+        case STAT_MACH_IRQ_EDGE:
+            {
+            edge_irq_stat_mach *mach = s->in_irqs[irq_idx].stat_mach;
+            triggered += mach->dispatch(mach, at);
+            }
+            break;
+
+        case STAT_MACH_IRQ_EOI_LVL:
+            {
+            eoi_lvl_irq_stat_mach *mach = s->in_irqs[irq_idx].stat_mach;
+            triggered += mach->dispatch(mach, at);
+            }
+            break;
+
+        case STAT_MACH_IRQ_EMPTY:
+            break;
+
+        default:
+            printf("[+] wierd irq type %d\n", type);
+            break;
+        }
+    }
+
+    return triggered;
+}
+
+static uint64_t autoboard_intc_read(void *opaque, hwaddr offset, unsigned size, unsigned mmio_idx)
+{
+    // as this is a read-only function, we may not need raise an event but read w/w.o lock
+    AUTOBOARD_INTCState *s;
+    auto_trifle at;
+    uint32_t triggered;
+    uint64_t res;
+
+    s = opaque;
+
+    res = s->aummios[mmio_idx].read(&s->aummios[mmio_idx], offset);
+
+    at.type = TRIFLE_KER_READ;
+    at.mmio_idx = mmio_idx;
+    at.off = offset;
+    at.old_val = res;
+    at.new_val = 0;
+
+    triggered = dispatch_mmio_rw(s, &at);
+
+    if (triggered) 
+        autoboard_refresh_irq_lines(s);
+
+    // read again as the mmio read may induce the change of mmio content
+    res = s->aummios[mmio_idx].read(&s->aummios[mmio_idx], offset);
+
+    //printf("[+] %s read idx %d off 0x%lx, size %d, value 0x%lx, %d event(s) are triggered\n", s->name, mmio_idx, offset, size, res, triggered);
+
+    return res;
+}
+
+static void autoboard_intc_write(void *opaque, hwaddr offset, uint64_t val, unsigned size, unsigned mmio_idx)
+{
+    AUTOBOARD_INTCState *s;
+    auto_trifle at;
+    uint32_t triggered;
+
+    s = opaque;
+
+    // offset, old_value, new_value
+    at.type = TRIFLE_KER_WRITE;
+    at.mmio_idx = mmio_idx;
+    at.off = offset;
+    at.old_val = (uint64_t)s->aummios[mmio_idx].read(&s->aummios[mmio_idx], offset);
+    at.new_val = val;
+
+    // update the value
+    s->aummios[mmio_idx].write(&s->aummios[mmio_idx], offset, val);
+
+    triggered = dispatch_mmio_rw(s, &at);
+
+    if (triggered) 
+        autoboard_refresh_irq_lines(s);
+
+    //printf("[+] %s write idx %d off 0x%lx, size %d, change value from 0x%lx to 0x%lx, %d event(s) are triggered\n", s->name, mmio_idx, at.off, size, at.old_val, at.new_val, triggered);
+}
+
+AUTOBOARD_MAKE_MMIO_RANGE_RW_FUNCS(intc, 0)
+AUTOBOARD_MAKE_MMIO_RANGE_RW_FUNCS(intc, 1)
+
+static const MemoryRegionOps autoboard_intc_ops[AUTOBOARD_INTC_MMIO_REGION_NUM] = {
+    AUTOBOARD_MMIO_OPS_STATIC_STRUCT(intc, 0)
+    AUTOBOARD_MMIO_OPS_STATIC_STRUCT(intc, 1)
+};
+
+static void autoboard_intc_device_irq_cb(void *opaque, int irq, int level)
+{
+    AUTOBOARD_INTCState *s;
+    auto_trifle at;
+
+    s = opaque;
+
+    // too many
+    //printf("[+] come into autoboard intc callback for irq #%d %s\n", irq, (level == 0)?("act"):("deact"));
+
+    // raise an irq act/deact event
+    switch (s->in_irqs[irq].type)
+    {
+    case STAT_MACH_IRQ_LEVEL:
+        {
+        level_irq_stat_mach *mach;
+
+        at.type = TRIFLE_HW_EVT;
+        if (level)
+            at.hw_evt = LVL_EVT_ACT;
+        else
+            at.hw_evt = LVL_EVT_DEACT;
+
+        mach = s->in_irqs[irq].stat_mach;
+        mach->dispatch(mach, &at);
+        }
+        break;
+    
+    case STAT_MACH_IRQ_EDGE:
+        {
+        edge_irq_stat_mach *mach;
+
+        at.type = TRIFLE_HW_EVT;
+        if (level)
+            at.hw_evt = EDGE_HW_EVT_PULSE_UP;
+        else
+            at.hw_evt = EDGE_HW_EVT_PULSE_DOWN;
+
+        mach = s->in_irqs[irq].stat_mach;
+        mach->dispatch(mach, &at);
+        }
+        break;
+    
+    case STAT_MACH_IRQ_EOI_LVL:
+        {
+        eoi_lvl_irq_stat_mach *mach;
+
+        at.type = TRIFLE_HW_EVT;
+        if (level)
+            at.hw_evt = EOI_LVL_EVT_ACT;
+        else
+            at.hw_evt = EOI_LVL_EVT_DEACT;
+
+        mach = s->in_irqs[irq].stat_mach;
+        mach->dispatch(mach, &at);
+        }
+        break;
+    
+    default:
+        return;
+        break;
+    }
+
+    autoboard_refresh_irq_lines(s);
+}
+
+static void autoboard_intc_init(Object *obj)
+{
+    AUTOBOARD_INTCState *s = AUTOBOARD_INTC(obj);
+    int i;
+
+    s->act_irq = -1;
+    s->name = intc_name;
+    s->cfg = get_autoboard_intc_config(choosen_id);
+
+    /* initialize the mmio cache & the mmio */
+    assert(s->cfg->mm_amount > 0 && s->cfg->mm_amount <= AUTOBOARD_INTC_MMIO_REGION_NUM && "wierd s->cfg->mm_amount");
+
+    s->mmios = calloc(s->cfg->mm_amount, sizeof(MemoryRegion));
+    s->aummios = calloc(s->cfg->mm_amount, sizeof(autoboard_mmio));
+    for (i = 0; i < s->cfg->mm_amount; i++) {
+        s->aummios[i].mmio_len = s->cfg->mm_lens[i];
+        s->aummios[i].caches = calloc(1, s->aummios[i].mmio_len);
+        s->aummios[i].read = autoboard_mmio_read;
+        s->aummios[i].write = autoboard_mmio_write;
+
+        memory_region_init_io(&(s->mmios[i]), obj, &(autoboard_intc_ops[i]), s, TYPE_AUTOBOARD_INTC, s->aummios[i].mmio_len);
+        sysbus_init_mmio(SYS_BUS_DEVICE(s), &(s->mmios[i]));
+    }
+
+    // TODO: ugly fix for init value of one addr in oxnas.gic
+    if (choosen_id == AUTOBOARD_INTC_OXNAS_GENERIC_GIC)
+        s->aummios[0].write(&s->aummios[0], 0x4, 0x1);
+
+    /* initialize the out irq to cpu */
+    // seems xxx & xxx_named cannot be mixly used
+    //qdev_init_gpio_out_named(DEVICE(s), &s->irq, "irq2cpu", 1);
+    // TODO: another ugly fix for the gic, re-do this when free
+    if (choosen_id == AUTOBOARD_INTC_OXNAS_GENERIC_GIC)
+        sysbus_init_irq(SYS_BUS_DEVICE(s), &s->irq);
+    else
+        qdev_init_gpio_out(DEVICE(s), &s->irq, 1);
+
+    /* initialize the in irqs connected with device */
+    //printf("autoboard_irq_num %d\n", s->cfg->irq_num);
+    //qdev_init_gpio_in_named(DEVICE(s), autoboard_intc_device_irq_cb, "irq2devs", s->cfg->irq_num);
+    qdev_init_gpio_in(DEVICE(s), autoboard_intc_device_irq_cb, s->cfg->irq_num);
+
+    // TODO: maybe some other init ops for members of s
+    //       ...
+
+    /* init irq related */
+    s->in_irq_num = s->cfg->irq_num;
+    s->in_irqs = (irq_bundle *)calloc(s->cfg->irq_num, sizeof(struct irq_bundle));
+
+    for (uint32_t i = 0; i < s->in_irq_num; i++) {
+        uint8_t type = s->cfg->irq_cfgs[i].irq_type;
+        s->in_irqs[i].type = type;
+        switch(type) {
+            case STAT_MACH_IRQ_EMPTY:
+                break;
+            case STAT_MACH_IRQ_LEVEL:
+                s->in_irqs[i].stat_mach = init_level_irq_stat_mach(s, i);
+                break;
+            case STAT_MACH_IRQ_EDGE:
+                s->in_irqs[i].stat_mach = init_edge_irq_stat_mach(s, i);
+                break;
+            case STAT_MACH_IRQ_EOI_LVL:
+                s->in_irqs[i].stat_mach = init_eoi_lvl_irq_stat_mach(s, i);
+                break;
+            default:
+                assert("wierd irq type:" && type && false);
+                break;
+        }
+    }
+}
+
+static void autoboard_intc_reset(DeviceState *dev)
+{
+    AUTOBOARD_INTCState *s;
+    auto_trifle at;
+
+    s = AUTOBOARD_INTC(dev);
+
+    // TODO: some other reset ops for members of s
+    // ...
+
+    // raise evt_reset event for all irqs
+    for (uint32_t i = 0; i < s->in_irq_num; i++) {
+        switch (s->in_irqs[i].type)
+        {
+        case STAT_MACH_IRQ_LEVEL:
+            {
+            level_irq_stat_mach *mach;
+
+            at.type = TRIFLE_HW_EVT;
+            at.hw_evt = LVL_EVT_RESET;
+
+            mach = s->in_irqs[i].stat_mach;
+            mach->dispatch(mach, &at);
+            }
+            break;
+        
+        case STAT_MACH_IRQ_EDGE:
+            {
+            edge_irq_stat_mach *mach;
+
+            at.type = TRIFLE_HW_EVT;
+            at.hw_evt = EDGE_EVT_RESET;
+
+            mach = s->in_irqs[i].stat_mach;
+            mach->dispatch(mach, &at);
+            }
+            break;
+
+        case STAT_MACH_IRQ_EOI_LVL:
+            {
+            eoi_lvl_irq_stat_mach *mach;
+
+            at.type = TRIFLE_HW_EVT;
+            at.hw_evt = EOI_LVL_EVT_RESET;
+
+            mach = s->in_irqs[i].stat_mach;
+            mach->dispatch(mach, &at);
+            }
+            break;
+
+        default:
+            break;
+        }
+    }
+}
+
+static void autoboard_intc_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+
+    dc->reset = autoboard_intc_reset;
+}
+
+static TypeInfo autoboard_intc_type_info = {
+    .name = TYPE_AUTOBOARD_INTC,
+    .parent = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(AUTOBOARD_INTCState),
+    .instance_init = autoboard_intc_init,
+    .class_init = autoboard_intc_class_init,
+};
+
+static void autoboard_intc_register_types(void)
+{
+    type_register_static(&autoboard_intc_type_info);
+}
+
+type_init(autoboard_intc_register_types)
diff -rNu qemu-2.3.0.orig/hw/intc/autoboard_intc_gen.c qemu-2.3.0/hw/intc/autoboard_intc_gen.c
--- qemu-2.3.0.orig/hw/intc/autoboard_intc_gen.c	1970-01-01 00:00:00.000000000 +0000
+++ qemu-2.3.0/hw/intc/autoboard_intc_gen.c	2020-08-10 11:19:38.272721983 +0000
@@ -0,0 +1,1603 @@
+/*
+ * autoboard intc auto generated implementation
+ */
+
+#include "qemu/osdep.h"
+
+#include "hw/intc/autoboard_intc.h"
+#include "hw/intc/autoboard_edge_irq.h"
+#include "hw/intc/autoboard_level_irq.h"
+#include "hw/intc/autoboard_eoi_lvl_irq.h"
+#include "hw/intc/autoboard_intc_gen.h"
+#include "hw/intc/autoboard_intc_utils.h"
+#include "hw/misc/autoboard_utils.h"
+
+// xxx_verify is untested & no use currently
+static uint8_t bit_verify(auto_trifle *at, uint32_t bit_pos, uint32_t raise)
+{
+    uint32_t tmp;
+
+    if (at->type == TRIFLE_KER_WRITE) {
+        tmp = 1 << bit_pos;
+
+        if (raise)
+            return ((tmp & at->old_val) == 0) && ((tmp & at->new_val) == tmp);
+        else
+            return ((tmp & at->old_val) == tmp) && ((tmp & at->new_val) == 0);
+    } else 
+        return false;
+}
+
+static uint8_t constraint_verify(auto_trifle *at)
+{
+    return ACU_ST_MISMATCH;
+}
+
+uint8_t intc_try_process_at_on_acu(AUTOBOARD_INTCState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    switch (acu->type) {
+        case ACU_DO_WATCH_READ:
+        {
+            if ((at->type != TRIFLE_KER_READ) || (at->mmio_idx != acu->midx) || (at->off != acu->moff))
+                return ACU_ST_MISMATCH;
+        }
+            break;
+        case ACU_DO_WATCH_WRITE:
+        {
+            if ((at->type != TRIFLE_KER_WRITE) || (at->mmio_idx != acu->midx) || (at->off != acu->moff))
+                return ACU_ST_MISMATCH;
+
+            if (!acu->match_write_cnt(s, acu, at))
+                return ACU_ST_MISMATCH;
+        }
+            break;
+        case ACU_DO_WATCH_HWEVT:
+        {
+            if ((at->type != TRIFLE_HW_EVT) || (at->hw_evt != acu->hw_evt))
+                return ACU_ST_MISMATCH;
+        }
+            break;
+        case ACU_DO_REACT:
+        {
+            acu->do_react(s, acu, at);
+        }
+            break;
+        default:
+            assert(false && "this should not be executed");
+            break;
+    }
+
+    return (acu->next) ? (ACU_ST_NEXT) : (ACU_ST_DONE);
+}
+
+/*
+ * generic configs for convenient reuse
+ */
+
+static auto_config_action wait_hw_evt_lvl_evt_reset_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_HWEVT,
+            .hw_evt = LVL_EVT_RESET,
+            .next = 0,
+        }
+    }
+};
+
+static auto_config_action wait_hw_evt_lvl_evt_act_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_HWEVT,
+            .hw_evt = LVL_EVT_ACT,
+            .next = 0,
+        }
+    }
+};
+
+static auto_config_action wait_hw_evt_lvl_evt_deact_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_HWEVT,
+            .hw_evt = LVL_EVT_DEACT,
+            .next = 0,
+        }
+    }
+};
+
+static auto_config_action wait_hw_evt_edge_evt_reset_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_HWEVT,
+            .hw_evt = EDGE_EVT_RESET,
+            .next = 0,
+        }
+    }
+};
+
+static auto_config_action wait_hw_evt_edge_evt_pulse_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_HWEVT,
+            .hw_evt = EDGE_HW_EVT_PULSE_UP,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_WATCH_HWEVT,
+            .hw_evt = EDGE_HW_EVT_PULSE_DOWN,
+            .next = 0,
+        },
+    }
+};
+
+static auto_config_action wait_hw_evt_eoi_lvl_evt_reset_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_HWEVT,
+            .hw_evt = EOI_LVL_EVT_RESET,
+            .next = 0,
+        }
+    }
+};
+
+static auto_config_action wait_hw_evt_eoi_lvl_evt_act_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_HWEVT,
+            .hw_evt = EOI_LVL_EVT_ACT,
+            .next = 0,
+        }
+    }
+};
+
+static auto_config_action wait_hw_evt_eoi_lvl_evt_deact_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_HWEVT,
+            .hw_evt = EOI_LVL_EVT_DEACT,
+            .next = 0,
+        }
+    }
+};
+
+/*
+ * for ramips.rt3883
+ *
+ * we only need 1 irq for uart
+ * 
+ * for the ramips.rt3883:
+ *  0x0  - status 1
+ *  0x34 - enable
+ *  0x38 - disable
+ * 
+ * static u32 rt_intc_regs[] = {
+ *     [INTC_REG_STATUS0] = 0x00,
+ *     [INTC_REG_STATUS1] = 0x04,
+ *     [INTC_REG_TYPE] = 0x20,
+ *     [INTC_REG_RAW_STATUS] = 0x30,
+ *     [INTC_REG_ENABLE] = 0x34,
+ *     [INTC_REG_DISABLE] = 0x38,
+ * };
+ *
+ * for the bit 31 of enable/disable, it controls the global enable/disable
+ * see more details, in https://cdn.sparkfun.com/datasheets/Wireless/WiFi/RT5350.pdf
+ *
+ */
+
+#define RAMIPS_RT3883_MMIO_AMOUNT 1
+#define RAMIPS_RT3883_MMIO1 0x100
+#define RAMIPS_RT3883_AUTOBOARD_IRQ_NUM 32
+
+static uint32_t ramips_rt3883_mmio_lens[RAMIPS_RT3883_MMIO_AMOUNT] = {
+   RAMIPS_RT3883_MMIO1, 
+};
+
+static uint8_t ramips_rt3883_uart_is_init_func_0(AUTOBOARD_INTCState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    return (at->new_val == (uint32_t)0xffffffff);
+}
+
+static uint8_t ramips_rt3883_uart_is_init_func_1(AUTOBOARD_INTCState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    return (at->new_val == (uint32_t)0x0);
+}
+
+static uint8_t ramips_rt3883_uart_is_init_func_2(AUTOBOARD_INTCState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    return (at->new_val == (uint32_t)(0x1 << 31));
+}
+
+static auto_config_action ramips_rt3883_uart_is_init_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x38,
+            .match_write_cnt = ramips_rt3883_uart_is_init_func_0,
+            .next = 1,
+        },{
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x20,
+            .match_write_cnt = ramips_rt3883_uart_is_init_func_1,
+            .next = 2,
+        },{
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x34,
+            .match_write_cnt = ramips_rt3883_uart_is_init_func_2,
+            .next = 0,
+        }
+    }
+};
+
+static uint8_t ramips_rt3883_uart_is_msk_func(AUTOBOARD_INTCState *s, auto_config_unit *acu, auto_trifle *at) 
+{
+    return at->new_val == ((uint32_t)(0x1 << acu->irq));
+}
+
+static auto_config_action ramips_rt3883_uart_is_msk_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x38,
+            .irq = 12,
+            .match_write_cnt = ramips_rt3883_uart_is_msk_func,
+            .next = 0,
+        }
+    },
+};
+
+static uint8_t ramips_rt3883_uart_is_unmsk_func(AUTOBOARD_INTCState *s, auto_config_unit *acu, auto_trifle *at) 
+{
+    return at->new_val == ((uint32_t)(0x1 << acu->irq));
+}
+
+static auto_config_action ramips_rt3883_uart_is_unmsk_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x34,
+            .irq = 12,
+            .match_write_cnt = ramips_rt3883_uart_is_unmsk_func,
+            .next = 0,
+        }
+    }
+};
+
+static uint8_t ramips_rt3883_uart_do_act_func(AUTOBOARD_INTCState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    //uint32_t val = s->aummios[acu->midx].read(&s->aummios[acu->midx], acu->moff);
+    //printf("[+] uart act write before 0x%x, size %d, value 0x%x\n", acu->moff, 4, val);
+    //s->aummios[acu->midx].write(&s->aummios[acu->midx], acu->moff, val | (uint32_t)(1 << acu->irq));
+    s->aummios[acu->midx].write(&s->aummios[acu->midx], acu->moff, (uint32_t)(1 << acu->irq));
+    //printf("[+] uart act write after 0x%x, size %d, value 0x%x\n", acu->moff, 4, val | (uint32_t)(1 << acu->irq));
+    return 0;
+}
+
+static auto_config_action ramips_rt3883_uart_do_act_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_HWEVT,
+            .hw_evt = LVL_HW_EVT_DOACT,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_REACT,
+            .midx = 0,
+            .moff = 0x0,
+            .irq = 12,
+            .do_react = ramips_rt3883_uart_do_act_func,
+            .next = 0,
+        }
+    }
+};
+
+static uint8_t ramips_rt3883_uart_do_deact_func(AUTOBOARD_INTCState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    //uint32_t val = s->aummios[acu->midx].read(&s->aummios[acu->midx], acu->moff);
+    //printf("[+] uart de-act write before 0x%x, size %d, value 0x%x\n", acu->moff, 4, val);
+    //s->aummios[acu->midx].write(&s->aummios[acu->midx], acu->moff, val & (~((uint32_t) (1 << acu->irq))));
+    s->aummios[acu->midx].write(&s->aummios[acu->midx], acu->moff, 0);
+    //printf("[+] uart de-act write after 0x%x, size %d, value 0x%x\n", acu->moff, 4, val & (~((uint32_t) (1 << acu->irq))));
+    return 0;
+}
+
+static auto_config_action ramips_rt3883_uart_do_deact_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_HWEVT,
+            .hw_evt = LVL_HW_EVT_DODEACT,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_REACT,
+            .midx = 0,
+            .moff = 0x0,
+            .irq = 12,
+            .do_react = ramips_rt3883_uart_do_deact_func,
+            .next = 0,
+        }
+    }
+};
+
+static level_irq_cfg ramips_rt3883_uart_level_irq_cfg = {
+    .is_off = NULL,
+    .is_on = NULL,
+    .is_act = &wait_hw_evt_lvl_evt_act_cfg,
+    .is_deact = &wait_hw_evt_lvl_evt_deact_cfg,
+    .is_msk = &ramips_rt3883_uart_is_msk_cfg,
+    .is_unmsk = &ramips_rt3883_uart_is_unmsk_cfg,
+    .is_reset = &wait_hw_evt_lvl_evt_reset_cfg,
+    .is_init = &ramips_rt3883_uart_is_init_cfg,
+    .do_act = &ramips_rt3883_uart_do_act_cfg,
+    .do_deact = &ramips_rt3883_uart_do_deact_cfg,
+};
+
+static auto_config_one_irq ramips_rt3883_irq_cfgs[RAMIPS_RT3883_AUTOBOARD_IRQ_NUM] = {
+    [12] = {
+        .irq_type = STAT_MACH_IRQ_LEVEL,
+        .irq_stat_mach_cfg = &ramips_rt3883_uart_level_irq_cfg,
+    }
+};
+
+
+/*
+ * for ath79.generic
+ *
+ * we only need 1 irq for uart, this is also a level irq
+ * 
+ */
+
+#define ATH79_GENERIC_MMIO_AMOUNT 1
+#define ATH79_GENERIC_MMIO1 0x100
+#define ATH79_GENERIC_AUTOBOARD_IRQ_NUM 32
+static uint32_t ath79_generic_mmio_lens[ATH79_GENERIC_MMIO_AMOUNT] = {
+   ATH79_GENERIC_MMIO1, 
+};
+
+
+static uint8_t ath79_generic_uart_is_msk_func0(AUTOBOARD_INTCState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    // This endian swap may due to the uart serial initializes with BIG ENDIAN
+    //if (at->new_val == ((at->old_val) & (__swap32(~(uint32_t)(1 << acu->irq)))))
+    //    //printf("[+] match the msk of irq %d\n", acu->irq);
+    return at->new_val == ((at->old_val) & (__swap32(~(uint32_t)(1 << acu->irq))));
+}
+
+static auto_config_action ath79_generic_uart_is_msk_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_READ,
+            .midx = 0,
+            .moff = 0x4,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x4,
+            .irq = 3,
+            .match_write_cnt = ath79_generic_uart_is_msk_func0,
+            .next = 2,
+        },
+        {
+            .type = ACU_DO_WATCH_READ,
+            .midx = 0,
+            .moff = 0x4,
+            .next = 0,
+        }
+    }
+};
+
+static uint8_t ath79_generic_uart_is_unmsk_func0(AUTOBOARD_INTCState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    // This endian swap may due to the uart serial initializes with BIG ENDIAN
+    //if (at->new_val == ((at->old_val) | (__swap32((uint32_t)(1 << acu->irq)))))
+    //    //printf("[+] match the unmsk of irq %d\n", acu->irq);
+    return at->new_val == ((at->old_val) | (__swap32((uint32_t)(1 << acu->irq))));
+}
+
+static auto_config_action ath79_generic_uart_is_unmsk_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_READ,
+            .midx = 0,
+            .moff = 0x4,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x4,
+            .irq = 3,
+            .match_write_cnt = ath79_generic_uart_is_unmsk_func0,
+            .next = 2,
+        },
+        {
+            .type = ACU_DO_WATCH_READ,
+            .midx = 0,
+            .moff = 0x4,
+            .next = 0,
+        }
+    }
+};
+
+static uint8_t ath79_generic_uart_do_act_func(AUTOBOARD_INTCState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    uint32_t status = 0, enable = 4;
+    //uint32_t val = s->aummios[acu->midx].read(&s->aummios[acu->midx], acu->moff);
+    //printf("[+] uart act write before 0x%x, size %d, value 0x%x\n", acu->moff, 4, val);
+    //s->aummios[acu->midx].write(&s->aummios[acu->midx], acu->moff, val | (uint32_t)(1 << acu->irq));
+    // This endian swap may due to the uart serial initializes with BIG ENDIAN
+    s->aummios[acu->midx].write(s->aummios, status, __swap32((uint32_t)(1 << acu->irq)));
+    s->aummios[acu->midx].write(s->aummios, enable, __swap32((uint32_t)(1 << acu->irq)));
+    //printf("[+] uart act write after 0x%x, size %d, value 0x%x\n", acu->moff, 4, val | (uint32_t)(1 << acu->irq));
+    return 0;
+}
+
+static auto_config_action ath79_generic_uart_do_act_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_HWEVT,
+            .hw_evt = LVL_HW_EVT_DOACT,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_REACT,
+            .irq = 3,
+            .do_react = ath79_generic_uart_do_act_func,
+            .next = 0,
+        }
+    }
+};
+
+static uint8_t ath79_generic_uart_do_deact_func(AUTOBOARD_INTCState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    uint32_t status = 0, enable = 4;
+    //uint32_t val = s->aummios[acu->midx].read(&s->aummios[acu->midx], acu->moff);
+    //printf("[+] uart de-act write before 0x%x, size %d, value 0x%x\n", acu->moff, 4, val);
+    //s->aummios[acu->midx].write(&s->aummios[acu->midx], acu->moff, val & (~((uint32_t) (1 << acu->irq))));
+    s->aummios[acu->midx].write(s->aummios, status, 0);
+    s->aummios[acu->midx].write(s->aummios, enable, 0);
+    //printf("[+] uart de-act write after 0x%x, size %d, value 0x%x\n", acu->moff, 4, val & (~((uint32_t) (1 << acu->irq))));
+    return 0;
+}
+
+static auto_config_action ath79_generic_uart_do_deact_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_HWEVT,
+            .hw_evt = LVL_HW_EVT_DODEACT,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_REACT,
+            .irq = 3,
+            .do_react = ath79_generic_uart_do_deact_func,
+            .next = 0,
+        }
+    }
+};
+
+static uint8_t ath79_generic_uart_is_init_func_0(AUTOBOARD_INTCState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    return (at->new_val == (uint32_t)0x0);
+}
+
+static uint8_t ath79_generic_uart_is_init_func_1(AUTOBOARD_INTCState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    return (at->new_val == (uint32_t)0x0);
+}
+
+static auto_config_action ath79_generic_uart_is_init_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0x0,
+            .moff = 0x4,
+            .match_write_cnt = ath79_generic_uart_is_init_func_0,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0x0,
+            .moff = 0x0,
+            .match_write_cnt = ath79_generic_uart_is_init_func_1,
+            .next = 0,
+        }
+    }
+};
+
+static level_irq_cfg ath79_generic_uart_level_irq_cfg = {
+    .is_off = NULL,
+    .is_on = NULL,
+    .is_act = &wait_hw_evt_lvl_evt_act_cfg,
+    .is_deact = &wait_hw_evt_lvl_evt_deact_cfg,
+    .is_msk = &ath79_generic_uart_is_msk_cfg,
+    .is_unmsk = &ath79_generic_uart_is_unmsk_cfg,
+    .is_reset = &wait_hw_evt_lvl_evt_reset_cfg,
+    .is_init = &ath79_generic_uart_is_init_cfg,
+    .do_act = &ath79_generic_uart_do_act_cfg,
+    .do_deact = &ath79_generic_uart_do_deact_cfg,
+};
+
+static auto_config_one_irq ath79_generic_irq_cfgs[ATH79_GENERIC_AUTOBOARD_IRQ_NUM] = {
+    [3] = {
+        .irq_type = STAT_MACH_IRQ_LEVEL,
+        .irq_stat_mach_cfg = &ath79_generic_uart_level_irq_cfg,
+    }
+};
+
+/*
+ * for kirkwood.generic
+ * 
+ * we have 2 intc, orion & bridge
+ * 
+ */
+
+/*
+ * for kirkwood.generic orion intc
+ * 
+ * we have 3 irqs connected to it, bridge intc & uart0 & uart1
+ */
+
+#define KIRKWOOD_GENERIC_ORION_MMIO_AMOUNT 1
+#define KIRKWOOD_GENERIC_ORION_MMIO1 0x20
+#define KIRKWOOD_GENERIC_ORION_AUTOBOARD_IRQ_NUM 64
+static uint32_t kirkwood_generic_orion_mmio_lens[KIRKWOOD_GENERIC_ORION_MMIO_AMOUNT] = {
+   KIRKWOOD_GENERIC_ORION_MMIO1, 
+};
+
+static uint8_t kirkwood_generic_common_is_msk_func(AUTOBOARD_INTCState *s, struct auto_config_unit *acu, auto_trifle *at)
+{
+    return (at->new_val == (at->old_val & (~(uint32_t)(1 << (acu->irq % 32)))));
+}
+
+static uint8_t kirkwood_generic_common_is_unmsk_func(AUTOBOARD_INTCState *s, struct auto_config_unit *acu, auto_trifle *at)
+{
+    return (at->new_val == (at->old_val | ((uint32_t)(1 << (acu->irq % 32)))));
+}
+
+static uint8_t kirkwood_generic_common_do_act_func(AUTOBOARD_INTCState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    uint32_t cause, mask;
+    //uint32_t val = s->aummios[acu->midx].read(&s->aummios[acu->midx], acu->moff);
+    //printf("[+] uart act write before 0x%x, size %d, value 0x%x\n", acu->moff, 4, val);
+    cause = (acu->irq / 32) * 0x10 + 0;
+    mask = (acu->irq / 32) * 0x10 + 4;
+    s->aummios[acu->midx].write(&s->aummios[acu->midx], cause, (uint32_t)(1 << (acu->irq % 32)));
+    s->aummios[acu->midx].write(&s->aummios[acu->midx], mask, (uint32_t)(1 << (acu->irq % 32)));
+    //printf("[+] uart act write after 0x%x, size %d, value 0x%x\n", acu->moff, 4, val | (uint32_t)(1 << acu->irq));
+    return 0;
+}
+
+static uint8_t kirkwood_generic_common_do_deact_func(AUTOBOARD_INTCState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    uint32_t cause, mask;
+    //uint32_t val = s->aummios[acu->midx].read(&s->aummios[acu->midx], acu->moff);
+    //printf("[+] uart act write before 0x%x, size %d, value 0x%x\n", acu->moff, 4, val);
+    cause = (acu->irq / 32) * 0x10 + 0;
+    mask = (acu->irq / 32) * 0x10 + 4;
+    s->aummios[acu->midx].write(s->aummios, cause, (uint32_t)(0));
+    s->aummios[acu->midx].write(s->aummios, mask, (uint32_t)(0));
+    //printf("[+] uart act write after 0x%x, size %d, value 0x%x\n", acu->moff, 4, val | (uint32_t)(1 << acu->irq));
+    return 0;
+}
+
+static uint8_t kirkwood_generic_orion_common_is_init_func0(AUTOBOARD_INTCState *s, struct auto_config_unit *acu, auto_trifle *at)
+{
+    return (at->new_val == (uint32_t)(0x0));
+}
+
+static uint8_t kirkwood_generic_orion_common_is_init_func1(AUTOBOARD_INTCState *s, struct auto_config_unit *acu, auto_trifle *at)
+{
+    return (at->new_val == (uint32_t)(0x0));
+}
+
+static auto_config_action kirkwood_generic_orion_common_is_init_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x4,
+            .match_write_cnt = kirkwood_generic_orion_common_is_init_func0,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x14,
+            .match_write_cnt = kirkwood_generic_orion_common_is_init_func1,
+            .next = 0,
+        }
+    }
+};
+
+static auto_config_action kirkwood_generic_orion_bridge_intc_is_msk_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x4,
+            .irq = 1,
+            .match_write_cnt = kirkwood_generic_common_is_msk_func,
+            .next = 0,
+        },
+    }
+};
+
+static auto_config_action kirkwood_generic_orion_bridge_intc_is_unmsk_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x4,
+            .irq = 1,
+            .match_write_cnt = kirkwood_generic_common_is_unmsk_func,
+            .next = 0,
+        },
+    },
+};
+
+static auto_config_action kirkwood_generic_orion_bridge_intc_do_act_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_HWEVT,
+            .hw_evt = LVL_HW_EVT_DOACT,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_REACT,
+            .irq = 1,
+            .midx = 0,
+            .moff = 0,
+            .do_react = kirkwood_generic_common_do_act_func,
+            .next = 0,
+        }
+    }
+};
+
+static auto_config_action kirkwood_generic_orion_bridge_intc_do_deact_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_HWEVT,
+            .hw_evt = LVL_HW_EVT_DODEACT,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_REACT,
+            .irq = 1,
+            .do_react = kirkwood_generic_common_do_deact_func,
+            .next = 0,
+        }
+    }
+};
+
+static level_irq_cfg kirkwood_generic_orion_bridge_intc_level_irq_cfg = {
+    .is_off = NULL,
+    .is_on = NULL,
+    .is_act = &wait_hw_evt_lvl_evt_act_cfg,
+    .is_deact = &wait_hw_evt_lvl_evt_deact_cfg,
+    .is_msk = &kirkwood_generic_orion_bridge_intc_is_msk_cfg,
+    .is_unmsk = &kirkwood_generic_orion_bridge_intc_is_unmsk_cfg,
+    .is_reset = &wait_hw_evt_lvl_evt_reset_cfg,
+    .is_init = &kirkwood_generic_orion_common_is_init_cfg,
+    .do_act = &kirkwood_generic_orion_bridge_intc_do_act_cfg,
+    .do_deact = &kirkwood_generic_orion_bridge_intc_do_deact_cfg,
+};
+
+static auto_config_action kirkwood_generic_orion_uart0_is_msk_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0x0,
+            .moff = 0x14,
+            .irq = 33,
+            .match_write_cnt = kirkwood_generic_common_is_msk_func,
+            .next = 0,
+        },
+    }
+};
+
+static auto_config_action kirkwood_generic_orion_uart0_is_unmsk_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x14,
+            .irq = 33,
+            .match_write_cnt = kirkwood_generic_common_is_unmsk_func,
+            .next = 0,
+        },
+    },
+};
+
+static auto_config_action kirkwood_generic_orion_uart0_do_act_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_HWEVT,
+            .hw_evt = LVL_HW_EVT_DOACT,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_REACT,
+            .irq = 33,
+            .midx = 0,
+            .moff = 0x10,
+            .do_react = kirkwood_generic_common_do_act_func,
+            .next = 0,
+        }
+    }
+};
+
+static auto_config_action kirkwood_generic_orion_uart0_do_deact_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_HWEVT,
+            .hw_evt = LVL_HW_EVT_DODEACT,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_REACT,
+            .irq = 33,
+            .midx = 0,
+            .moff = 0x10,
+            .do_react = kirkwood_generic_common_do_deact_func,
+            .next = 0,
+        }
+    }
+};
+
+static level_irq_cfg kirkwood_generic_orion_uart0_level_irq_cfg = {
+    .is_off = NULL,
+    .is_on = NULL,
+    .is_act = &wait_hw_evt_lvl_evt_act_cfg,
+    .is_deact = &wait_hw_evt_lvl_evt_deact_cfg,
+    .is_msk = &kirkwood_generic_orion_uart0_is_msk_cfg,
+    .is_unmsk = &kirkwood_generic_orion_uart0_is_unmsk_cfg,
+    .is_reset = &wait_hw_evt_lvl_evt_reset_cfg,
+    .is_init = &kirkwood_generic_orion_common_is_init_cfg,
+    .do_act = &kirkwood_generic_orion_uart0_do_act_cfg,
+    .do_deact = &kirkwood_generic_orion_uart0_do_deact_cfg,
+};
+
+static auto_config_action kirkwood_generic_orion_uart1_is_msk_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x14,
+            .irq = 34,
+            .match_write_cnt = kirkwood_generic_common_is_msk_func,
+            .next = 0,
+        },
+    }
+};
+
+static auto_config_action kirkwood_generic_orion_uart1_is_unmsk_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x14,
+            .irq = 34,
+            .match_write_cnt = kirkwood_generic_common_is_unmsk_func,
+            .next = 0,
+        },
+    },
+};
+
+static auto_config_action kirkwood_generic_orion_uart1_do_act_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_HWEVT,
+            .hw_evt = LVL_HW_EVT_DOACT,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_REACT,
+            .irq = 34,
+            .midx = 0,
+            .moff = 0x10,
+            .do_react = kirkwood_generic_common_do_act_func,
+            .next = 0,
+        }
+    }
+};
+
+static auto_config_action kirkwood_generic_orion_uart1_do_deact_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_HWEVT,
+            .hw_evt = LVL_HW_EVT_DODEACT,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_REACT,
+            .irq = 34,
+            .midx = 0,
+            .moff = 0x10,
+            .do_react = kirkwood_generic_common_do_deact_func,
+            .next = 0,
+        }
+    }
+};
+
+static level_irq_cfg kirkwood_generic_orion_uart1_intc_level_irq_cfg = {
+    .is_off = NULL,
+    .is_on = NULL,
+    .is_act = &wait_hw_evt_lvl_evt_act_cfg,
+    .is_deact = &wait_hw_evt_lvl_evt_deact_cfg,
+    .is_msk = &kirkwood_generic_orion_uart1_is_msk_cfg,
+    .is_unmsk = &kirkwood_generic_orion_uart1_is_unmsk_cfg,
+    .is_reset = &wait_hw_evt_lvl_evt_reset_cfg,
+    .is_init = &kirkwood_generic_orion_common_is_init_cfg,
+    .do_act = &kirkwood_generic_orion_uart1_do_act_cfg,
+    .do_deact = &kirkwood_generic_orion_uart1_do_deact_cfg,
+};
+
+static auto_config_one_irq kirkwood_generic_orion_irq_cfgs[KIRKWOOD_GENERIC_ORION_AUTOBOARD_IRQ_NUM] = {
+    [1] = {
+        .irq_type = STAT_MACH_IRQ_LEVEL,
+        .irq_stat_mach_cfg = &kirkwood_generic_orion_bridge_intc_level_irq_cfg,
+    },
+    [33] = {
+        .irq_type = STAT_MACH_IRQ_LEVEL,
+        .irq_stat_mach_cfg = &kirkwood_generic_orion_uart0_level_irq_cfg,
+    },
+    [34] = {
+        .irq_type = STAT_MACH_IRQ_LEVEL,
+        .irq_stat_mach_cfg = &kirkwood_generic_orion_uart1_intc_level_irq_cfg,
+    },
+};
+
+/*
+ * for kirkwood.generic bridge intc
+ * 
+ * we have 2 irqs connected to it in timer
+ */
+
+#define KIRKWOOD_GENERIC_BRIDGE_MMIO_AMOUNT 1
+#define KIRKWOOD_GENERIC_BRIDGE_MMIO1 0x8
+#define KIRKWOOD_GENERIC_BRIDGE_AUTOBOARD_IRQ_NUM 6
+static uint32_t kirkwood_generic_bridge_mmio_lens[KIRKWOOD_GENERIC_BRIDGE_MMIO_AMOUNT] = {
+   KIRKWOOD_GENERIC_BRIDGE_MMIO1, 
+};
+
+static uint8_t kirkwood_generic_bridge_common_is_init_func0(AUTOBOARD_INTCState *s, struct auto_config_unit *acu, auto_trifle *at)
+{
+    return (at->new_val == (uint32_t)(0x0));
+}
+
+static uint8_t kirkwood_generic_bridge_common_is_init_func1(AUTOBOARD_INTCState *s, struct auto_config_unit *acu, auto_trifle *at)
+{
+    return (at->new_val == (uint32_t)(0x0));
+}
+
+static auto_config_action kirkwood_generic_bridge_common_is_init_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x4,
+            .match_write_cnt = kirkwood_generic_bridge_common_is_init_func0,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x0,
+            .match_write_cnt = kirkwood_generic_bridge_common_is_init_func1,
+            .next = 0,
+        }
+    }
+};
+
+static uint8_t kirkwood_generic_bridge_common_is_ack_func(AUTOBOARD_INTCState *s, struct auto_config_unit *acu, auto_trifle *at)
+{
+    return (at->new_val == (~(uint32_t)(1 << (acu->irq % 32))));
+}
+
+static auto_config_action kirkwood_generic_bridge_timer1_is_ack_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x0,
+            .irq = 1,
+            .match_write_cnt = kirkwood_generic_bridge_common_is_ack_func,
+            .next = 0,
+        },
+    }
+};
+
+static auto_config_action kirkwood_generic_bridge_timer1_is_msk_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x4,
+            .irq = 1,
+            .match_write_cnt = kirkwood_generic_common_is_msk_func,
+            .next = 0,
+        },
+    }
+};
+
+static auto_config_action kirkwood_generic_bridge_timer1_is_unmsk_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x4,
+            .irq = 1,
+            .match_write_cnt = kirkwood_generic_common_is_unmsk_func,
+            .next = 0,
+        },
+    },
+};
+
+static auto_config_action kirkwood_generic_bridge_timer1_do_act_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_HWEVT,
+            .hw_evt = EDGE_HW_EVT_DOACT,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_REACT,
+            .irq = 1,
+            .do_react = kirkwood_generic_common_do_act_func,
+            .next = 0,
+        }
+    }
+};
+
+static auto_config_action kirkwood_generic_bridge_timer1_do_deact_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_HWEVT,
+            .hw_evt = EDGE_HW_EVT_DODEACT,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_REACT,
+            .irq = 1,
+            .do_react = kirkwood_generic_common_do_deact_func,
+            .next = 0,
+        }
+    }
+};
+
+static edge_irq_cfg kirkwood_generic_bridge_timer1_edge_irq_cfg = {
+    .is_off = NULL,
+    .is_on = NULL,
+    .is_pulse = &wait_hw_evt_edge_evt_pulse_cfg,
+    .is_ack = &kirkwood_generic_bridge_timer1_is_ack_cfg,
+    .is_msk = &kirkwood_generic_bridge_timer1_is_msk_cfg,
+    .is_unmsk = &kirkwood_generic_bridge_timer1_is_unmsk_cfg,
+    .is_reset = &wait_hw_evt_edge_evt_reset_cfg,
+    .is_init = &kirkwood_generic_bridge_common_is_init_cfg,
+    .do_act = &kirkwood_generic_bridge_timer1_do_act_cfg,
+    .do_deact = &kirkwood_generic_bridge_timer1_do_deact_cfg,
+};
+
+static auto_config_action kirkwood_generic_bridge_timer2_is_ack_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x0,
+            .irq = 2,
+            .match_write_cnt = kirkwood_generic_bridge_common_is_ack_func,
+            .next = 0,
+        },
+    }
+};
+
+static auto_config_action kirkwood_generic_bridge_timer2_is_msk_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x4,
+            .irq = 2,
+            .match_write_cnt = kirkwood_generic_common_is_msk_func,
+            .next = 0,
+        },
+    }
+};
+
+static auto_config_action kirkwood_generic_bridge_timer2_is_unmsk_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x4,
+            .irq = 2,
+            .match_write_cnt = kirkwood_generic_common_is_unmsk_func,
+            .next = 0,
+        },
+    },
+};
+
+static auto_config_action kirkwood_generic_bridge_timer2_do_act_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_HWEVT,
+            .hw_evt = EDGE_HW_EVT_DOACT,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_REACT,
+            .irq = 2,
+            .do_react = kirkwood_generic_common_do_act_func,
+            .next = 0,
+        }
+    }
+};
+
+static auto_config_action kirkwood_generic_bridge_timer2_do_deact_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_HWEVT,
+            .hw_evt = EDGE_HW_EVT_DODEACT,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_REACT,
+            .irq = 2,
+            .do_react = kirkwood_generic_common_do_deact_func,
+            .next = 0,
+        }
+    }
+};
+
+static edge_irq_cfg kirkwood_generic_bridge_timer2_intc_edge_irq_cfg = {
+    .is_off = NULL,
+    .is_on = NULL,
+    .is_pulse = &wait_hw_evt_edge_evt_pulse_cfg,
+    .is_ack = &kirkwood_generic_bridge_timer2_is_ack_cfg,
+    .is_msk = &kirkwood_generic_bridge_timer2_is_msk_cfg,
+    .is_unmsk = &kirkwood_generic_bridge_timer2_is_unmsk_cfg,
+    .is_reset = &wait_hw_evt_edge_evt_reset_cfg,
+    .is_init = &kirkwood_generic_bridge_common_is_init_cfg,
+    .do_act = &kirkwood_generic_bridge_timer2_do_act_cfg,
+    .do_deact = &kirkwood_generic_bridge_timer2_do_deact_cfg,
+};
+
+static auto_config_action kirkwood_generic_bridge_wdt_is_ack_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x0,
+            .irq = 3,
+            .match_write_cnt = kirkwood_generic_bridge_common_is_ack_func,
+            .next = 0,
+        },
+    }
+};
+
+static auto_config_action kirkwood_generic_bridge_wdt_is_msk_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x4,
+            .irq = 3,
+            .match_write_cnt = kirkwood_generic_common_is_msk_func,
+            .next = 0,
+        },
+    }
+};
+
+static auto_config_action kirkwood_generic_bridge_wdt_is_unmsk_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x4,
+            .irq = 3,
+            .match_write_cnt = kirkwood_generic_common_is_unmsk_func,
+            .next = 0,
+        },
+    },
+};
+
+static auto_config_action kirkwood_generic_bridge_wdt_do_act_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_HWEVT,
+            .hw_evt = EDGE_HW_EVT_DOACT,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_REACT,
+            .irq = 3,
+            .do_react = kirkwood_generic_common_do_act_func,
+            .next = 0,
+        }
+    }
+};
+
+static auto_config_action kirkwood_generic_bridge_wdt_do_deact_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_HWEVT,
+            .hw_evt = EDGE_HW_EVT_DODEACT,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_REACT,
+            .irq = 3,
+            .do_react = kirkwood_generic_common_do_deact_func,
+            .next = 0,
+        }
+    }
+};
+
+static edge_irq_cfg kirkwood_generic_bridge_wdt_intc_edge_irq_cfg = {
+    .is_off = NULL,
+    .is_on = NULL,
+    .is_pulse = &wait_hw_evt_edge_evt_pulse_cfg,
+    .is_ack = &kirkwood_generic_bridge_wdt_is_ack_cfg,
+    .is_msk = &kirkwood_generic_bridge_wdt_is_msk_cfg,
+    .is_unmsk = &kirkwood_generic_bridge_wdt_is_unmsk_cfg,
+    .is_reset = &wait_hw_evt_edge_evt_reset_cfg,
+    .is_init = &kirkwood_generic_bridge_common_is_init_cfg,
+    .do_act = &kirkwood_generic_bridge_wdt_do_act_cfg,
+    .do_deact = &kirkwood_generic_bridge_wdt_do_deact_cfg,
+};
+
+static auto_config_one_irq kirkwood_generic_bridge_irq_cfgs[KIRKWOOD_GENERIC_BRIDGE_AUTOBOARD_IRQ_NUM] = {
+    [1] = {
+        .irq_type = STAT_MACH_IRQ_EDGE,
+        .irq_stat_mach_cfg = &kirkwood_generic_bridge_timer1_edge_irq_cfg,
+    },
+    [2] = {
+        .irq_type = STAT_MACH_IRQ_EDGE,
+        .irq_stat_mach_cfg = &kirkwood_generic_bridge_timer2_intc_edge_irq_cfg,
+    },
+    [3] = {
+        //.irq_type = STAT_MACH_IRQ_EDGE,
+        .irq_type = STAT_MACH_IRQ_EMPTY,
+        .irq_stat_mach_cfg = &kirkwood_generic_bridge_wdt_intc_edge_irq_cfg,
+    },
+};
+
+/*
+ * for oxnas.generic
+ * 
+ * we have 1 intc, gic
+ * 
+ */
+
+#define OXNAS_GENERIC_GIC_MMIO_AMOUNT 2
+#define OXNAS_GENERIC_GIC_MMIO1 0x1000
+#define OXNAS_GENERIC_GIC_MMIO2 0x100
+#define OXNAS_GENERIC_GIC_AUTOBOARD_IRQ_NUM 64
+static uint32_t oxnas_generic_gic_mmio_lens[OXNAS_GENERIC_GIC_MMIO_AMOUNT] = {
+   OXNAS_GENERIC_GIC_MMIO1, 
+   OXNAS_GENERIC_GIC_MMIO2, 
+};
+
+static uint8_t oxnas_generic_gic_common_is_msk_func(AUTOBOARD_INTCState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    return at->new_val == ((uint32_t)(1 << (acu->irq % 32)));
+}
+
+static uint8_t oxnas_generic_gic_common_is_unmsk_func(AUTOBOARD_INTCState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    return at->new_val == ((uint32_t)(1 << (acu->irq % 32)));
+}
+
+static uint8_t oxnas_generic_gic_common_is_init_func0(AUTOBOARD_INTCState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    //printf("[+] match init func0 at->new_val:0x%x %d \n", at->new_val, (at->new_val == (uint32_t)0xffff0000));
+    return (at->new_val == (uint32_t)0xffff0000);
+}
+
+static uint8_t oxnas_generic_gic_common_is_init_func1(AUTOBOARD_INTCState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    //printf("[+] match init func1 at->new_val:0x%x result: %d \n", at->new_val, (at->new_val == (uint32_t)0x0000ffff));
+    return (at->new_val == (uint32_t)0x0000ffff);
+}
+
+static auto_config_action oxnas_generic_gic_common_is_init_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x180,
+            .match_write_cnt = oxnas_generic_gic_common_is_init_func0,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x100,
+            .match_write_cnt = oxnas_generic_gic_common_is_init_func1,
+            .next = 0,
+        },
+    }
+};
+
+static uint8_t oxnas_generic_gic_common_do_deact_func(AUTOBOARD_INTCState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    //printf("[+] uart de-act write before 0x%x, size %d, value 0x%x\n", acu->moff, 4, val);
+    //printf("[+] gic common do deact func\n");
+    s->aummios[acu->midx].write(&s->aummios[acu->midx], acu->moff, (uint32_t)1021);
+    //printf("[+] uart de-act write after 0x%x, size %d, value 0x%x\n", acu->moff, 4, val & (~((uint32_t) (1 << acu->irq))));
+    return 0;
+}
+
+static uint8_t oxnas_generic_gic_common_eoi_func(AUTOBOARD_INTCState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    //printf("[+] gic common eoi match irq %d at->new_val 0x%lx result:%d\n", acu->irq, at->new_val, (at->new_val == (uint32_t)acu->irq));
+    return (at->new_val == (uint32_t)acu->irq);
+}
+
+static auto_config_action oxnas_generic_gic_common_do_deact_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_HWEVT,
+            .hw_evt = EOI_LVL_HW_EVT_DODEACT,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_REACT,
+            .midx = 1,
+            .moff = 0xc,
+            .do_react = oxnas_generic_gic_common_do_deact_func,
+            .next = 0,
+        },
+    }
+};
+
+static auto_config_action oxnas_generic_gic_timer_is_msk_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x180 + (29 / 32) * 4,
+            .irq = 29,
+            .match_write_cnt = oxnas_generic_gic_common_is_msk_func,
+            .next = 0,
+        },
+    }
+};
+
+static auto_config_action oxnas_generic_gic_timer_is_unmsk_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x100 + (29 / 32) * 4,
+            .irq = 29,
+            .match_write_cnt = oxnas_generic_gic_common_is_unmsk_func,
+            .next = 0,
+        },
+    }
+};
+
+static auto_config_action oxnas_generic_gic_timer_is_eoi_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 1,
+            .moff = 0x10,
+            .irq = 29,
+            .match_write_cnt = oxnas_generic_gic_common_eoi_func,
+            .next = 0,
+        },
+    }
+};
+
+static uint8_t oxnas_generic_gic_timer_do_act_func1(AUTOBOARD_INTCState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    //printf("[+] uart de-act write before 0x%x, size %d, value 0x%x\n", acu->moff, 4, val);
+    //printf("[+] do timer do act func 1, write 29\n");
+    s->aummios[acu->midx].write(&s->aummios[acu->midx], acu->moff, (uint32_t)29);
+    //printf("[+] uart de-act write after 0x%x, size %d, value 0x%x\n", acu->moff, 4, val & (~((uint32_t) (1 << acu->irq))));
+    return 0;
+}
+
+static uint8_t oxnas_generic_gic_timer_do_act_func2(AUTOBOARD_INTCState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    //printf("[+] uart de-act write before 0x%x, size %d, value 0x%x\n", acu->moff, 4, val);
+    //printf("[+] do timer do act func 2, write 1021\n");
+    s->aummios[acu->midx].write(&s->aummios[acu->midx], acu->moff, (uint32_t)1021);
+    //printf("[+] uart de-act write after 0x%x, size %d, value 0x%x\n", acu->moff, 4, val & (~((uint32_t) (1 << acu->irq))));
+    return 0;
+}
+
+static auto_config_action oxnas_generic_gic_timer_do_act_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_HWEVT,
+            .hw_evt = EOI_LVL_HW_EVT_DOACT,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_WATCH_READ,
+            .midx = 1,
+            .moff = 0xc,
+            .irq = 29,
+            .next = 2,
+        },
+        {
+            .type = ACU_DO_REACT,
+            .midx = 1,
+            .moff = 0xc,
+            .do_react = oxnas_generic_gic_timer_do_act_func1,
+            .next = 3,
+        },
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 1,
+            .moff = 0x10,
+            .irq = 29,
+            .match_write_cnt = oxnas_generic_gic_common_eoi_func,
+            .next = 4,
+        },
+        {
+            .type = ACU_DO_WATCH_READ,
+            .midx = 1,
+            .moff = 0xc,
+            .irq = 29,
+            .next = 5,
+        },
+        {
+            .type = ACU_DO_REACT,
+            .midx = 1,
+            .moff = 0xc,
+            .do_react = oxnas_generic_gic_timer_do_act_func2,
+            .next = 0,
+        },
+    }
+};
+
+static eoi_lvl_irq_cfg oxnas_generic_gic_timer_eoi_lvl_irq_cfg = {
+    .is_off = NULL,
+    .is_on = NULL,
+    .is_act = &wait_hw_evt_eoi_lvl_evt_act_cfg,
+    .is_deact = &wait_hw_evt_eoi_lvl_evt_deact_cfg,
+    .is_eoi = &oxnas_generic_gic_timer_is_eoi_cfg,
+    .is_msk = &oxnas_generic_gic_timer_is_msk_cfg,
+    .is_unmsk = &oxnas_generic_gic_timer_is_unmsk_cfg,
+    .is_reset = &wait_hw_evt_eoi_lvl_evt_reset_cfg,
+    .is_init = &oxnas_generic_gic_common_is_init_cfg,
+    .do_act = &oxnas_generic_gic_timer_do_act_cfg,
+    .do_deact = &oxnas_generic_gic_common_do_deact_cfg,
+};
+
+static auto_config_action oxnas_generic_gic_uart_is_msk_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x180 + (55 / 32) * 4,
+            .irq = 55,
+            .match_write_cnt = oxnas_generic_gic_common_is_msk_func,
+            .next = 0,
+        },
+    }
+};
+
+static auto_config_action oxnas_generic_gic_uart_is_unmsk_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x100 + (55 / 32) * 4,
+            .irq = 55,
+            .match_write_cnt = oxnas_generic_gic_common_is_unmsk_func,
+            .next = 0,
+        },
+    }
+};
+
+static auto_config_action oxnas_generic_gic_uart_is_eoi_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 1,
+            .moff = 0x10,
+            .irq = 55,
+            .match_write_cnt = oxnas_generic_gic_common_eoi_func,
+            .next = 0,
+        },
+    }
+};
+
+static uint8_t oxnas_generic_gic_uart_do_act_func1(AUTOBOARD_INTCState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    //printf("[+] uart de-act write before 0x%x, size %d, value 0x%x\n", acu->moff, 4, val);
+    //printf("[+] do uart do act func 1, write 55\n");
+    s->aummios[acu->midx].write(&s->aummios[acu->midx], acu->moff, (uint32_t)55);
+    //printf("[+] uart de-act write after 0x%x, size %d, value 0x%x\n", acu->moff, 4, val & (~((uint32_t) (1 << acu->irq))));
+    return 0;
+}
+
+static uint8_t oxnas_generic_gic_uart_do_act_func2(AUTOBOARD_INTCState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    //printf("[+] uart de-act write before 0x%x, size %d, value 0x%x\n", acu->moff, 4, val);
+    //printf("[+] do uart do act func 2, write 1021\n");
+    s->aummios[acu->midx].write(&s->aummios[acu->midx], acu->moff, (uint32_t)1021);
+    //printf("[+] uart de-act write after 0x%x, size %d, value 0x%x\n", acu->moff, 4, val & (~((uint32_t) (1 << acu->irq))));
+    return 0;
+}
+
+static auto_config_action oxnas_generic_gic_uart_do_act_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_HWEVT,
+            .hw_evt = EOI_LVL_HW_EVT_DOACT,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_WATCH_READ,
+            .midx = 1,
+            .moff = 0xc,
+            .irq = 55,
+            .next = 2,
+        },
+        {
+            .type = ACU_DO_REACT,
+            .midx = 1,
+            .moff = 0xc,
+            .do_react = oxnas_generic_gic_uart_do_act_func1,
+            .next = 3,
+        },
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 1,
+            .moff = 0x10,
+            .irq = 55,
+            .match_write_cnt = oxnas_generic_gic_common_eoi_func,
+            .next = 4,
+        },
+        {
+            .type = ACU_DO_WATCH_READ,
+            .midx = 1,
+            .moff = 0xc,
+            .irq = 55,
+            .next = 5,
+        },
+        {
+            .type = ACU_DO_REACT,
+            .midx = 1,
+            .moff = 0xc,
+            .do_react = oxnas_generic_gic_uart_do_act_func2,
+            .next = 0,
+        },
+    }
+};
+
+static eoi_lvl_irq_cfg oxnas_generic_gic_uart_eoi_lvl_irq_cfg = {
+    .is_off = NULL,
+    .is_on = NULL,
+    .is_act = &wait_hw_evt_eoi_lvl_evt_act_cfg,
+    .is_deact = &wait_hw_evt_eoi_lvl_evt_deact_cfg,
+    .is_eoi = &oxnas_generic_gic_uart_is_eoi_cfg,
+    .is_msk = &oxnas_generic_gic_uart_is_msk_cfg,
+    .is_unmsk = &oxnas_generic_gic_uart_is_unmsk_cfg,
+    .is_reset = &wait_hw_evt_eoi_lvl_evt_reset_cfg,
+    .is_init = &oxnas_generic_gic_common_is_init_cfg,
+    .do_act = &oxnas_generic_gic_uart_do_act_cfg,
+    .do_deact = &oxnas_generic_gic_common_do_deact_cfg,
+};
+
+static auto_config_one_irq oxnas_generic_gic_irq_cfgs[OXNAS_GENERIC_GIC_AUTOBOARD_IRQ_NUM] = {
+    [29] = {
+        .irq_type = STAT_MACH_IRQ_EOI_LVL,
+        .irq_stat_mach_cfg = &oxnas_generic_gic_timer_eoi_lvl_irq_cfg,
+    },
+    [55] = {
+        .irq_type = STAT_MACH_IRQ_EOI_LVL,
+        .irq_stat_mach_cfg = &oxnas_generic_gic_uart_eoi_lvl_irq_cfg,
+    },
+};
+
+/*
+ * Config Panel
+ */
+
+static auto_one_intc_cfg all_irq_cfgs[AUTOBOARD_INTC_NUM] = {
+    [AUTOBOARD_INTC_RAMIPS_RT3883] = {
+        .irq_cfgs = ramips_rt3883_irq_cfgs,
+        .mm_lens = ramips_rt3883_mmio_lens,
+        .mm_amount = RAMIPS_RT3883_MMIO_AMOUNT,
+        .irq_num = RAMIPS_RT3883_AUTOBOARD_IRQ_NUM,
+    },
+    [AUTOBOARD_INTC_ATH79_GENERIC] = {
+        .irq_cfgs = ath79_generic_irq_cfgs,
+        .mm_lens = ath79_generic_mmio_lens,
+        .mm_amount = ATH79_GENERIC_MMIO_AMOUNT,
+        .irq_num = ATH79_GENERIC_AUTOBOARD_IRQ_NUM,
+    },
+    [AUTOBOARD_INTC_KIRKWOOD_GENERIC_ORION] = {
+        .irq_cfgs = kirkwood_generic_orion_irq_cfgs,
+        .mm_lens = kirkwood_generic_orion_mmio_lens,
+        .mm_amount = KIRKWOOD_GENERIC_ORION_MMIO_AMOUNT,
+        .irq_num = KIRKWOOD_GENERIC_ORION_AUTOBOARD_IRQ_NUM,
+    },
+    [AUTOBOARD_INTC_KIRKWOOD_GENERIC_BRIDGE] = {
+        .irq_cfgs = kirkwood_generic_bridge_irq_cfgs,
+        .mm_lens = kirkwood_generic_bridge_mmio_lens,
+        .mm_amount = KIRKWOOD_GENERIC_BRIDGE_MMIO_AMOUNT,
+        .irq_num = KIRKWOOD_GENERIC_BRIDGE_AUTOBOARD_IRQ_NUM,
+    },
+    [AUTOBOARD_INTC_OXNAS_GENERIC_GIC] = {
+        .irq_cfgs = oxnas_generic_gic_irq_cfgs,
+        .mm_lens = oxnas_generic_gic_mmio_lens,
+        .mm_amount = OXNAS_GENERIC_GIC_MMIO_AMOUNT,
+        .irq_num = OXNAS_GENERIC_GIC_AUTOBOARD_IRQ_NUM,
+    },
+};
+
+auto_one_intc_cfg *get_autoboard_intc_config(autoboard_intc_cfg_id id)
+{
+    assert(id > AUTOBOARD_INTC_INVALID && id < AUTOBOARD_INTC_NUM && "invalid autoboard intc cfg id");
+    return &all_irq_cfgs[id];
+}
diff -rNu qemu-2.3.0.orig/hw/intc/autoboard_intc_utils.c qemu-2.3.0/hw/intc/autoboard_intc_utils.c
--- qemu-2.3.0.orig/hw/intc/autoboard_intc_utils.c	1970-01-01 00:00:00.000000000 +0000
+++ qemu-2.3.0/hw/intc/autoboard_intc_utils.c	2020-08-10 11:19:38.276722113 +0000
@@ -0,0 +1,8 @@
+/*
+ * autoboard intc common utils implementation
+ */
+
+#include "qemu/osdep.h"
+
+#include "hw/intc/autoboard_intc_utils.h"
+#include "hw/misc/autoboard_utils.h"
diff -rNu qemu-2.3.0.orig/hw/intc/autoboard_level_irq.c qemu-2.3.0/hw/intc/autoboard_level_irq.c
--- qemu-2.3.0.orig/hw/intc/autoboard_level_irq.c	1970-01-01 00:00:00.000000000 +0000
+++ qemu-2.3.0/hw/intc/autoboard_level_irq.c	2020-08-10 11:19:38.276722113 +0000
@@ -0,0 +1,364 @@
+/*
+ * autoboard level irq stat machine implementation
+ */
+
+#include "qemu/osdep.h"
+
+#include "hw/intc/autoboard_intc_gen.h"
+#include "hw/intc/autoboard_level_irq.h"
+#include "hw/intc/autoboard_intc_utils.h"
+#include "hw/misc/autoboard_utils.h"
+
+static bool level_irq_is_acted(struct level_irq_stat_mach *m)
+{
+    //return (m->stat == LVL_STAT_ACT);
+    return (m->on == 1 && m->act == 1);
+}
+
+static int level_irq_dispatch(struct level_irq_stat_mach *m, auto_trifle *at)
+{
+    int triggered;
+
+    if (at->type == TRIFLE_HW_EVT) {
+        // do act & do deact are mutually exclusive
+        if (at->hw_evt == LVL_HW_EVT_DOACT) 
+            m->progs[LVL_HW_EVT_DODEACT] = 0;
+        if (at->hw_evt == LVL_HW_EVT_DODEACT) 
+            m->progs[LVL_HW_EVT_DOACT] = 0;
+    }
+
+    triggered = 0;
+
+    if (m->is_evt_off(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger off event for lvl irq %d\n", m->irq_idx);
+        m->handle_event(m, LVL_EVT_OFF);
+        triggered++;
+    }
+
+    if (m->is_evt_on(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger on event for lvl irq %d\n", m->irq_idx);
+        m->handle_event(m, LVL_EVT_ON);
+        triggered++;
+    }
+
+    if (m->is_evt_act(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger act event for lvl irq %d\n", m->irq_idx);
+        m->handle_event(m, LVL_EVT_ACT);
+        triggered++;
+    }
+
+    if (m->is_evt_deact(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger deact event for lvl irq %d\n", m->irq_idx);
+        m->handle_event(m, LVL_EVT_DEACT);
+        triggered++;
+    }
+
+    if (m->is_evt_msk(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger msk event for lvl irq %d\n", m->irq_idx);
+        m->handle_event(m, LVL_EVT_MSK);
+        triggered++;
+    }
+
+    if (m->is_evt_unmsk(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger unmsk event for lvl irq %d\n", m->irq_idx);
+        m->handle_event(m, LVL_EVT_UNMSK);
+        triggered++;
+    }
+
+    if (m->is_evt_reset(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger reset event for lvl irq %d\n", m->irq_idx);
+        m->handle_event(m, LVL_EVT_RESET);
+        triggered++;
+    }
+
+    if (m->is_evt_init(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger init event for lvl irq %d\n", m->irq_idx);
+        m->handle_event(m, LVL_EVT_INIT);
+        triggered++;
+    }
+
+    if (m->do_act(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger do act event for lvl irq %d\n", m->irq_idx);
+        triggered++;
+    }
+
+    if (m->do_deact(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger do deact event for lvl irq %d\n", m->irq_idx);
+        triggered++;
+    }
+
+    return triggered;
+}
+
+static void level_irq_handle_event(level_irq_stat_mach *m, level_irq_event lie)
+{
+    switch (lie)
+    {
+    case LVL_EVT_OFF:
+        m->stat = LVL_STAT_OFF;
+        m->on = 0;
+
+        break;
+    
+    case LVL_EVT_ON:
+        if (m->stat == LVL_STAT_OFF) {
+            if (m->msk)
+                m->stat = LVL_STAT_MSK;
+            else if (m->act) 
+                m->stat = LVL_STAT_ACT;
+            else
+                m->stat = LVL_STAT_IDLE;
+        }
+
+        m->on = 1;
+
+        break;
+    
+    case LVL_EVT_INIT:
+        if (m->stat == LVL_STAT_OFF) {
+            // when init, the irq is set as masked according to the kernel intc drivers' code we've seen
+            //m->stat = LVL_STAT_IDLE;
+            m->stat = LVL_STAT_MSK;
+            m->msk = 1;
+        }
+
+        m->on = 1;
+
+        break;
+
+    case LVL_EVT_ACT:
+        if (m->stat == LVL_STAT_IDLE)
+            m->stat = LVL_STAT_ACT;
+
+        m->act = 1;
+
+        break;
+    
+    case LVL_EVT_DEACT:
+        if (m->stat == LVL_STAT_ACT)
+            m->stat = LVL_STAT_IDLE;
+
+        m->act = 0;
+
+        break;
+    
+    case LVL_EVT_MSK:
+        if (m->stat == LVL_STAT_IDLE)
+            m->stat = LVL_STAT_MSK;
+        else if (m->stat == LVL_STAT_ACT)
+            m->stat = LVL_STAT_MSK;
+
+        m->msk = 1;
+
+        break;
+    
+    case LVL_EVT_UNMSK:
+        if (m->stat == LVL_STAT_MSK) {
+            if (m->act) 
+                m->stat = LVL_STAT_ACT;
+            else 
+                m->stat = LVL_STAT_IDLE;
+        }
+
+        m->msk = 0;
+
+        break;
+    
+    case LVL_EVT_RESET:
+        // TODO: here may need re-consider suitable reset logic
+        m->on = 1;
+        m->act = 0;
+        m->msk = 0;
+        m->stat = LVL_STAT_IDLE;
+
+        break;
+    
+    default:
+        break;
+    }
+
+    return;
+}
+
+static uint8_t level_irq_acu_func_flow(level_irq_stat_mach *m, auto_config_action *aca, auto_trifle *at, uint8_t evt)
+{
+    uint32_t stat;
+    uint32_t *prog;
+    auto_config_unit *acu;
+
+    prog = &m->progs[evt];
+
+    do {
+        // continue the execution from the last time
+        acu = &aca->acus[*prog];
+        stat = intc_try_process_at_on_acu(m->s, acu, at);
+        if (stat == ACU_ST_NEXT) {
+            *prog = acu->next;
+        }
+    } while (ACU_IS_DO_REACT(acu->type) && stat == ACU_ST_NEXT);
+
+    // if done, means trigger
+    if (stat == ACU_ST_DONE) {
+        *prog = 0;
+        return stat;
+    }
+
+    // matching...
+    if (stat == ACU_ST_NEXT) {
+        return stat;
+    }
+
+    // if mismatch, re-match from the start again
+    if (stat == ACU_ST_MISMATCH) {
+        // for lvl irq, we only have doact/dodeact now
+        // TODO: for lvl irq, maybe we shoule do cmp for specific hw evt 
+        //     when we have not start usage of hw evt
+        if ( (at->type == TRIFLE_HW_EVT && ACU_IS_DO_HW_WATCH(acu->type)) ||
+             ((at->type == TRIFLE_KER_READ || at->type == TRIFLE_KER_WRITE) && 
+                ACU_IS_DO_KER_WATCH(acu->type))
+           ) {
+            // if wait & come are same sources of event
+            //    then reset the prog & try match 1st thing again
+            if (*prog != 0) {
+                *prog = 0;
+                return level_irq_acu_func_flow(m, aca, at, evt);
+            }
+        }
+
+        return stat;
+    }
+
+    assert(false && "shouldn't come to here in level_irq_acu_func_flow");
+    return stat;
+}
+
+static uint8_t level_irq_is_evt_off(level_irq_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_off;
+    if (aca) 
+        return level_irq_acu_func_flow(m, aca, at, LVL_EVT_OFF);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t level_irq_is_evt_on(level_irq_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_on;
+    if (aca) 
+        return level_irq_acu_func_flow(m, aca, at, LVL_EVT_ON);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t level_irq_is_evt_act(level_irq_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_act;
+    if (aca) 
+        return level_irq_acu_func_flow(m, aca, at, LVL_EVT_ACT);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t level_irq_is_evt_deact(level_irq_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_deact;
+    if (aca) 
+        return level_irq_acu_func_flow(m, aca, at, LVL_EVT_DEACT);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t level_irq_is_evt_msk(level_irq_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_msk;
+    if (aca) 
+        return level_irq_acu_func_flow(m, aca, at, LVL_EVT_MSK);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t level_irq_is_evt_unmsk(level_irq_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_unmsk;
+    if (aca) 
+        return level_irq_acu_func_flow(m, aca, at, LVL_EVT_UNMSK);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t level_irq_is_evt_reset(level_irq_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_reset;
+    if (aca) 
+        return level_irq_acu_func_flow(m, aca, at, LVL_EVT_RESET);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t level_irq_is_evt_init(level_irq_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_init;
+    if (aca) 
+        return level_irq_acu_func_flow(m, aca, at, LVL_EVT_INIT);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t level_irq_do_act(level_irq_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->do_act;
+    if (aca) 
+        return level_irq_acu_func_flow(m, aca, at, LVL_HW_EVT_DOACT);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t level_irq_do_deact(level_irq_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->do_deact;
+    if (aca) 
+        return level_irq_acu_func_flow(m, aca, at, LVL_HW_EVT_DODEACT);
+
+    return ACU_ST_MISMATCH;
+}
+
+level_irq_stat_mach *init_level_irq_stat_mach(AUTOBOARD_INTCState *s, uint32_t cfg_idx)
+{
+    int i;
+    level_irq_stat_mach *m;
+
+    assert(s->cfg->irq_cfgs[cfg_idx].irq_type == STAT_MACH_IRQ_LEVEL);
+
+    m = calloc(1, sizeof(level_irq_stat_mach));
+
+    m->s = s;
+    m->irq_idx = cfg_idx;
+    m->cfg = (level_irq_cfg *)(s->cfg->irq_cfgs[cfg_idx].irq_stat_mach_cfg);
+
+    // at the very beginning, the intc is uninitialized & not activated & not masked
+    m->stat = LVL_STAT_OFF;
+    m->on = 0;
+    m->act = 0;
+    m->msk = 0;
+
+    for (i = 0; i < LVL_ALL_EVT_NUM; i++)
+        m->progs[i] = 0;
+
+    m->is_evt_off = level_irq_is_evt_off;
+    m->is_evt_on = level_irq_is_evt_on;
+    m->is_evt_act = level_irq_is_evt_act;
+    m->is_evt_deact = level_irq_is_evt_deact;
+    m->is_evt_msk = level_irq_is_evt_msk;
+    m->is_evt_unmsk = level_irq_is_evt_unmsk;
+    m->is_evt_reset = level_irq_is_evt_reset;
+    m->is_evt_init = level_irq_is_evt_init;
+
+    m->is_acted = level_irq_is_acted;
+    m->do_act = level_irq_do_act;
+    m->do_deact = level_irq_do_deact;
+
+    m->handle_event = level_irq_handle_event;
+    m->dispatch = level_irq_dispatch;
+
+    return m;
+}
diff -rNu qemu-2.3.0.orig/hw/mips/Makefile.objs qemu-2.3.0/hw/mips/Makefile.objs
--- qemu-2.3.0.orig/hw/mips/Makefile.objs	2015-04-27 14:08:24.000000000 +0000
+++ qemu-2.3.0/hw/mips/Makefile.objs	2020-08-10 11:22:55.702389989 +0000
@@ -1,4 +1,4 @@
 obj-y += mips_r4k.o mips_jazz.o mips_malta.o mips_mipssim.o
-obj-y += addr.o cputimer.o mips_int.o
+obj-y += addr.o cputimer.o mips_int.o boot.o
 obj-$(CONFIG_FULONG) += mips_fulong2e.o
 obj-y += gt64xxx_pci.o
diff -rNu qemu-2.3.0.orig/hw/mips/boot.c qemu-2.3.0/hw/mips/boot.c
--- qemu-2.3.0.orig/hw/mips/boot.c	1970-01-01 00:00:00.000000000 +0000
+++ qemu-2.3.0/hw/mips/boot.c	2020-08-10 12:45:59.016107709 +0000
@@ -0,0 +1,345 @@
+#include "qemu/osdep.h"
+#include "hw/hw.h"
+#include "qapi/error.h"
+#include "qemu/error-report.h"
+#include "qemu-common.h"
+#include "hw/mips/mips.h"
+#include <libfdt.h>
+#include "hw/mips/cpudevs.h"
+#include "sysemu/device_tree.h"
+#include "sysemu/sysemu.h"
+#include "qemu/option.h"
+#include "hw/loader.h"
+#include "elf.h"
+
+#define ENVP_ADDR           0xBFC00000 // 2(256)
+#define ENVP_NB_ENTRIES     16
+#define ENVP_ENTRY_SIZE     252
+#define BOOT_LOADER_ADDR    0xBFD00000 // 48 bytes
+
+static void do_cpu_reset(void *opaque)
+{
+    CommonResetData *reset_data = (CommonResetData *)opaque;
+    MIPSCPU *cpu = reset_data->cpu;
+
+    cpu_reset(CPU(cpu));
+    cpu->env.active_tc.PC = reset_data->vector;
+}
+
+static inline bool have_dtb(const struct mips_boot_info *info)
+{
+    return info->dtb_filename;
+}
+
+static void GCC_FMT_ATTR(3, 4) prom_set(uint32_t* prom_buf, int index,
+                                        const char *string, ...)
+{
+    va_list ap;
+    int32_t table_addr;
+
+    if (index >= ENVP_NB_ENTRIES)
+        return;
+
+    if (string == NULL) {
+        prom_buf[index] = 0;
+        return;
+    }
+
+    table_addr = sizeof(int32_t) * ENVP_NB_ENTRIES + index * ENVP_ENTRY_SIZE;
+    prom_buf[index] = tswap32(ENVP_ADDR + table_addr);
+
+    va_start(ap, string);
+    vsnprintf((char *)prom_buf + table_addr, ENVP_ENTRY_SIZE, string, ap);
+    va_end(ap);
+}
+
+/* ROM and pseudo bootloader
+ *
+ * The following code implements a very very simple bootloader. It first
+ * loads the registers a0 to a3 to the values expected by the OS, and
+ * then jump at the kernel address.
+ *
+ * The bootloader should pass the locations of the kernel arguments and
+ * environment variables tables. Those tables contain the 32-bit address
+ * of NULL terminated strings. The environment variables table should be
+ * terminated by a NULL address.
+ *
+ * For a simpler implementation, the number of kernel arguments is fixed
+ * to two (the name of the kernel and the command line), and the two
+ * tables are actually the same one.
+ *
+ * The registers a0 to a3 should contain the following values:
+ *     a0 - number of kernel arguments
+ *     a1 - 32-bit address of the kernel arguments table
+ *     a2 - 32-bit address of the environment variables table
+ *     a3 - RAM size in bytes
+ *
+ */
+
+static int64_t mips_setup_direct_kernel_boot(MIPSCPU *cpu, struct mips_boot_info *info)
+{
+    hwaddr ep, loadaddr;
+    uint64_t kernel_entry, kernel_low, kernel_high, image_high;
+    long kernel_size, prom_size;
+    uint32_t *prom_buf, *boot_loader_buf;
+    int big_endian, prom_index = 0;
+    int argc = 0;
+
+#ifdef TARGET_WORDS_BIGENDIAN
+    big_endian = 1;
+#else
+    big_endian = 0;
+#endif
+
+    /* kernel is loaded from 0 max to 0x0FFFFFFF(256M)
+     * initrd is loaded after the kernel max to 0x0FFFFFFF(256M)
+     *
+     * ram and flash are allocated in machine_init not here
+     */
+
+    /* load kernel */
+    kernel_size = load_elf(info->kernel_filename, cpu_mips_kseg0_to_phys, NULL,
+                           &kernel_entry, &kernel_low, &kernel_high, big_endian, EM_MIPS, 1);
+    if (kernel_size < 0) {
+        int is_linux;
+        kernel_size = load_uimage(info->kernel_filename, &ep, &loadaddr, &is_linux,
+                                  cpu_mips_kseg0_to_phys, NULL);
+        kernel_entry = (uint64_t)ep;
+        kernel_low = cpu_mips_kseg0_to_phys(NULL, loadaddr);
+        kernel_high = cpu_mips_kseg0_to_phys(NULL, loadaddr) + (uint64_t)kernel_size;
+        if (kernel_size < 0) {
+            error_report("could not load kernel '%s'", info->kernel_filename);
+            exit(1);
+        }
+    }
+    /* we just leverage INITRD_PAGE_MASK, just for convenience */
+    image_high = (kernel_high + ~INITRD_PAGE_MASK) & INITRD_PAGE_MASK;
+
+    /* load initrd */
+    if (info->initrd_filename) {
+        info->initrd_size = get_image_size(info->initrd_filename);
+        if (info->initrd_size > 0) {
+            // suppose the kernel size (including bss )is less than 0x01000000(16M)
+            info->initrd_start = (kernel_high + ~INITRD_PAGE_MASK) & INITRD_PAGE_MASK;
+            if (info->initrd_start + info->initrd_size > info->ram_size) {
+                error_report("memory too small for initial ram disk '%s'",
+                             info->initrd_filename);
+                exit(1);
+            }
+            info->initrd_size = load_image_targphys(info->initrd_filename, info->initrd_start,
+                                              info->ram_size - info->initrd_start);
+            image_high = (info->initrd_start + info->initrd_size + ~INITRD_PAGE_MASK) & INITRD_PAGE_MASK;
+        } else {
+            error_report("could not load initial ram disk '%s'",
+                         info->initrd_filename);
+            exit(1);
+        }
+    }
+
+    /* update fdt */
+    if (info->dtb_filename) {
+        /* generally, the device tree blob is after the kernel image or the initrd */
+        info->dtb_start = image_high;
+        info->dtb_limit = info->ram_size;
+        if (info->dtb_offset) {
+            info->dtb_start = kernel_low + info->dtb_offset;
+        }
+    }
+
+    /* store cmdline  */
+    prom_size = ENVP_NB_ENTRIES * (sizeof(int32_t) + ENVP_ENTRY_SIZE);
+    prom_buf = g_malloc(prom_size);
+
+    if (info->initrd_size > 0) {
+        prom_set(prom_buf, prom_index++, "rd_start=0x%" PRIx64 " rd_size=%" PRId64 " %s",
+                 cpu_mips_phys_to_kseg0(NULL, info->initrd_start), info->initrd_size,
+                 info->kernel_cmdline);
+        prom_set(prom_buf, prom_index++, "initrd_start=0x%" PRIx32, (unsigned int)cpu_mips_phys_to_kseg0(NULL, info->initrd_start));
+        prom_set(prom_buf, prom_index++, "initrd_size=%" PRId32, (int)info->initrd_size);
+        argc += 3;
+    } else {
+        prom_set(prom_buf, prom_index++, "%s", info->kernel_cmdline);
+        argc += 1;
+    }
+    prom_set(prom_buf, prom_index, NULL);
+
+    rom_add_blob_fixed("prom", prom_buf, prom_size, cpu_mips_kseg0_to_phys(NULL, ENVP_ADDR));
+    g_free(prom_buf);
+
+    /* small bootloader */
+    boot_loader_buf = g_malloc(0x30);
+    boot_loader_buf[0x0] = tswap32(0x3c040000);                                      /* lui a0, 0 */
+    boot_loader_buf[0x1] = tswap32(0x34840000 | argc);                               /* ori a0, a0, ARGC */
+    boot_loader_buf[0x2] = tswap32(0x3c050000 | ((ENVP_ADDR >> 16) & 0xffff));       /* lui a1, high(ENVP_ADDR) */
+    boot_loader_buf[0x3] = tswap32(0x34a50000 | (ENVP_ADDR & 0xffff));               /* ori a1, a0, low(ENVP_ADDR) */
+    boot_loader_buf[0x4] = tswap32(0x3c060000 | ((ENVP_ADDR >> 16) & 0xffff));       /* lui a2, high(ENVP_ADDR) */
+    boot_loader_buf[0x5] = tswap32(0x34c60000 | (ENVP_ADDR & 0xffff));               /* ori a2, a2, low(ENVP_ADDR) */
+    boot_loader_buf[0x6] = tswap32(0x3c070000 | (info->ram_size >> 16));             /* lui a3, high(env->ram_size) */
+    boot_loader_buf[0x7] = tswap32(0x34e70000 | (info->ram_size & 0xffff));          /* ori a3, a3, low(env->ram_size) */
+    boot_loader_buf[0x8] = tswap32(0x3c1f0000 | ((kernel_entry >> 16) & 0xffff));    /* lui ra, high(kernel_addr) */;
+    boot_loader_buf[0x9] = tswap32(0x37ff0000 | (kernel_entry & 0xffff));            /* ori ra, ra, low(kernel_addr) */
+    boot_loader_buf[0xa] = tswap32(0x03e00008);                                      /* jr ra */
+    boot_loader_buf[0xb] = tswap32(0x00000000);                                      /* nop */
+
+    rom_add_blob_fixed("bootloader", boot_loader_buf, 0x30, cpu_mips_kseg0_to_phys(NULL, BOOT_LOADER_ADDR));
+    g_free(boot_loader_buf);
+
+    return (int64_t)BOOT_LOADER_ADDR;
+}
+
+QemuOptsList enhance_dtb_opts = {
+    .name = "dtb",
+    .implied_opt_name = "path",
+    .merge_lists = true,
+    .head = QTAILQ_HEAD_INITIALIZER(enhance_dtb_opts.head),
+    .desc = {
+        {
+            .name = "path",
+            .type = QEMU_OPT_STRING,
+            .help = "file path of device tree blob",
+        }, {
+            .name = "offset",
+            .type = QEMU_OPT_NUMBER,
+            .help = "offset to which we put the device tree blob relative to the start of the kernel image",
+        },
+        { /* End of list */ }
+    },
+};
+
+struct rom_hotfix_blob kernel_builtin_fdt;
+
+int mips_load_dtb(hwaddr addr, struct mips_boot_info *binfo,
+                  hwaddr addr_limit, AddressSpace *as)
+{
+    void *fdt = NULL;
+    int size, dt_size, rc = 0;
+    uint32_t acells, scells;
+
+    if (binfo->dtb_filename) {
+        char *filename;
+        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, binfo->dtb_filename);
+        if (!filename) {
+            fprintf(stderr, "Couldn't open dtb file %s\n", binfo->dtb_filename);
+            goto fail;
+        }
+        // the size returned by load_device_tree is too large to override instructions
+        dt_size = (get_image_size(filename) + ~DTB_PAGE_MASK) & DTB_PAGE_MASK;
+        fdt = load_device_tree(filename, &size);
+        if (!fdt) {
+            fprintf(stderr, "Couldn't open dtb file %s\n", filename);
+            g_free(filename);
+            goto fail;
+        }
+        g_free(filename);
+    } else {
+        return 0;
+    }
+
+    if (addr_limit > addr && size > (addr_limit - addr)) {
+        /* Installing the device tree blob at addr would exceed addr_limit.
+         * Whether this constitutes failure is up to the caller to decide,
+         * so just return 0 as size, i.e., no error.
+         */
+        g_free(fdt);
+        return 0;
+    }
+
+    acells = qemu_fdt_getprop_cell(fdt, "/", "#address-cells");
+    scells = qemu_fdt_getprop_cell(fdt, "/", "#size-cells");
+    if (acells == 0 || scells == 0) {
+        fprintf(stderr, "dtb file invalid (#address-cells or #size-cells 0)\n");
+        goto fail;
+    }
+
+    if (scells < 2 && binfo->ram_size >= (1ULL << 32)) {
+        /* This is user error so deserves a friendlier error message
+         * than the failure of setprop_sized_cells would provide
+         */
+        fprintf(stderr, "qemu: dtb file not compatible with "
+                "RAM size > 4GB\n");
+         goto fail;
+    }
+
+    rc = fdt_path_offset(fdt, "/chosen");
+    if (rc < 0) {
+        qemu_fdt_add_subnode(fdt, "/chosen");
+    }
+
+    if (binfo->kernel_cmdline && *binfo->kernel_cmdline) {
+        rc = qemu_fdt_setprop_string(fdt, "/chosen", "bootargs",
+                                     binfo->kernel_cmdline);
+        if (rc < 0) {
+            fprintf(stderr, "couldn't set /chosen/bootargs\n");
+            goto fail;
+        }
+    }
+    if (binfo->initrd_size) {
+        rc = qemu_fdt_setprop_cell(fdt, "/chosen", "linux,initrd-start",
+                                   binfo->initrd_start);
+        if (rc < 0) {
+            fprintf(stderr, "couldn't set /chosen/linux,initrd-start\n");
+            goto fail;
+        }
+
+        rc = qemu_fdt_setprop_cell(fdt, "/chosen", "linux,initrd-end",
+                                   binfo->initrd_start + binfo->initrd_size);
+        if (rc < 0) {
+            fprintf(stderr, "couldn't set /chosen/linux,initrd-end\n");
+            goto fail;
+        }
+    }
+
+    qemu_fdt_dumpdtb(fdt, size);
+
+    /* Put the DTB into the memory map as a ROM image: this will ensure
+     * the DTB is copied again upon reset, even if addr points into RAM.
+     */
+    if (binfo->dtb_offset) {
+        kernel_builtin_fdt.data = g_malloc(size);
+        memcpy(kernel_builtin_fdt.data, fdt, size);
+        kernel_builtin_fdt.size = dt_size;
+        kernel_builtin_fdt.offset = binfo->dtb_offset;
+        kernel_builtin_fdt.addr = binfo->dtb_start;
+        qemu_register_reset(rom_hotfix_reset, &kernel_builtin_fdt);
+    } else {
+        rom_add_blob_fixed("dtb", fdt, size, addr);
+    }
+
+    g_free(fdt);
+    return size;
+
+fail:
+    g_free(fdt);
+    return -1;
+}
+
+void mips_load_kernel(MIPSCPU *cpu, struct mips_boot_info *info)
+{
+    CommonResetData *reset_data;
+    int64_t entry;
+    QemuOpts *dtb_opts;
+
+    dtb_opts = qemu_opts_parse(&enhance_dtb_opts,
+                          qemu_opt_get(qemu_get_machine_opts(), "dtb"),
+                          true);
+
+    info->dtb_filename = qemu_opt_get(dtb_opts, "path");
+    info->dtb_offset = qemu_opt_get_number(dtb_opts, "offset", 0);
+
+    if (!info->kernel_filename) {
+        error_report("could not boot without kernel");
+        exit(1);
+    }
+    entry = mips_setup_direct_kernel_boot(cpu, info);
+    if (have_dtb(info)) {
+        if (mips_load_dtb(info->dtb_start, info, info->dtb_limit, NULL) < 0) {
+            exit(1);
+        }
+    }
+
+    reset_data = g_malloc0(sizeof(CommonResetData));
+    reset_data->cpu = cpu;
+    reset_data->vector = entry;
+
+    qemu_register_reset(do_cpu_reset, reset_data);
+}
diff -rNu qemu-2.3.0.orig/hw/timer/Makefile.objs qemu-2.3.0/hw/timer/Makefile.objs
--- qemu-2.3.0.orig/hw/timer/Makefile.objs	2015-04-27 14:08:24.000000000 +0000
+++ qemu-2.3.0/hw/timer/Makefile.objs	2020-08-10 11:28:21.557262757 +0000
@@ -33,3 +33,4 @@
 obj-$(CONFIG_ALLWINNER_A10_PIT) += allwinner-a10-pit.o
 
 common-obj-$(CONFIG_STM32F2XX_TIMER) += stm32f2xx_timer.o
+obj-$(CONFIG_AUTOBOARD) += autoboard_timer_gen.o autoboard_clkevt.o autoboard_clksrc.o autoboard_timer.o autoboard_timer_utils.o
diff -rNu qemu-2.3.0.orig/hw/timer/autoboard_clkevt.c qemu-2.3.0/hw/timer/autoboard_clkevt.c
--- qemu-2.3.0.orig/hw/timer/autoboard_clkevt.c	1970-01-01 00:00:00.000000000 +0000
+++ qemu-2.3.0/hw/timer/autoboard_clkevt.c	2020-08-10 11:22:20.005469617 +0000
@@ -0,0 +1,356 @@
+/*
+ * autoboard timer clock event device stat machine implementation
+ */
+
+#include "qemu/osdep.h"
+
+#include "hw/timer/autoboard_timer_gen.h"
+#include "hw/timer/autoboard_clkevt.h"
+#include "hw/timer/autoboard_timer_utils.h"
+#include "hw/misc/autoboard_utils.h"
+
+#define IMPOSSIBLE 0xffffffff
+
+static void clkevt_past_one_cycle(struct clkevt_stat_mach *m)
+{
+    uint32_t passes = m->step * m->delta;
+    if (m->repeat || m->enable) {
+        //printf("[+] %s load value is %u\n", m->name, m->load);
+        if (m->load > passes) {
+            m->load -= passes;
+        } else {
+            // act irq
+            //printf("[+] %s act the irq\n", m->name);
+            m->act_irq(m->s);
+            m->load = m->countdown - (passes % m->load);
+            m->enable = false;
+        }
+    }
+}
+
+static int clkevt_dispatch(struct clkevt_stat_mach *m, auto_trifle *at)
+{
+    int triggered;
+
+    triggered = 0;
+
+    if (at->type == TRIFLE_HW_EVT && at->hw_evt == CLKEVT_HW_EVT_ONE_CYCLE) {
+        //printf("[+] one cycle past for clock event %s\n", m->name);
+        m->step = at->evt_arg;
+        m->handle_event(m, CLKEVT_HW_EVT_ONE_CYCLE);
+        return 0;
+    }
+
+    if (m->is_evt_off(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger off event for clock event %s\n", m->name);
+        m->handle_event(m, CLKEVT_EVT_OFF);
+        triggered++;
+    }
+
+    if (m->is_evt_on(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger on event for clock event %s\n", m->name);
+        m->handle_event(m, CLKEVT_EVT_ON);
+        triggered++;
+    }
+
+    if (m->is_evt_init(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger init event for clock event %s\n", m->name);
+        m->handle_event(m, CLKEVT_EVT_INIT);
+        triggered++;
+    }
+
+    if (m->is_evt_reset(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger reset event for clock event %s\n", m->name);
+        m->handle_event(m, CLKEVT_EVT_RESET);
+        triggered++;
+    }
+
+    if (m->is_evt_set_unused(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger set unused event for clock event %s\n", m->name);
+        m->handle_event(m, CLKEVT_EVT_SET_UNUSED);
+        triggered++;
+    }
+
+    if (m->is_evt_set_perio(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger set perio event for clock event %s\n", m->name);
+        m->handle_event(m, CLKEVT_EVT_SET_PERIO);
+        triggered++;
+    }
+
+    if (m->is_evt_set_oneshot(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger set oneshot event for clock event %s\n", m->name);
+        m->handle_event(m, CLKEVT_EVT_SET_ONESHOT);
+        triggered++;
+    }
+
+    if (m->is_evt_ack(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger set ack event for clock event %s\n", m->name);
+        m->handle_event(m, CLKEVT_EVT_ACK);
+        triggered++;
+    }
+
+    if (m->is_evt_oneshot_set_next(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger oneshot set next event for clock event %s\n", m->name);
+        m->handle_event(m, CLKEVT_EVT_ONESHOT_SET_NEXT);
+        triggered++;
+    }
+
+    return triggered;
+}
+
+static void clkevt_handle_event(clkevt_stat_mach *m, clkevt_event ce)
+{
+    switch (ce)
+    {
+    case CLKEVT_EVT_OFF:
+    case CLKEVT_EVT_RESET:
+        m->stat = CLKEVT_STAT_OFF;
+        m->on = false;
+        m->enable = false;
+        m->repeat = false;
+        break;
+    
+    case CLKEVT_EVT_ON:
+    case CLKEVT_EVT_INIT:
+        if (m->stat == CLKEVT_STAT_OFF)
+            m->stat = CLKEVT_STAT_UNUSED;
+
+        m->on = true;
+        m->enable = false;
+        m->repeat = false;
+        break;
+    
+    case CLKEVT_EVT_SET_UNUSED:
+        if (m->on) {
+            m->stat = CLKEVT_STAT_UNUSED;
+            m->enable = false;
+            m->repeat = false;
+        }
+        break;
+    
+    case CLKEVT_EVT_SET_PERIO:
+        if (m->on) {
+            m->stat = CLKEVT_STAT_PERIODIC;
+            m->enable = true;
+            m->repeat = true;
+        }
+        break;
+    
+    case CLKEVT_EVT_SET_ONESHOT:
+        if (m->on) {
+            m->stat = CLKEVT_STAT_ONESHOT;
+            m->enable = false;
+            m->repeat = false;
+        }
+        break;
+    
+    case CLKEVT_EVT_ACK:
+        if (m->stat == CLKEVT_STAT_PERIODIC || m->stat == CLKEVT_STAT_ONESHOT) {
+            //printf("[+] %s deact the irq\n", m->name);
+            m->deact_irq(m->s);
+        }
+        break;
+    
+    case CLKEVT_EVT_ONESHOT_SET_NEXT:
+        // TODO: now we just remove this check , as in kirkwood case
+        //       the ONESHOT stat is the same as UNUSED
+        //       maybe design a variable stat model next time
+        //if (m->stat == CLKEVT_STAT_ONESHOT) {
+            //assert(false && "we think now has no case really working on oneshot mode now");
+            m->enable = true;
+        //}
+        break;
+    
+    case CLKEVT_HW_EVT_ONE_CYCLE:
+        m->pass_one_cycle(m);
+        break;
+
+    default:
+        break;
+    }
+
+    return;
+}
+
+static uint8_t clkevt_acu_func_flow(clkevt_stat_mach *m, auto_config_action *aca, auto_trifle *at, uint8_t evt)
+{
+    uint32_t stat;
+    uint32_t *prog;
+    auto_config_unit *acu;
+
+    prog = &m->progs[evt];
+
+    do {
+        // continue the execution from the last time
+        acu = &aca->acus[*prog];
+        stat = timer_try_process_at_on_acu(m->s, acu, at);
+        if (stat == ACU_ST_NEXT) {
+            *prog = acu->next;
+        }
+    } while (ACU_IS_DO_REACT(acu->type) && stat == ACU_ST_NEXT);
+
+    // if done, means trigger
+    if (stat == ACU_ST_DONE) {
+        *prog = 0;
+        return stat;
+    }
+
+    // matching...
+    if (stat == ACU_ST_NEXT) {
+        return stat;
+    }
+
+    // if mismatch, re-match from the start again
+    if (stat == ACU_ST_MISMATCH) {
+        // for lvl irq, we only have doact/dodeact now
+        // TODO: for lvl irq, maybe we shoule do cmp for specific hw evt 
+        //     when we have not start usage of hw evt
+        if ( (at->type == TRIFLE_HW_EVT && ACU_IS_DO_HW_WATCH(acu->type)) ||
+             ((at->type == TRIFLE_KER_READ || at->type == TRIFLE_KER_WRITE) && 
+                ACU_IS_DO_KER_WATCH(acu->type))
+           ) {
+            // if wait & come are same sources of event
+            //    then reset the prog & try match 1st thing again
+            if (*prog != 0) {
+                *prog = 0;
+                return clkevt_acu_func_flow(m, aca, at, evt);
+            }
+        }
+
+        return stat;
+    }
+
+    assert(false && "shouldn't come to here in clkevt_acu_func_flow");
+    return stat;
+}
+
+static uint8_t clkevt_is_evt_off(clkevt_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_off;
+    if (aca) 
+        return clkevt_acu_func_flow(m, aca, at, CLKEVT_EVT_OFF);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t clkevt_is_evt_on(clkevt_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_on;
+    if (aca) 
+        return clkevt_acu_func_flow(m, aca, at, CLKEVT_EVT_ON);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t clkevt_is_evt_init(clkevt_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_init;
+    if (aca) 
+        return clkevt_acu_func_flow(m, aca, at, CLKEVT_EVT_INIT);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t clkevt_is_evt_reset(clkevt_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_reset;
+    if (aca) 
+        return clkevt_acu_func_flow(m, aca, at, CLKEVT_EVT_RESET);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t clkevt_is_evt_set_unused(clkevt_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_set_unused;
+    if (aca) 
+        return clkevt_acu_func_flow(m, aca, at, CLKEVT_EVT_SET_UNUSED);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t clkevt_is_evt_set_perio(clkevt_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_set_perio;
+    if (aca) 
+        return clkevt_acu_func_flow(m, aca, at, CLKEVT_EVT_SET_PERIO);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t clkevt_is_evt_set_oneshot(clkevt_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_set_oneshot;
+    if (aca) 
+        return clkevt_acu_func_flow(m, aca, at, CLKEVT_EVT_SET_ONESHOT);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t clkevt_is_evt_ack(clkevt_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_ack;
+    if (aca) 
+        return clkevt_acu_func_flow(m, aca, at, CLKEVT_EVT_ACK);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t clkevt_is_evt_oneshot_set_next(clkevt_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_oneshot_set_next;
+    if (aca) 
+        return clkevt_acu_func_flow(m, aca, at, CLKEVT_EVT_ONESHOT_SET_NEXT);
+
+    return ACU_ST_MISMATCH;
+}
+
+clkevt_stat_mach *init_clkevt_stat_mach(AUTOBOARD_TIMERState *s, uint32_t cfg_idx)
+{
+    int i;
+    clkevt_stat_mach *m;
+
+    assert(s->cfg->timer_cfgs[cfg_idx].timer_type == STAT_MACH_CLKDEV_EVENT);
+    assert(s->act_irq != NULL);
+    assert(s->deact_irq != NULL);
+
+    m = calloc(1, sizeof(clkevt_stat_mach));
+
+    m->s = s;
+    m->name = s->name;
+    m->clk_idx = cfg_idx;
+    m->cfg = (clkevt_cfg *)(s->cfg->timer_cfgs[cfg_idx].timer_stat_mach_cfg);
+
+    m->on = false;
+    m->enable = false;
+    m->repeat = false;
+
+    m->delta = s->ns_per_cycle / s->cfg->ns_per_cycle;
+    m->countdown = IMPOSSIBLE;
+    m->load = m->countdown;
+
+    // at the very beginning, the timer is off
+    m->stat = CLKEVT_STAT_OFF;
+
+    for (i = 0; i < CLKEVT_ALL_EVT_NUM; i++)
+        m->progs[i] = 0;
+
+    m->is_evt_off = clkevt_is_evt_off;
+    m->is_evt_on = clkevt_is_evt_on;
+    m->is_evt_init = clkevt_is_evt_init;
+    m->is_evt_reset = clkevt_is_evt_reset;
+    m->is_evt_set_unused = clkevt_is_evt_set_unused;
+    m->is_evt_set_perio = clkevt_is_evt_set_perio;
+    m->is_evt_set_oneshot = clkevt_is_evt_set_oneshot;
+    m->is_evt_ack = clkevt_is_evt_ack;
+    m->is_evt_oneshot_set_next = clkevt_is_evt_oneshot_set_next;
+
+    m->act_irq = s->act_irq;
+    m->deact_irq = s->deact_irq;
+
+    m->pass_one_cycle = clkevt_past_one_cycle;
+    m->handle_event = clkevt_handle_event;
+    m->dispatch = clkevt_dispatch;
+
+    return m;
+}
diff -rNu qemu-2.3.0.orig/hw/timer/autoboard_clksrc.c qemu-2.3.0/hw/timer/autoboard_clksrc.c
--- qemu-2.3.0.orig/hw/timer/autoboard_clksrc.c	1970-01-01 00:00:00.000000000 +0000
+++ qemu-2.3.0/hw/timer/autoboard_clksrc.c	2020-08-10 11:22:20.005469617 +0000
@@ -0,0 +1,231 @@
+/*
+ * autoboard timer clock source device stat machine implementation
+ */
+
+#include "qemu/osdep.h"
+
+#include "hw/timer/autoboard_timer_gen.h"
+#include "hw/timer/autoboard_clksrc.h"
+#include "hw/timer/autoboard_timer_utils.h"
+#include "hw/misc/autoboard_utils.h"
+
+static void clksrc_past_one_cycle(struct clksrc_stat_mach *m)
+{
+    if (m->increment) 
+        m->cycles += m->delta;
+    else 
+        m->cycles -= m->delta;
+}
+
+static int clksrc_dispatch(struct clksrc_stat_mach *m, auto_trifle *at)
+{
+    int triggered;
+
+    triggered = 0;
+
+    if (at->type == TRIFLE_HW_EVT && at->hw_evt == CLKSRC_HW_EVT_ONE_CYCLE) {
+        //printf("[+] one cycle past for clock source %s\n", m->name);
+        m->handle_event(m, CLKSRC_HW_EVT_ONE_CYCLE);
+        return 0;
+    }
+
+    if (m->is_evt_off(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger off event for clock source %s\n", m->name);
+        m->handle_event(m, CLKSRC_EVT_OFF);
+        triggered++;
+    }
+
+    if (m->is_evt_on(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger on event for clock source %s\n", m->name);
+        m->handle_event(m, CLKSRC_EVT_ON);
+        triggered++;
+    }
+
+    if (m->is_evt_init(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger init event for clock source %s\n", m->name);
+        m->handle_event(m, CLKSRC_EVT_INIT);
+        triggered++;
+    }
+
+    if (m->is_evt_reset(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger reset event for clock source %s\n", m->name);
+        m->handle_event(m, CLKSRC_EVT_RESET);
+        triggered++;
+    }
+
+    if (m->is_kernel_read(m, at) == ACU_ST_DONE) {
+        //printf("[+] trigger kernel read event for clock source %s\n", m->name);
+        m->handle_event(m, CLKSRC_EVT_KERNEL_READ);
+        triggered++;
+    }
+
+    return triggered;
+}
+
+static void clksrc_handle_event(clksrc_stat_mach *m, clksrc_event ce)
+{
+    switch (ce)
+    {
+    case CLKSRC_EVT_OFF:
+    case CLKSRC_EVT_RESET:
+        m->stat = CLKSRC_STAT_OFF;
+        m->on = false;
+        break;
+    
+    case CLKSRC_EVT_ON:
+    case CLKSRC_EVT_INIT:
+        if (m->stat == CLKSRC_STAT_OFF)
+            m->stat = CLKSRC_STAT_RUN;
+
+        m->on = true;
+        break;
+    
+    case CLKSRC_HW_EVT_ONE_CYCLE:
+        if (m->stat == CLKSRC_STAT_RUN) {
+            m->pass_one_cycle(m);
+        }
+        break;
+
+    default:
+        break;
+    }
+
+    return;
+}
+
+static uint8_t clksrc_acu_func_flow(clksrc_stat_mach *m, auto_config_action *aca, auto_trifle *at, uint8_t evt)
+{
+    uint32_t stat;
+    uint32_t *prog;
+    auto_config_unit *acu;
+
+    prog = &m->progs[evt];
+
+    do {
+        // continue the execution from the last time
+        acu = &aca->acus[*prog];
+        stat = timer_try_process_at_on_acu(m->s, acu, at);
+        if (stat == ACU_ST_NEXT) {
+            *prog = acu->next;
+        }
+    } while (ACU_IS_DO_REACT(acu->type) && stat == ACU_ST_NEXT);
+
+    // if done, means trigger
+    if (stat == ACU_ST_DONE) {
+        *prog = 0;
+        return stat;
+    }
+
+    // matching...
+    if (stat == ACU_ST_NEXT) {
+        return stat;
+    }
+
+    // if mismatch, re-match from the start again
+    if (stat == ACU_ST_MISMATCH) {
+        // for lvl irq, we only have doact/dodeact now
+        // TODO: for lvl irq, maybe we shoule do cmp for specific hw evt 
+        //     when we have not start usage of hw evt
+        if ( (at->type == TRIFLE_HW_EVT && ACU_IS_DO_HW_WATCH(acu->type)) ||
+             ((at->type == TRIFLE_KER_READ || at->type == TRIFLE_KER_WRITE) && 
+                ACU_IS_DO_KER_WATCH(acu->type))
+           ) {
+            // if wait & come are same sources of event
+            //    then reset the prog & try match 1st thing again
+            if (*prog != 0) {
+                *prog = 0;
+                return clksrc_acu_func_flow(m, aca, at, evt);
+            }
+        }
+
+        return stat;
+    }
+
+    assert(false && "shouldn't come to here in clksrc_acu_func_flow");
+    return stat;
+}
+
+static uint8_t clksrc_is_evt_off(clksrc_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_off;
+    if (aca) 
+        return clksrc_acu_func_flow(m, aca, at, CLKSRC_EVT_OFF);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t clksrc_is_evt_on(clksrc_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_on;
+    if (aca) 
+        return clksrc_acu_func_flow(m, aca, at, CLKSRC_EVT_ON);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t clksrc_is_evt_init(clksrc_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_init;
+    if (aca) 
+        return clksrc_acu_func_flow(m, aca, at, CLKSRC_EVT_INIT);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t clksrc_is_evt_reset(clksrc_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_reset;
+    if (aca) 
+        return clksrc_acu_func_flow(m, aca, at, CLKSRC_EVT_RESET);
+
+    return ACU_ST_MISMATCH;
+}
+
+static uint8_t clksrc_is_kernel_read(clksrc_stat_mach *m, auto_trifle *at)
+{
+    auto_config_action *aca = m->cfg->is_kernel_read;
+    if (aca) 
+        // use this hwevt's prog slot as only this hwevt can trigger this is_kernel_read
+        return clksrc_acu_func_flow(m, aca, at, CLKSRC_EVT_KERNEL_READ);
+
+    return ACU_ST_MISMATCH;
+}
+
+clksrc_stat_mach *init_clksrc_stat_mach(AUTOBOARD_TIMERState *s, uint32_t cfg_idx)
+{
+    int i;
+    clksrc_stat_mach *m;
+
+    assert(s->cfg->timer_cfgs[cfg_idx].timer_type == STAT_MACH_CLKDEV_SOURCE);
+
+    m = calloc(1, sizeof(clksrc_stat_mach));
+
+    m->s = s;
+    m->name = s->name;
+    m->clk_idx = cfg_idx;
+    m->cfg = (clksrc_cfg *)(s->cfg->timer_cfgs[cfg_idx].timer_stat_mach_cfg);
+
+    m->on = false;
+    m->increment = m->cfg->increment;
+
+    m->delta = s->ns_per_cycle / s->cfg->ns_per_cycle;
+    m->cycles = 0;
+
+    // at the very beginning, the timer is off
+    m->stat = CLKSRC_STAT_OFF;
+
+    for (i = 0; i < CLKSRC_ALL_EVT_NUM; i++)
+        m->progs[i] = 0;
+
+    m->is_evt_off = clksrc_is_evt_off;
+    m->is_evt_on = clksrc_is_evt_on;
+    m->is_evt_init = clksrc_is_evt_init;
+    m->is_evt_reset = clksrc_is_evt_reset;
+    m->is_kernel_read = clksrc_is_kernel_read;
+
+    m->pass_one_cycle = clksrc_past_one_cycle;
+    m->handle_event = clksrc_handle_event;
+    m->dispatch = clksrc_dispatch;
+
+    return m;
+}
diff -rNu qemu-2.3.0.orig/hw/timer/autoboard_timer.c qemu-2.3.0/hw/timer/autoboard_timer.c
--- qemu-2.3.0.orig/hw/timer/autoboard_timer.c	1970-01-01 00:00:00.000000000 +0000
+++ qemu-2.3.0/hw/timer/autoboard_timer.c	2020-08-10 12:21:36.703099334 +0000
@@ -0,0 +1,346 @@
+/*
+ * automatically generated, don't change
+ */
+
+#include "qemu/osdep.h"
+#include "qemu-common.h"
+#include "qemu/log.h"
+#include "qapi/error.h"
+#include "qemu/timer.h"
+#include "hw/timer/autoboard_timer.h"
+#include "hw/timer/autoboard_clksrc.h"
+#include "hw/timer/autoboard_clkevt.h"
+#include "hw/timer/autoboard_timer_gen.h"
+#include "hw/timer/autoboard_timer_utils.h"
+#include "hw/misc/autoboard_utils.h"
+
+static autoboard_timer_cfg_id choosen_id = AUTOBOARD_TIMER_INVALID;
+static const char *timer_name = "anonymous";
+
+void set_autoboard_timer_cfg(autoboard_timer_cfg_id id, const char *name)
+{
+    choosen_id = id; 
+    timer_name = name;
+}
+
+static uint32_t autoboard_mmio_read(autoboard_mmio *mmio, hwaddr off)
+{
+    // TODO: may need add lock here in future
+    return __u32_native(mmio->caches + off);
+}
+
+static uint32_t autoboard_mmio_write(autoboard_mmio *mmio, hwaddr off, uint64_t val)
+{
+    // TODO: may need add lock here in future
+    *((uint32_t *) (mmio->caches + off)) = (uint32_t) val;
+    return 0;
+}
+
+static void autoboard_timer_act_irq(AUTOBOARD_TIMERState *s)
+{
+    if (s->is_level_irq) {
+        // level irq raise
+        qemu_set_irq(s->irq, 1);
+    } else {
+        // edge irq pulse
+        qemu_set_irq(s->irq, 1);
+        qemu_set_irq(s->irq, 0);
+    }
+}
+
+static void autoboard_timer_deact_irq(AUTOBOARD_TIMERState *s)
+{
+    if (s->is_level_irq) {
+        // level irq lower
+        qemu_set_irq(s->irq, 0);
+    }
+}
+
+static void autoboard_timer_tick_callback(void *opaque)
+{
+    AUTOBOARD_TIMERState *s;
+    auto_trifle at;
+
+    s = opaque;
+
+    /* naive timer */
+    uint64_t exceed = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) - s->last_tick;
+    uint64_t round = (exceed + s->ns_per_cycle - 1) / s->ns_per_cycle;
+    s->last_tick += (s->ns_per_cycle * round);
+    timer_mod(s->timer, s->last_tick);
+
+    /* trigger hwevt one cycle */
+    for (uint32_t i = 0; i < s->clkdev_num; i++) {
+        switch (s->clkdevs[i].type) {
+            case STAT_MACH_CLKDEV_EVENT:
+            {
+                clkevt_stat_mach *mach;
+
+                at.type = TRIFLE_HW_EVT;
+                at.hw_evt = CLKEVT_HW_EVT_ONE_CYCLE;
+                at.evt_arg = round;
+
+                mach = s->clkdevs[i].stat_mach;
+                mach->dispatch(mach, &at);
+            }
+                break;
+
+            case STAT_MACH_CLKDEV_SOURCE:
+            // we have a more precise way for clksrc cycle
+            //   could refine these things later
+            /*
+            {
+                clksrc_stat_mach *mach;
+
+                at.type = TRIFLE_HW_EVT;
+                at.hw_evt = CLKSRC_HW_EVT_ONE_CYCLE;
+
+                mach = s->clkdevs[i].stat_mach;
+                mach->dispatch(mach, &at);
+            }
+            */
+                break;
+
+            default:
+                assert("wierd timer type:" && s->clkdevs[i].type && false);
+                break;
+        }
+    }
+}
+
+static uint32_t dispatch_mmio_rw(AUTOBOARD_TIMERState *s, auto_trifle *at)
+{
+    uint32_t triggered = 0;
+
+    // using mmio_rw_once to infer which irq is involved
+    // TODO: here may add trigger series feature
+    for (uint32_t i = 0; i < s->clkdev_num; i++) {
+        switch (s->clkdevs[i].type) {
+            case STAT_MACH_CLKDEV_EVENT:
+                {
+                clkevt_stat_mach *mach = s->clkdevs[i].stat_mach;
+                triggered += mach->dispatch(mach, at);
+                }
+                break;
+
+            case STAT_MACH_CLKDEV_SOURCE:
+                {
+                clksrc_stat_mach *mach = s->clkdevs[i].stat_mach;
+                triggered += mach->dispatch(mach, at);
+                }
+                break;
+
+            case STAT_MACH_CLKDEV_EMPTY:
+                break;
+
+            default:
+                //printf("[+] wierd timer type %d\n", s->clkdevs[i].type);
+                break;
+        }
+    }
+
+    return triggered;
+}
+
+static uint64_t autoboard_timer_read(void *opaque, hwaddr offset, unsigned size, unsigned mmio_idx)
+{
+    AUTOBOARD_TIMERState *s;
+    auto_trifle at;
+    uint32_t triggered;
+    uint32_t res;
+
+    s = opaque;
+
+    res = s->aummios[mmio_idx].read(&s->aummios[mmio_idx], offset);
+
+    at.type = TRIFLE_KER_READ;
+    at.mmio_idx = mmio_idx;
+    at.off = offset;
+    at.old_val = res;
+    at.new_val = 0;
+
+    triggered = dispatch_mmio_rw(s, &at);
+
+    if (triggered) {
+        // do nothing now
+    }
+
+    // read again as the mmio read may induce the change of mmio content
+    res = s->aummios[mmio_idx].read(&s->aummios[mmio_idx], offset);
+
+    //printf("[+] %s read idx %d off 0x%lx, size %d, value 0x%x, %u event(s) are triggered\n", s->name, mmio_idx, offset, size, res, triggered);
+    return res;
+}
+
+static void autoboard_timer_write(void *opaque, hwaddr offset, uint64_t val, unsigned size, unsigned mmio_idx)
+{
+    AUTOBOARD_TIMERState *s;
+    auto_trifle at;
+    uint32_t triggered;
+
+    s = opaque;
+
+    // offset, old_value, new_value
+    at.type = TRIFLE_KER_WRITE;
+    at.mmio_idx = mmio_idx;
+    at.off = offset;
+    at.old_val = (uint64_t)s->aummios[mmio_idx].read(&s->aummios[mmio_idx], offset);
+    at.new_val = val;
+
+    // update the value
+    s->aummios[mmio_idx].write(&s->aummios[mmio_idx], offset, val);
+
+    triggered = dispatch_mmio_rw(s, &at);
+
+    if (triggered) {
+        // do nothing now
+    }
+
+    //printf("[+] %s write idx %d off 0x%lx, size %d, change value from 0x%lx to 0x%lx, %u event(s) are triggered\n", s->name, mmio_idx, at.off, size, at.old_val, at.new_val, triggered);
+}
+
+AUTOBOARD_MAKE_MMIO_RANGE_RW_FUNCS(timer, 0)
+
+static const MemoryRegionOps autoboard_timer_ops[AUTOBOARD_TIMER_MMIO_REGION_NUM] = {
+    AUTOBOARD_MMIO_OPS_STATIC_STRUCT(timer, 0)
+};
+
+static inline uint32_t calc_ns_per_cycle(uint32_t fix, uint32_t cfg)
+{
+    uint32_t factor = (fix / cfg) + ((fix % cfg == 0) ? (0) : (1));
+    return (cfg > fix) ? (cfg) : (factor * cfg);
+}
+
+static void autoboard_timer_init(Object *obj)
+{
+    AUTOBOARD_TIMERState *s = AUTOBOARD_TIMER(obj);
+    int i;
+
+    s->name = timer_name;
+    s->cfg = get_autoboard_timer_config(choosen_id);
+    s->is_level_irq = s->cfg->is_level_irq;
+    s->ns_per_cycle = calc_ns_per_cycle(AUTOBOARD_TIMER_NS_PER_CYCLE, s->cfg->ns_per_cycle);
+    s->act_irq = autoboard_timer_act_irq;
+    s->deact_irq = autoboard_timer_deact_irq;
+
+    /* initialize the mmio cache & the mmio */
+    assert(s->cfg->mm_amount > 0 && s->cfg->mm_amount <= AUTOBOARD_TIMER_MMIO_REGION_NUM && "wierd s->cfg->mm_amount");
+
+    s->mmios = calloc(s->cfg->mm_amount, sizeof(MemoryRegion));
+    s->aummios = calloc(s->cfg->mm_amount, sizeof(autoboard_mmio));
+    for (i = 0; i < s->cfg->mm_amount; i++) {
+        s->aummios[i].mmio_len = s->cfg->mm_lens[i];
+        s->aummios[i].caches = calloc(1, s->aummios[i].mmio_len);
+        s->aummios[i].read = autoboard_mmio_read;
+        s->aummios[i].write = autoboard_mmio_write;
+
+        memory_region_init_io(&(s->mmios[i]), obj, &(autoboard_timer_ops[i]), s, TYPE_AUTOBOARD_TIMER, s->aummios[i].mmio_len);
+        sysbus_init_mmio(SYS_BUS_DEVICE(s), &(s->mmios[i]));
+    }
+
+    /* initialize an irq to the timer */
+    // TODO: ugly fix for the gic timer, re-do this when free
+    if (choosen_id == AUTOBOARD_TIMER_OXNAS_GENERIC_MPTIMER)
+        sysbus_init_irq(SYS_BUS_DEVICE(s), &s->irq);
+    else
+        qdev_init_gpio_out(DEVICE(s), &s->irq, 1);
+
+    /* setup the clock devices */
+    s->clkdev_num = s->cfg->clkdev_num;
+    s->clkdevs = (timer_bundle *)calloc(s->cfg->clkdev_num, sizeof(struct timer_bundle));
+
+    for (uint32_t i = 0; i < s->clkdev_num; i++) {
+        uint8_t type = s->cfg->timer_cfgs[i].timer_type;
+        s->clkdevs[i].type = type;
+        switch(type) {
+            case STAT_MACH_CLKDEV_EMPTY:
+                break;
+
+            case STAT_MACH_CLKDEV_EVENT:
+                s->clkdevs[i].stat_mach = init_clkevt_stat_mach(s, i);
+                break;
+
+            case STAT_MACH_CLKDEV_SOURCE:
+                s->clkdevs[i].stat_mach = init_clksrc_stat_mach(s, i);
+                break;
+
+            default:
+                assert("wierd timer type:" && type && false);
+                break;
+        }
+    }
+
+    /* initialize the timer finally*/
+    s->timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, autoboard_timer_tick_callback, s);
+}
+
+static void autoboard_timer_reset(DeviceState *dev)
+{
+    AUTOBOARD_TIMERState *s;
+    auto_trifle at;
+
+    s = AUTOBOARD_TIMER(dev);
+
+    for (uint32_t i = 0; i < s->clkdev_num; i++) {
+        switch (s->clkdevs[i].type) {
+        case STAT_MACH_CLKDEV_EVENT:
+            {
+            clkevt_stat_mach *mach;
+
+            at.type = TRIFLE_HW_EVT;
+            at.hw_evt = CLKEVT_EVT_RESET;
+
+            mach = s->clkdevs[i].stat_mach;
+            mach->dispatch(mach, &at);
+            }
+            break;
+
+        case STAT_MACH_CLKDEV_SOURCE:
+            {
+            clksrc_stat_mach *mach;
+
+            at.type = TRIFLE_HW_EVT;
+            at.hw_evt = CLKSRC_EVT_RESET;
+
+            mach = s->clkdevs[i].stat_mach;
+            mach->dispatch(mach, &at);
+            }
+            break;
+
+        case STAT_MACH_CLKDEV_EMPTY:
+            break;
+
+        default:
+            //printf("[+] wierd timer type %d\n", s->clkdevs[i].type);
+            break;
+        }
+    }
+
+    // kickoff the timer
+    s->last_tick = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);
+    s->first_tick_off = 0 - s->last_tick / s->cfg->ns_per_cycle;
+    timer_mod(s->timer, s->last_tick + s->ns_per_cycle);
+}
+
+static void autoboard_timer_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+
+    dc->reset = autoboard_timer_reset;
+}
+
+static TypeInfo autoboard_timer_type_info = {
+    .name = TYPE_AUTOBOARD_TIMER,
+    .parent = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(AUTOBOARD_TIMERState),
+    .instance_init = autoboard_timer_init,
+    /* .class_size = sizeof(SysBusDeviceClass), */
+    .class_init = autoboard_timer_class_init,
+};
+
+static void autoboard_timer_register_types(void)
+{
+    type_register_static(&autoboard_timer_type_info);
+}
+
+type_init(autoboard_timer_register_types)
diff -rNu qemu-2.3.0.orig/hw/timer/autoboard_timer_gen.c qemu-2.3.0/hw/timer/autoboard_timer_gen.c
--- qemu-2.3.0.orig/hw/timer/autoboard_timer_gen.c	1970-01-01 00:00:00.000000000 +0000
+++ qemu-2.3.0/hw/timer/autoboard_timer_gen.c	2020-08-10 11:22:20.005469617 +0000
@@ -0,0 +1,637 @@
+/*
+ * autoboard timer auto generated implementation
+ */
+
+#include "qemu/osdep.h"
+
+#include "hw/timer/autoboard_timer.h"
+#include "hw/timer/autoboard_clkevt.h"
+#include "hw/timer/autoboard_clksrc.h"
+#include "hw/timer/autoboard_timer_gen.h"
+#include "hw/timer/autoboard_timer_utils.h"
+#include "hw/misc/autoboard_utils.h"
+
+
+uint8_t timer_try_process_at_on_acu(AUTOBOARD_TIMERState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    switch (acu->type) {
+        case ACU_DO_WATCH_READ:
+        {
+            if ((at->type != TRIFLE_KER_READ) || (at->mmio_idx != acu->midx) || (at->off != acu->moff))
+                return ACU_ST_MISMATCH;
+        }
+            break;
+        case ACU_DO_WATCH_WRITE:
+        {
+            if ((at->type != TRIFLE_KER_WRITE) || (at->mmio_idx != acu->midx) || (at->off != acu->moff))
+                return ACU_ST_MISMATCH;
+
+            if (!acu->match_write_cnt(s, acu, at))
+                return ACU_ST_MISMATCH;
+        }
+            break;
+        case ACU_DO_WATCH_HWEVT:
+        {
+            if ((at->type != TRIFLE_HW_EVT) || (at->hw_evt != acu->hw_evt))
+                return ACU_ST_MISMATCH;
+        }
+            break;
+        case ACU_DO_REACT:
+        {
+            acu->do_react(s, acu, at);
+        }
+            break;
+        default:
+            assert(false && "this should not be executed");
+            break;
+    }
+
+    return (acu->next) ? (ACU_ST_NEXT) : (ACU_ST_DONE);
+}
+
+static auto_config_action wait_hw_evt_clkevt_reset_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_HWEVT,
+            .hw_evt = CLKEVT_EVT_RESET,
+            .next = 0,
+        }
+    }
+};
+
+static auto_config_action wait_hw_evt_clksrc_reset_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_HWEVT,
+            .hw_evt = CLKSRC_EVT_RESET,
+            .next = 0,
+        }
+    }
+};
+
+/*
+ * for oxnas.generic
+ * 
+ * we have 2 timers, 1 for clvevt in gic, 1 for clksrc
+ * 
+ */
+
+/*
+ * for oxnas.generic rps clksrc device
+ */
+
+#define OXNAS_GENERIC_RPS_CLKDEV_NUM 1
+#define OXNAS_GENERIC_RPS_INCREMENT false
+#define OXNAS_GENERIC_RPS_NS_PER_CYCLE 2560
+#define OXNAS_GENERIC_RPS_MMIO_AMOUNT 1
+#define OXNAS_GENERIC_RPS_MMIO1 0x40
+static uint32_t oxnas_generic_rps_mmio_lens[OXNAS_GENERIC_RPS_MMIO_AMOUNT] = {
+   OXNAS_GENERIC_RPS_MMIO1, 
+};
+
+static uint8_t oxnas_generic_rps_is_init_func0(AUTOBOARD_TIMERState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    //printf("[+] match init func0 at->new_val:0x%x %d \n", at->new_val, (at->new_val == (uint32_t)(uint32_t)((1 << 24) - 1)));
+    return (at->new_val == (uint32_t)((1 << 24) - 1));
+}
+
+static uint8_t oxnas_generic_rps_is_init_func1(AUTOBOARD_TIMERState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    //printf("[+] match init func1 at->new_val:0x%x result: %d \n", at->new_val, (at->new_val == (uint32_t)(__bit(2) | __bit(6) | __bit(7)));
+    return (at->new_val == (uint32_t)(__bit(2) | __bit(6) | __bit(7)));
+}
+
+static auto_config_action oxnas_generic_rps_is_init_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x20,
+            .match_write_cnt = oxnas_generic_rps_is_init_func0,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x28,
+            .match_write_cnt = oxnas_generic_rps_is_init_func1,
+            .next = 0,
+        },
+    }
+};
+
+// TODO: this logic can be more clear by only doing necessary conversion when kernel reads
+//       should add one more event & partly re-design the stat machine
+static uint8_t oxnas_generic_rps_is_kernel_read_func(AUTOBOARD_TIMERState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    uint32_t midx = 0, moff = 0x24;
+    uint32_t cycles = 0 - (qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) / s->cfg->ns_per_cycle + s->first_tick_off);
+
+    s->aummios[midx].write(s->aummios, moff, (uint32_t)(cycles));
+    return 0;
+}
+
+static auto_config_action oxnas_generic_rps_is_kernel_read_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_READ,
+            .midx = 0,
+            .moff = 0x24,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_REACT,
+            .do_react = oxnas_generic_rps_is_kernel_read_func,
+            .next = 0,
+        }
+    }
+};
+
+static clksrc_cfg oxnas_generic_rps_timer_cfg = {
+    .increment = OXNAS_GENERIC_RPS_INCREMENT,
+    .is_off = NULL,
+    .is_on = NULL,
+    .is_init = &oxnas_generic_rps_is_init_cfg,
+    .is_reset = &wait_hw_evt_clksrc_reset_cfg,
+    .is_kernel_read = &oxnas_generic_rps_is_kernel_read_cfg,
+};
+
+static auto_config_one_timer oxnas_generic_rps_timer_cfgs[OXNAS_GENERIC_RPS_CLKDEV_NUM] = {
+    [0] = {
+        .timer_type = STAT_MACH_CLKDEV_SOURCE,
+        .timer_stat_mach_cfg = &oxnas_generic_rps_timer_cfg,
+    },
+};
+
+/*
+ * for oxnas.generic mptimer clkevt device
+ */
+
+#define OXNAS_GENERIC_MPTIMER_CLKDEV_NUM 1
+#define OXNAS_GENERIC_MPTIMER_LEVEL_IRQ true
+// TODO: currently set it as 2560, but its calculated value is 6 
+//       maybe we should limit the symbolic execution to give a reasonable value here
+#define OXNAS_GENERIC_MPTIMER_NS_PER_CYCLE 2000
+#define OXNAS_GENERIC_MPTIMER_MMIO_AMOUNT 1
+#define OXNAS_GENERIC_MPTIMER_MMIO1 0x20
+static uint32_t oxnas_generic_mptimer_mmio_lens[OXNAS_GENERIC_MPTIMER_MMIO_AMOUNT] = {
+   OXNAS_GENERIC_MPTIMER_MMIO1, 
+};
+
+static uint8_t oxnas_generic_mptimer_set_idle_func(AUTOBOARD_TIMERState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    //printf("[+] match init func1 at->new_val:0x%x result: %d \n", at->new_val, (at->new_val == (uint32_t)(__bit(2) | __bit(6) | __bit(7)));
+    return (at->new_val == (uint32_t)(0));
+}
+
+static auto_config_action oxnas_generic_mptimer_set_idle_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x8,
+            .match_write_cnt = oxnas_generic_mptimer_set_idle_func,
+            .next = 0,
+        },
+    }
+};
+
+static uint8_t oxnas_generic_mptimer_is_set_perio_func0(AUTOBOARD_TIMERState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    //printf("[+] is set perio func0 at->new_val: 0x%lx, countdown & load value is: %lu \n", at->new_val, ((uint32_t) 10E9) / at->new_val);
+    // TODO: we need to fill the actual rate/factor value here
+    //return (at->new_val == (uint32_t)(???));
+    //printf("[+] is set perio func0 at->new_val: 0x%lx\n", at->new_val);
+    //((clkevt_stat_mach *)(((timer_bundle)s->clkdevs[0]).stat_mach))->countdown = at->new_val / 500;
+    //((clkevt_stat_mach *)(((timer_bundle)s->clkdevs[0]).stat_mach))->load = at->new_val / 500;
+    ((clkevt_stat_mach *)(((timer_bundle)s->clkdevs[0]).stat_mach))->countdown = at->new_val;
+    ((clkevt_stat_mach *)(((timer_bundle)s->clkdevs[0]).stat_mach))->load = at->new_val;
+    return true;
+}
+
+static uint8_t oxnas_generic_mptimer_is_set_perio_func1(AUTOBOARD_TIMERState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    //printf("[+] match is set perio func1 result: %d \n", (at->new_val == (uint32_t)(__bit(0) | __bit(1) | __bit(2))));
+    return (at->new_val == (uint32_t)(__bit(0) | __bit(1) | __bit(2)));
+}
+
+static auto_config_action oxnas_generic_mptimer_is_set_perio_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x0,
+            .match_write_cnt = oxnas_generic_mptimer_is_set_perio_func0,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x8,
+            .match_write_cnt = oxnas_generic_mptimer_is_set_perio_func1,
+            .next = 0,
+        },
+    }
+};
+
+static uint8_t oxnas_generic_mptimer_is_set_oneshot_func(AUTOBOARD_TIMERState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    //printf("[+] match init func1 at->new_val:0x%x result: %d \n", at->new_val, (at->new_val == (uint32_t)(__bit(2))));
+    // TODO: we need to fill the actual rate/factor value here
+    return (at->new_val == (uint32_t)(__bit(2)));
+}
+
+static auto_config_action oxnas_generic_mptimer_is_set_oneshot_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x8,
+            .match_write_cnt = oxnas_generic_mptimer_is_set_oneshot_func,
+            .next = 0,
+        },
+    }
+};
+
+static uint8_t oxnas_generic_mptimer_is_ack_func0(AUTOBOARD_TIMERState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    uint32_t midx = 0, moff = 0xc;
+    s->aummios[midx].write(&s->aummios[midx], moff, 1);
+    return 0;
+}
+
+static uint8_t oxnas_generic_mptimer_is_ack_func1(AUTOBOARD_TIMERState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    return at->new_val == 1;
+}
+
+static auto_config_action oxnas_generic_mptimer_is_ack_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_READ,
+            .midx = 0,
+            .moff = 0xc,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_REACT,
+            .do_react = oxnas_generic_mptimer_is_ack_func0,
+            .next = 2,
+        },
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0xc,
+            .match_write_cnt = oxnas_generic_mptimer_is_ack_func1,
+            .next = 0,
+        },
+    }
+};
+
+static uint8_t oxnas_generic_mptimer_is_oneshot_set_next_func0(AUTOBOARD_TIMERState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    // TODO: here may need more consideration?
+    // now we know that the written cnt directly tells the cycle num
+    //printf("[+] is oneshot set next func0 load value is: %lu \n", at->new_val);
+    ((clkevt_stat_mach *)(((timer_bundle)s->clkdevs[0]).stat_mach))->load = at->new_val;
+    return true;
+}
+
+static uint8_t oxnas_generic_mptimer_is_oneshot_set_next_func1(AUTOBOARD_TIMERState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    return at->new_val == ((at->old_val) | (uint32_t)(__bit(0)));
+}
+
+static auto_config_action oxnas_generic_mptimer_is_oneshot_set_next_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_READ,
+            .midx = 0,
+            .moff = 0x8,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x4,
+            .match_write_cnt = oxnas_generic_mptimer_is_oneshot_set_next_func0,
+            .next = 2,
+        },
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x8,
+            .match_write_cnt = oxnas_generic_mptimer_is_oneshot_set_next_func1,
+            .next = 0,
+        },
+    }
+};
+
+static clkevt_cfg oxnas_generic_mptimer_timer_cfg = {
+    .is_off = NULL,
+    .is_on = NULL,
+    .is_init = &oxnas_generic_mptimer_set_idle_cfg,
+    .is_reset = &wait_hw_evt_clkevt_reset_cfg,
+    .is_set_unused = &oxnas_generic_mptimer_set_idle_cfg,
+    .is_set_perio = &oxnas_generic_mptimer_is_set_perio_cfg,
+    .is_set_oneshot = &oxnas_generic_mptimer_is_set_oneshot_cfg,
+    .is_ack = &oxnas_generic_mptimer_is_ack_cfg,
+    .is_oneshot_set_next = &oxnas_generic_mptimer_is_oneshot_set_next_cfg,
+};
+
+static auto_config_one_timer oxnas_generic_mptimer_timer_cfgs[OXNAS_GENERIC_MPTIMER_CLKDEV_NUM] = {
+    [0] = {
+        .timer_type = STAT_MACH_CLKDEV_EVENT,
+        .timer_stat_mach_cfg = &oxnas_generic_mptimer_timer_cfg,
+    },
+};
+
+/*
+ * for kirkwood.generic
+ * 
+ * we have 1 timer: marvell orion timer
+ * 
+ */
+#define MARVELL_ORION_CLKDEV_NUM 2
+#define MARVELL_ORION_INCREMENT false
+#define MARVELL_ORION_LEVEL_IRQ false
+#define MARVELL_ORION_NS_PER_CYCLE 5
+#define MARVELL_ORION_MMIO_AMOUNT 1
+#define MARVELL_ORION_MMIO1 0x20
+static uint32_t marvell_orion_mmio_lens[MARVELL_ORION_MMIO_AMOUNT] = {
+   MARVELL_ORION_MMIO1, 
+};
+
+static uint8_t marvell_orion_timer_is_init_func0(AUTOBOARD_TIMERState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    return (at->new_val == (uint32_t)(~0));
+}
+
+static uint8_t marvell_orion_timer_is_init_func1(AUTOBOARD_TIMERState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    uint32_t mask = __bit(0) | __bit(1);
+    uint32_t set = __bit(0) | __bit(1);
+    return (at->new_val == (uint32_t)(((uint32_t)(at->old_val) & ~mask) | (mask & set)));
+}
+
+static auto_config_action marvell_orion_timer_is_init_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x14,
+            .match_write_cnt = marvell_orion_timer_is_init_func0,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x10,
+            .match_write_cnt = marvell_orion_timer_is_init_func0,
+            .next = 2,
+        },
+        {
+            .type = ACU_DO_WATCH_READ,
+            .midx = 0,
+            .moff = 0x0,
+            .next = 3,
+        },
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x0,
+            .match_write_cnt = marvell_orion_timer_is_init_func1,
+            .next = 0,
+        },
+    }
+};
+
+static uint8_t marvell_orion_timer_is_kernel_read_func(AUTOBOARD_TIMERState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    uint32_t midx = 0, moff = 0x14;
+    uint32_t cycles = 0 - (qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) / s->cfg->ns_per_cycle + s->first_tick_off);
+
+    s->aummios[midx].write(s->aummios, moff, (uint32_t)(cycles));
+    return 0;
+}
+
+static auto_config_action marvell_orion_timer_is_kernel_read_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_READ,
+            .midx = 0,
+            .moff = 0x14,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_REACT,
+            .do_react = marvell_orion_timer_is_kernel_read_func,
+            .next = 0,
+        }
+    }
+};
+
+static clksrc_cfg marvell_orion_timer_clksrc_cfg = {
+    .increment = MARVELL_ORION_INCREMENT,
+    .is_off = NULL,
+    .is_on = NULL,
+    .is_init = &marvell_orion_timer_is_init_cfg,
+    .is_reset = &wait_hw_evt_clksrc_reset_cfg,
+    .is_kernel_read = &marvell_orion_timer_is_kernel_read_cfg,
+};
+
+static uint8_t marvell_orion_timer_is_set_perio_func0(AUTOBOARD_TIMERState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    //printf("[+] is set perio func0 at->new_val: 0x%lx, countdown & load value is: %lu \n", at->new_val, ((uint32_t) 10E9) / at->new_val);
+    // TODO: we need to fill the actual rate/factor value here
+    //return (at->new_val == (uint32_t)(???));
+    //printf("[+] is set perio func0 at->new_val: 0x%lx\n", at->new_val);
+    ((clkevt_stat_mach *)(((timer_bundle)s->clkdevs[1]).stat_mach))->countdown = at->new_val;
+    ((clkevt_stat_mach *)(((timer_bundle)s->clkdevs[1]).stat_mach))->load = at->new_val;
+    return true;
+}
+
+static uint8_t marvell_orion_timer_is_set_perio_func1(AUTOBOARD_TIMERState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    //printf("[+] match is set perio func1 result: %d \n", (at->new_val == (uint32_t)(__bit(0) | __bit(1) | __bit(2))));
+    return true;
+}
+
+static uint8_t marvell_orion_timer_is_set_perio_func2(AUTOBOARD_TIMERState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    uint32_t mask = __bit(2) | __bit(3);
+    uint32_t set = __bit(2) | __bit(3);
+    return (at->new_val == (uint32_t)(((uint32_t)(at->old_val) & ~mask) | (mask & set)));
+}
+
+static auto_config_action marvell_orion_timer_is_set_perio_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x18,
+            .match_write_cnt = marvell_orion_timer_is_set_perio_func0,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x1c,
+            .match_write_cnt = marvell_orion_timer_is_set_perio_func1,
+            .next = 2,
+        },
+        {
+            .type = ACU_DO_WATCH_READ,
+            .midx = 0,
+            .moff = 0x0,
+            .next = 3,
+        },
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x0,
+            .match_write_cnt = marvell_orion_timer_is_set_perio_func2,
+            .next = 0,
+        },
+    }
+};
+
+static uint8_t marvell_orion_timer_is_set_oneshot_func(AUTOBOARD_TIMERState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    uint32_t mask = __bit(2) | __bit(3);
+    uint32_t set = 0;
+    return (at->new_val == (uint32_t)(((uint32_t)(at->old_val) & ~mask) | (mask & set)));
+}
+
+static auto_config_action marvell_orion_timer_is_set_oneshot_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_READ,
+            .midx = 0,
+            .moff = 0x0,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x0,
+            .match_write_cnt = marvell_orion_timer_is_set_oneshot_func,
+            .next = 0,
+        },
+    }
+};
+
+static uint8_t marvell_orion_timer_is_oneshot_set_next_func0(AUTOBOARD_TIMERState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    // TODO: here may need more consideration?
+    // now we know that the written cnt directly tells the cycle num
+    //printf("[+] is oneshot set next func0 load value is: %lu \n", at->new_val);
+    ((clkevt_stat_mach *)(((timer_bundle)s->clkdevs[1]).stat_mach))->load = at->new_val;
+    return true;
+}
+
+static uint8_t marvell_orion_timer_is_oneshot_set_next_func1(AUTOBOARD_TIMERState *s, auto_config_unit *acu, auto_trifle *at)
+{
+    uint32_t mask = __bit(2) | __bit(3);
+    uint32_t set = __bit(2);
+    return (at->new_val == (uint32_t)(((uint32_t)(at->old_val) & ~mask) | (mask & set)));
+}
+
+static auto_config_action marvell_orion_timer_is_oneshot_set_next_cfg = {
+    .prog = 0,
+    .acus = {
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x1c,
+            .match_write_cnt = marvell_orion_timer_is_oneshot_set_next_func0,
+            .next = 1,
+        },
+        {
+            .type = ACU_DO_WATCH_READ,
+            .midx = 0,
+            .moff = 0x0,
+            .next = 2,
+        },
+        {
+            .type = ACU_DO_WATCH_WRITE,
+            .midx = 0,
+            .moff = 0x0,
+            .match_write_cnt = marvell_orion_timer_is_oneshot_set_next_func1,
+            .next = 0,
+        },
+    }
+};
+
+static clkevt_cfg marvell_orion_timer_clkevt_cfg = {
+    .is_off = NULL,
+    .is_on = NULL,
+    .is_init = &marvell_orion_timer_is_init_cfg,
+    .is_reset = &wait_hw_evt_clkevt_reset_cfg,
+    .is_set_unused = NULL,
+    .is_set_perio = &marvell_orion_timer_is_set_perio_cfg,
+    .is_set_oneshot = &marvell_orion_timer_is_set_oneshot_cfg,
+    .is_ack = NULL,
+    .is_oneshot_set_next = &marvell_orion_timer_is_oneshot_set_next_cfg,
+};
+
+static auto_config_one_timer marvell_orion_timer_cfgs[MARVELL_ORION_CLKDEV_NUM] = {
+    [0] = {
+        .timer_type = STAT_MACH_CLKDEV_SOURCE,
+        .timer_stat_mach_cfg = &marvell_orion_timer_clksrc_cfg,
+    },
+    [1] = {
+        .timer_type = STAT_MACH_CLKDEV_EVENT,
+        .timer_stat_mach_cfg = &marvell_orion_timer_clkevt_cfg,
+    },
+};
+
+/*
+ * Config Panel
+ */
+
+static auto_one_timer_cfg all_timer_cfgs[AUTOBOARD_TIMER_NUM] = {
+    [AUTOBOARD_TIMER_OXNAS_GENERIC_RPS] = {
+        .timer_cfgs = oxnas_generic_rps_timer_cfgs,
+        .mm_lens = oxnas_generic_rps_mmio_lens,
+        .mm_amount = OXNAS_GENERIC_RPS_MMIO_AMOUNT,
+        .ns_per_cycle = OXNAS_GENERIC_RPS_NS_PER_CYCLE,
+        .clkdev_num = OXNAS_GENERIC_RPS_CLKDEV_NUM,
+    },
+    [AUTOBOARD_TIMER_OXNAS_GENERIC_MPTIMER] = {
+        .timer_cfgs = oxnas_generic_mptimer_timer_cfgs,
+        .mm_lens = oxnas_generic_mptimer_mmio_lens,
+        .mm_amount = OXNAS_GENERIC_MPTIMER_MMIO_AMOUNT,
+        .is_level_irq = OXNAS_GENERIC_MPTIMER_LEVEL_IRQ,
+        .ns_per_cycle = OXNAS_GENERIC_MPTIMER_NS_PER_CYCLE,
+        .clkdev_num = OXNAS_GENERIC_MPTIMER_CLKDEV_NUM,
+    },
+    [AUTOBOARD_TIMER_MARVELL_ORION] = {
+        .timer_cfgs = marvell_orion_timer_cfgs,
+        .mm_lens = marvell_orion_mmio_lens,
+        .mm_amount = MARVELL_ORION_MMIO_AMOUNT,
+        .is_level_irq = MARVELL_ORION_LEVEL_IRQ,
+        .ns_per_cycle = MARVELL_ORION_NS_PER_CYCLE,
+        .clkdev_num = MARVELL_ORION_CLKDEV_NUM,
+    },
+};
+
+// This init func should be called at the very beginning as it will init the above global variables
+auto_one_timer_cfg *get_autoboard_timer_config(autoboard_timer_cfg_id id)
+{
+    assert(id > AUTOBOARD_TIMER_INVALID && id < AUTOBOARD_TIMER_NUM && "invalid autoboard timer cfg id");
+    return &all_timer_cfgs[id];
+}
\ No newline at end of file
diff -rNu qemu-2.3.0.orig/hw/timer/autoboard_timer_utils.c qemu-2.3.0/hw/timer/autoboard_timer_utils.c
--- qemu-2.3.0.orig/hw/timer/autoboard_timer_utils.c	1970-01-01 00:00:00.000000000 +0000
+++ qemu-2.3.0/hw/timer/autoboard_timer_utils.c	2020-08-10 11:22:20.005469617 +0000
@@ -0,0 +1,8 @@
+/*
+ * autoboard timer common utils implementation
+ */
+
+#include "qemu/osdep.h"
+
+#include "hw/timer/autoboard_timer_utils.h"
+#include "hw/misc/autoboard_utils.h"
\ No newline at end of file
diff -rNu qemu-2.3.0.orig/include/hw/char/serial.h qemu-2.3.0/include/hw/char/serial.h
--- qemu-2.3.0.orig/include/hw/char/serial.h	2015-04-27 14:08:25.000000000 +0000
+++ qemu-2.3.0/include/hw/char/serial.h	2020-08-10 11:46:35.100115285 +0000
@@ -57,6 +57,7 @@
     int baudbase;
     int tsr_retry;
     uint32_t wakeup;
+    bool au;
 
     /* Time when the last byte was successfully sent out of the tsr */
     uint64_t last_xmit_ts;
@@ -89,6 +90,10 @@
                             hwaddr base, int it_shift,
                             qemu_irq irq, int baudbase,
                             CharDriverState *chr, enum device_endian end);
+SerialState *serial_mm_init_au(MemoryRegion *address_space,
+                            hwaddr base, int it_shift,
+                            qemu_irq irq, int baudbase,
+                            CharDriverState *chr, enum device_endian end);
 
 /* serial-isa.c */
 #define TYPE_ISA_SERIAL "isa-serial"
diff -rNu qemu-2.3.0.orig/include/hw/cpu/autoboard_arm11mpcore.h qemu-2.3.0/include/hw/cpu/autoboard_arm11mpcore.h
--- qemu-2.3.0.orig/include/hw/cpu/autoboard_arm11mpcore.h	1970-01-01 00:00:00.000000000 +0000
+++ qemu-2.3.0/include/hw/cpu/autoboard_arm11mpcore.h	2020-08-10 11:20:39.662645666 +0000
@@ -0,0 +1,37 @@
+/*
+ * ARM11MPCore internal peripheral emulation for autoboard.
+ *
+ * Written by Zhang Cen
+ *
+ * This code is licensed under the GPL.
+ */
+
+#ifndef HW_CPU_AUTOBOARDARM11MPCORE_H
+#define HW_CPU_AUTOBOARDARM11MPCORE_H
+
+#include "hw/sysbus.h"
+#include "hw/misc/arm11scu.h"
+//#include "hw/intc/arm_gic.h"
+#include "hw/intc/autoboard_intc.h"
+//#include "hw/timer/arm_mptimer.h"
+#include "hw/timer/autoboard_timer.h"
+
+#define TYPE_AUTOBOARDARM11MPCORE_PRIV "autoboardarm11mpcore_priv"
+#define AUTOBOARDARM11MPCORE_PRIV(obj) \
+    OBJECT_CHECK(AUTOBOARDARM11MPCorePriveState, (obj), TYPE_AUTOBOARDARM11MPCORE_PRIV)
+
+typedef struct AUTOBOARDARM11MPCorePriveState {
+    SysBusDevice parent_obj;
+
+    uint32_t num_cpu;
+    MemoryRegion container;
+    uint32_t num_irq;
+
+    ARM11SCUState scu;
+    AUTOBOARD_INTCState aic;
+    AUTOBOARD_TIMERState mptimer;
+    //ARMMPTimerState mptimer;
+    //ARMMPTimerState wdtimer;
+} AUTOBOARDARM11MPCorePriveState;
+
+#endif
diff -rNu qemu-2.3.0.orig/include/hw/intc/autoboard_edge_irq.h qemu-2.3.0/include/hw/intc/autoboard_edge_irq.h
--- qemu-2.3.0.orig/include/hw/intc/autoboard_edge_irq.h	1970-01-01 00:00:00.000000000 +0000
+++ qemu-2.3.0/include/hw/intc/autoboard_edge_irq.h	2020-08-10 11:21:11.615585455 +0000
@@ -0,0 +1,108 @@
+/*
+ * autoboard edge irq stat machine header file
+ */
+
+#ifndef TYPE_AUTOBOARD_EDGE_IRQ_H
+#define TYPE_AUTOBOARD_EDGE_IRQ_H
+
+#include "hw/sysbus.h"
+#include "hw/intc/autoboard_intc.h"
+#include "hw/intc/autoboard_intc_gen.h"
+#include "hw/intc/autoboard_intc_utils.h"
+#include "hw/misc/autoboard_utils.h"
+
+/*
+ * EDGE IRQ STAT MACHINE
+ * 
+ * "-" means all the other events
+ * 
+ *       OFF  IDLE   ACT  MSK 
+ * OFF    -    on    on   on
+ * IDLE  off    -   pulse msk
+ * ACT   off   ack    -   msk
+ * MSK   off  unmsk unmsk   -
+ * 
+ * on reset, set this irq to idle 
+ * on init, set this irq to idle if it is in off, otherwise no change?
+ * 
+ */
+typedef enum {
+    EDGE_STAT_OFF = 0,
+    EDGE_STAT_IDLE,
+    EDGE_STAT_ACT,
+    EDGE_STAT_MSK,
+    EDGE_STAT_NUM,
+    EDGE_STAT_INVALID = -1,
+} edge_irq_stat;
+
+/*
+ * currently, we only found the case that msk/unmsk/init is watchable
+ * for evt on/off/reset, they are raised by the hardware
+ */
+typedef enum {
+    EDGE_EVT_OFF = 0,
+    EDGE_EVT_ON,
+    EDGE_EVT_PULSE,
+    EDGE_EVT_ACK,
+    EDGE_EVT_MSK,
+    EDGE_EVT_UNMSK,
+    EDGE_EVT_RESET,
+    EDGE_EVT_INIT,
+    EDGE_HW_EVT_PULSE_UP,
+    EDGE_HW_EVT_PULSE_DOWN,
+    EDGE_HW_EVT_DOACT,
+    EDGE_HW_EVT_DODEACT,
+    // The following are not valid events
+    EDGE_ALL_EVT_NUM,
+    EDGE_EVT_INVALID = -1,
+} edge_irq_event;
+
+typedef struct edge_irq_cfg {
+    auto_config_action *is_off;
+    auto_config_action *is_on;
+    auto_config_action *is_pulse;
+    auto_config_action *is_ack;
+    auto_config_action *is_msk;
+    auto_config_action *is_unmsk;
+    auto_config_action *is_reset;
+    auto_config_action *is_init;
+    auto_config_action *do_act;
+    auto_config_action *do_deact;
+} edge_irq_cfg;
+
+typedef struct edge_irq_stat_mach {
+    uint32_t irq_idx;
+
+    edge_irq_cfg *cfg;
+
+    edge_irq_stat stat;
+
+    AUTOBOARD_INTCState *s;
+
+    uint8_t on;
+    uint8_t act;
+    uint8_t msk;
+
+    uint32_t progs[EDGE_ALL_EVT_NUM];
+
+    uint8_t (* is_evt_off) (struct edge_irq_stat_mach *, auto_trifle *);
+    uint8_t (* is_evt_on) (struct edge_irq_stat_mach *, auto_trifle *);
+    uint8_t (* is_evt_pulse) (struct edge_irq_stat_mach *, auto_trifle *);
+    uint8_t (* is_evt_ack) (struct edge_irq_stat_mach *, auto_trifle *);
+    uint8_t (* is_evt_msk) (struct edge_irq_stat_mach *, auto_trifle *);
+    uint8_t (* is_evt_unmsk) (struct edge_irq_stat_mach *, auto_trifle *);
+    uint8_t (* is_evt_reset) (struct edge_irq_stat_mach *, auto_trifle *);
+    uint8_t (* is_evt_init) (struct edge_irq_stat_mach *, auto_trifle *);
+
+    bool (* is_acted) (struct edge_irq_stat_mach *);
+    uint8_t (* do_act) (struct edge_irq_stat_mach *, auto_trifle *);
+    uint8_t (* do_deact) (struct edge_irq_stat_mach *, auto_trifle *);
+
+    void (* handle_event)(struct edge_irq_stat_mach *, edge_irq_event);
+    int (* dispatch)(struct edge_irq_stat_mach *, auto_trifle *);
+
+} edge_irq_stat_mach;
+
+edge_irq_stat_mach *init_edge_irq_stat_mach(AUTOBOARD_INTCState *s, uint32_t cfg_idx);
+
+#endif /* TYPE_AUTOBOARD_EDGE_IRQ_H */
\ No newline at end of file
diff -rNu qemu-2.3.0.orig/include/hw/intc/autoboard_eoi_lvl_irq.h qemu-2.3.0/include/hw/intc/autoboard_eoi_lvl_irq.h
--- qemu-2.3.0.orig/include/hw/intc/autoboard_eoi_lvl_irq.h	1970-01-01 00:00:00.000000000 +0000
+++ qemu-2.3.0/include/hw/intc/autoboard_eoi_lvl_irq.h	2020-08-10 11:21:11.615585455 +0000
@@ -0,0 +1,112 @@
+/*
+ * autoboard eoi level irq stat machine header file
+ */
+
+#ifndef TYPE_AUTOBOARD_EOI_LVL_IRQ_H
+#define TYPE_AUTOBOARD_EOI_LVL_IRQ_H
+
+#include "hw/sysbus.h"
+#include "hw/intc/autoboard_intc.h"
+#include "hw/intc/autoboard_intc_gen.h"
+#include "hw/intc/autoboard_intc_utils.h"
+#include "hw/misc/autoboard_utils.h"
+
+/*
+ * LEVEL EOI IRQ STAT MACHINE
+ * 
+ * "-" means all the other events
+ * 
+ *       OFF  IDLE   ACT  MSK 
+ * OFF    -    on    on   on
+ * IDLE  off    -   act   msk
+ * ACT   off  deact   -   msk
+ * MSK   off  unmsk unmsk   -
+ * 
+ * on reset, set this irq to idle 
+ * on init, set this irq to idle if it is in off, otherwise no change?
+ * 
+ */
+typedef enum {
+    EOI_LVL_STAT_OFF = 0,
+    EOI_LVL_STAT_IDLE,
+    EOI_LVL_STAT_ACT,
+    EOI_LVL_STAT_MSK,
+    //EOI_LVL_STAT_ACK,
+    EOI_LVL_STAT_NUM,
+    EOI_LVL_STAT_INVALID = -1,
+} eoi_lvl_irq_stat;
+
+/*
+ * currently, we only found the case that msk/unmsk/init is watchable
+ * for evt on/off/reset, they are raised by the hardware
+ */
+typedef enum {
+    EOI_LVL_EVT_OFF = 0,
+    EOI_LVL_EVT_ON,
+    EOI_LVL_EVT_ACT,
+    EOI_LVL_EVT_DEACT,
+    EOI_LVL_EVT_EOI,
+    EOI_LVL_EVT_MSK,
+    // Seems we don't need ack step in hardware as we didn't find any kernel code call ack solely
+    //EOI_LVL_EVT_ACK,
+    EOI_LVL_EVT_UNMSK,
+    EOI_LVL_EVT_RESET,
+    EOI_LVL_EVT_INIT,
+    EOI_LVL_HW_EVT_DOACT,
+    EOI_LVL_HW_EVT_DODEACT,
+    // The following are not valid events
+    EOI_LVL_ALL_EVT_NUM,
+    EOI_LVL_EVT_INVALID = -1,
+} eoi_lvl_irq_event;
+
+typedef struct eoi_lvl_irq_cfg {
+    auto_config_action *is_off;
+    auto_config_action *is_on;
+    auto_config_action *is_act;
+    auto_config_action *is_deact;
+    auto_config_action *is_eoi;
+    auto_config_action *is_msk;
+    auto_config_action *is_unmsk;
+    auto_config_action *is_reset;
+    auto_config_action *is_init;
+    auto_config_action *do_act;
+    auto_config_action *do_deact;
+} eoi_lvl_irq_cfg;
+
+typedef struct eoi_lvl_irq_stat_mach {
+    uint32_t irq_idx;
+
+    eoi_lvl_irq_cfg *cfg;
+
+    eoi_lvl_irq_stat stat;
+
+    AUTOBOARD_INTCState *s;
+
+    uint8_t on;
+    uint8_t act;
+    uint8_t msk;
+
+    uint32_t progs[EOI_LVL_ALL_EVT_NUM];
+
+    uint8_t (* is_evt_off) (struct eoi_lvl_irq_stat_mach *, auto_trifle *);
+    uint8_t (* is_evt_on) (struct eoi_lvl_irq_stat_mach *, auto_trifle *);
+    uint8_t (* is_evt_act) (struct eoi_lvl_irq_stat_mach *, auto_trifle *);
+    uint8_t (* is_evt_deact) (struct eoi_lvl_irq_stat_mach *, auto_trifle *);
+    uint8_t (* is_evt_eoi) (struct eoi_lvl_irq_stat_mach *, auto_trifle *);
+    uint8_t (* is_evt_msk) (struct eoi_lvl_irq_stat_mach *, auto_trifle *);
+    uint8_t (* is_evt_unmsk) (struct eoi_lvl_irq_stat_mach *, auto_trifle *);
+    uint8_t (* is_evt_reset) (struct eoi_lvl_irq_stat_mach *, auto_trifle *);
+    uint8_t (* is_evt_init) (struct eoi_lvl_irq_stat_mach *, auto_trifle *);
+
+    bool (* is_acted) (struct eoi_lvl_irq_stat_mach *);
+    uint8_t (* do_act) (struct eoi_lvl_irq_stat_mach *, auto_trifle *);
+    uint8_t (* do_deact) (struct eoi_lvl_irq_stat_mach *, auto_trifle *);
+
+    void (* handle_event)(struct eoi_lvl_irq_stat_mach *, eoi_lvl_irq_event);
+    int (* dispatch)(struct eoi_lvl_irq_stat_mach *, auto_trifle *);
+
+} eoi_lvl_irq_stat_mach;
+
+eoi_lvl_irq_stat_mach *init_eoi_lvl_irq_stat_mach(AUTOBOARD_INTCState *s, uint32_t cfg_idx);
+
+#endif /* TYPE_AUTOBOARD_EOI_LVL_IRQ_H */
\ No newline at end of file
diff -rNu qemu-2.3.0.orig/include/hw/intc/autoboard_intc.h qemu-2.3.0/include/hw/intc/autoboard_intc.h
--- qemu-2.3.0.orig/include/hw/intc/autoboard_intc.h	1970-01-01 00:00:00.000000000 +0000
+++ qemu-2.3.0/include/hw/intc/autoboard_intc.h	2020-08-10 11:21:11.615585455 +0000
@@ -0,0 +1,115 @@
+/*
+ * autoboard intc header file
+ */
+
+#ifndef TYPE_AUTOBOARD_INTC_H
+#define TYPE_AUTOBOARD_INTC_H
+
+#include "hw/sysbus.h"
+#include "hw/intc/autoboard_intc_utils.h"
+#include "hw/misc/autoboard_utils.h"
+
+#define TYPE_AUTOBOARD_INTC "autoboard_intc"
+#define AUTOBOARD_INTC(obj) \
+    OBJECT_CHECK(AUTOBOARD_INTCState, (obj), TYPE_AUTOBOARD_INTC)
+
+typedef enum {
+    STAT_MACH_IRQ_EMPTY = 0,
+    STAT_MACH_IRQ_LEVEL,
+    STAT_MACH_IRQ_EDGE,
+    STAT_MACH_IRQ_EOI_LVL,
+} autoboard_irq_stat_mach_type;
+
+typedef struct irq_bundle {
+    autoboard_irq_stat_mach_type    type;
+    void                            *stat_mach;
+} irq_bundle;
+
+typedef enum {
+    AUTOBOARD_INTC_INVALID = -1,
+    AUTOBOARD_INTC_RAMIPS_RT3883,
+    AUTOBOARD_INTC_ATH79_GENERIC,
+    AUTOBOARD_INTC_KIRKWOOD_GENERIC_ORION,
+    AUTOBOARD_INTC_KIRKWOOD_GENERIC_BRIDGE,
+    AUTOBOARD_INTC_OXNAS_GENERIC_GIC,
+    AUTOBOARD_INTC_NUM,
+} autoboard_intc_cfg_id;
+
+typedef struct auto_config_one_irq {
+    // this chooses the state machine that irq belongs to
+    uint8_t irq_type;
+    void *irq_stat_mach_cfg;
+} auto_config_one_irq;
+
+typedef struct auto_one_intc_cfg {
+    auto_config_one_irq *irq_cfgs;
+    uint32_t *mm_lens;
+    uint32_t mm_amount;
+    uint32_t irq_num;
+} auto_one_intc_cfg;
+
+typedef struct AUTOBOARD_INTCState {
+    /*< private >*/
+    SysBusDevice sys_bus;
+
+    /*< public >*/
+
+    /*
+     * currently act irq idx
+     */ 
+    int32_t act_irq;
+
+    /*
+     * string tag used for labeling intc in log
+     */
+    const char *name;
+
+    /*
+     * cfg pointer for autoboard intc
+     */
+    struct auto_one_intc_cfg *cfg;
+
+    /*
+     * amount of memory region
+     */
+    int32_t mm_amount;
+
+    /*
+     * mmio is the memory layout of the ic
+     */
+    MemoryRegion *mmios;
+
+    /*
+     * cache of the mmio, internal read & write should use this
+     */
+    autoboard_mmio *aummios;
+
+    /* 
+     * Output to the parent device, usually cpu 
+     * 
+     * Currently we only use 1 irq connected to the outside
+     * however, we could have more than 1 irq line connected with cpu
+     * 
+     * For out irq:
+     * - each out irq has a list of in irqs
+     * - each out irq has an index number as its position in the list and
+     *     which cpu irq it will connect to
+     * 
+     * We also prepared several list of in irqs connected to devices:
+     * - each list of in irqs has name CPU_X which X is the index of the out irq
+     * 
+     */
+    qemu_irq irq;
+
+    /* 
+     * internal state for every interrupt source 
+     */
+    uint32_t in_irq_num;
+    irq_bundle *in_irqs;
+
+} AUTOBOARD_INTCState;
+
+// this needs to be called before real initialization of an autoboard intc instance
+void set_autoboard_intc_cfg(autoboard_intc_cfg_id id, const char *name);
+
+#endif /* TYPE_AUTOBOARD_INTC_H */
\ No newline at end of file
diff -rNu qemu-2.3.0.orig/include/hw/intc/autoboard_intc_gen.h qemu-2.3.0/include/hw/intc/autoboard_intc_gen.h
--- qemu-2.3.0.orig/include/hw/intc/autoboard_intc_gen.h	1970-01-01 00:00:00.000000000 +0000
+++ qemu-2.3.0/include/hw/intc/autoboard_intc_gen.h	2020-08-10 11:21:11.615585455 +0000
@@ -0,0 +1,67 @@
+/*
+ * autoboard intc auto-generated header file
+ */
+
+#ifndef TYPE_AUTOBOARD_INTC_GEN_H
+#define TYPE_AUTOBOARD_INTC_GEN_H
+
+#include "hw/intc/autoboard_intc.h"
+#include "hw/intc/autoboard_intc_utils.h"
+#include "hw/misc/autoboard_utils.h"
+
+// type for acu
+// acu is for auto config unit
+#define ACU_DO_INVALID      0
+#define ACU_DO_WATCH_READ   (1 << 0)
+#define ACU_DO_WATCH_WRITE  (1 << 1)
+#define ACU_DO_WATCH_HWEVT (1 << 2)
+#define ACU_DO_REACT        (1 << 3)
+
+#define ACU_IS_DO_WATCH(d)  ((d) & (ACU_DO_WATCH_READ | ACU_DO_WATCH_WRITE | ACU_DO_WATCH_HWEVT))
+#define ACU_IS_DO_KER_WATCH(d)  ((d) & (ACU_DO_WATCH_READ | ACU_DO_WATCH_WRITE))
+#define ACU_IS_DO_HW_WATCH(d)  ((d) & (ACU_DO_WATCH_HWEVT))
+#define ACU_IS_DO_REACT(d)  ((d) & (ACU_DO_REACT))
+
+// status for acu func result
+// done with right reaction or match an event
+#define ACU_ST_DONE      0
+// not match
+#define ACU_ST_MISMATCH  1
+// in progress
+#define ACU_ST_NEXT      2
+
+struct auto_config_unit;
+
+typedef uint8_t (* acu_func) (AUTOBOARD_INTCState *s, struct auto_config_unit *, auto_trifle *);
+
+typedef struct auto_config_unit {
+    uint8_t type;
+
+    uint32_t midx;
+    uint32_t moff;
+
+    uint32_t irq;
+
+    uint32_t hw_evt;
+
+    // this function actually returns true/false
+    acu_func match_write_cnt;
+    // this function actually returns nothing
+    acu_func do_react;
+
+    uint32_t next;
+} auto_config_unit;
+
+typedef struct auto_config_action {
+    // progress
+    uint32_t prog;
+
+    auto_config_unit acus[];
+} auto_config_action;
+
+uint8_t intc_try_process_at_on_acu(AUTOBOARD_INTCState *s, auto_config_unit *acu, auto_trifle *at);
+
+// This init func should be called at the very beginning as it will init the above global variables
+auto_one_intc_cfg *get_autoboard_intc_config(autoboard_intc_cfg_id id);
+
+#endif /* TYPE_AUTOBOARD_INTC_GEN_H */
\ No newline at end of file
diff -rNu qemu-2.3.0.orig/include/hw/intc/autoboard_intc_utils.h qemu-2.3.0/include/hw/intc/autoboard_intc_utils.h
--- qemu-2.3.0.orig/include/hw/intc/autoboard_intc_utils.h	1970-01-01 00:00:00.000000000 +0000
+++ qemu-2.3.0/include/hw/intc/autoboard_intc_utils.h	2020-08-10 11:21:11.615585455 +0000
@@ -0,0 +1,9 @@
+/*
+ * autoboard intc common utility header file
+ */
+
+#ifndef TYPE_AUTOBOARD_INTC_UTILS_H
+#define TYPE_AUTOBOARD_INTC_UTILS_H
+
+
+#endif /* TYPE_AUTOBOARD_INTC_UTILS_H */
\ No newline at end of file
diff -rNu qemu-2.3.0.orig/include/hw/intc/autoboard_level_irq.h qemu-2.3.0/include/hw/intc/autoboard_level_irq.h
--- qemu-2.3.0.orig/include/hw/intc/autoboard_level_irq.h	1970-01-01 00:00:00.000000000 +0000
+++ qemu-2.3.0/include/hw/intc/autoboard_level_irq.h	2020-08-10 11:21:11.615585455 +0000
@@ -0,0 +1,109 @@
+/*
+ * autoboard level irq stat machine header file
+ */
+
+#ifndef TYPE_AUTOBOARD_LVL_IRQ_H
+#define TYPE_AUTOBOARD_LVL_IRQ_H
+
+#include "hw/sysbus.h"
+#include "hw/intc/autoboard_intc.h"
+#include "hw/intc/autoboard_intc_gen.h"
+#include "hw/intc/autoboard_intc_utils.h"
+#include "hw/misc/autoboard_utils.h"
+
+/*
+ * LEVEL IRQ STAT MACHINE
+ * 
+ * "-" means all the other events
+ * 
+ *       OFF  IDLE   ACT  MSK 
+ * OFF    -    on    on   on
+ * IDLE  off    -   act   msk
+ * ACT   off  deact   -   msk
+ * MSK   off  unmsk unmsk   -
+ * 
+ * on reset, set this irq to idle 
+ * on init, set this irq to idle if it is in off, otherwise no change?
+ * 
+ */
+typedef enum {
+    LVL_STAT_OFF = 0,
+    LVL_STAT_IDLE,
+    LVL_STAT_ACT,
+    LVL_STAT_MSK,
+    //LVL_STAT_ACK,
+    LVL_STAT_NUM,
+    LVL_STAT_INVALID = -1,
+} level_irq_stat;
+
+/*
+ * currently, we only found the case that msk/unmsk/init is watchable
+ * for evt on/off/reset, they are raised by the hardware
+ */
+typedef enum {
+    LVL_EVT_OFF = 0,
+    LVL_EVT_ON,
+    LVL_EVT_ACT,
+    LVL_EVT_DEACT,
+    LVL_EVT_MSK,
+    // Seems we don't need ack step in hardware as we didn't find any kernel code call ack solely
+    //LVL_EVT_ACK,
+    LVL_EVT_UNMSK,
+    LVL_EVT_RESET,
+    LVL_EVT_INIT,
+    LVL_HW_EVT_DOACT,
+    LVL_HW_EVT_DODEACT,
+    // The following are not valid events
+    LVL_ALL_EVT_NUM,
+    LVL_EVT_INVALID = -1,
+} level_irq_event;
+
+typedef struct level_irq_cfg {
+    auto_config_action *is_off;
+    auto_config_action *is_on;
+    auto_config_action *is_act;
+    auto_config_action *is_deact;
+    auto_config_action *is_msk;
+    auto_config_action *is_unmsk;
+    auto_config_action *is_reset;
+    auto_config_action *is_init;
+    auto_config_action *do_act;
+    auto_config_action *do_deact;
+} level_irq_cfg;
+
+typedef struct level_irq_stat_mach {
+    uint32_t irq_idx;
+
+    level_irq_cfg *cfg;
+
+    level_irq_stat stat;
+
+    AUTOBOARD_INTCState *s;
+
+    uint8_t on;
+    uint8_t act;
+    uint8_t msk;
+
+    uint32_t progs[LVL_ALL_EVT_NUM];
+
+    uint8_t (* is_evt_off) (struct level_irq_stat_mach *, auto_trifle *);
+    uint8_t (* is_evt_on) (struct level_irq_stat_mach *, auto_trifle *);
+    uint8_t (* is_evt_act) (struct level_irq_stat_mach *, auto_trifle *);
+    uint8_t (* is_evt_deact) (struct level_irq_stat_mach *, auto_trifle *);
+    uint8_t (* is_evt_msk) (struct level_irq_stat_mach *, auto_trifle *);
+    uint8_t (* is_evt_unmsk) (struct level_irq_stat_mach *, auto_trifle *);
+    uint8_t (* is_evt_reset) (struct level_irq_stat_mach *, auto_trifle *);
+    uint8_t (* is_evt_init) (struct level_irq_stat_mach *, auto_trifle *);
+
+    bool (* is_acted) (struct level_irq_stat_mach *);
+    uint8_t (* do_act) (struct level_irq_stat_mach *, auto_trifle *);
+    uint8_t (* do_deact) (struct level_irq_stat_mach *, auto_trifle *);
+
+    void (* handle_event)(struct level_irq_stat_mach *, level_irq_event);
+    int (* dispatch)(struct level_irq_stat_mach *, auto_trifle *);
+
+} level_irq_stat_mach;
+
+level_irq_stat_mach *init_level_irq_stat_mach(AUTOBOARD_INTCState *s, uint32_t cfg_idx);
+
+#endif /* TYPE_AUTOBOARD_LVL_IRQ_H */
\ No newline at end of file
diff -rNu qemu-2.3.0.orig/include/hw/loader.h qemu-2.3.0/include/hw/loader.h
--- qemu-2.3.0.orig/include/hw/loader.h	2015-04-27 14:08:25.000000000 +0000
+++ qemu-2.3.0/include/hw/loader.h	2020-08-10 11:32:02.292834145 +0000
@@ -65,6 +65,14 @@
 extern bool option_rom_has_mr;
 extern bool rom_file_has_mr;
 
+struct rom_hotfix_blob {
+   AddressSpace *as;
+   hwaddr addr;
+   uint64_t offset;
+   uint64_t size;
+   char *data;
+};
+
 int rom_add_file(const char *file, const char *fw_dir,
                  hwaddr addr, int32_t bootindex,
                  bool option_rom);
@@ -76,6 +84,7 @@
 int rom_load_all(void);
 void rom_load_done(void);
 void rom_set_fw(FWCfgState *f);
+void rom_hotfix_reset(void *opaque);
 int rom_copy(uint8_t *dest, hwaddr addr, size_t size);
 void *rom_ptr(hwaddr addr);
 void hmp_info_roms(Monitor *mon, const QDict *qdict);
diff -rNu qemu-2.3.0.orig/include/hw/mips/cpudevs.h qemu-2.3.0/include/hw/mips/cpudevs.h
--- qemu-2.3.0.orig/include/hw/mips/cpudevs.h	2015-04-27 14:08:25.000000000 +0000
+++ qemu-2.3.0/include/hw/mips/cpudevs.h	2020-08-10 13:06:17.740275780 +0000
@@ -2,6 +2,8 @@
 #define HW_MIPS_CPUDEVS_H
 /* Definitions for MIPS CPU internal devices.  */
 
+#include <hw/mips/mips.h>
+
 /* mips_addr.c */
 uint64_t cpu_mips_kseg0_to_phys(void *opaque, uint64_t addr);
 uint64_t cpu_mips_phys_to_kseg0(void *opaque, uint64_t addr);
@@ -14,4 +16,10 @@
 /* mips_timer.c */
 void cpu_mips_clock_init(CPUMIPSState *);
 
+void mips_load_kernel(MIPSCPU *cpu, struct mips_boot_info *info);
+
+typedef struct CommonResetData {
+    MIPSCPU *cpu;
+    uint64_t vector;
+} CommonResetData;
 #endif
diff -rNu qemu-2.3.0.orig/include/hw/mips/mips.h qemu-2.3.0/include/hw/mips/mips.h
--- qemu-2.3.0.orig/include/hw/mips/mips.h	2015-04-27 14:08:25.000000000 +0000
+++ qemu-2.3.0/include/hw/mips/mips.h	2020-08-10 12:48:55.759317853 +0000
@@ -3,7 +3,9 @@
 /* Definitions for mips board emulation.  */
 
 /* Kernels can be configured with 64KB pages */
-#define INITRD_PAGE_MASK (~((1 << 16) - 1))
+/* Considering BSS we enlarge the page align to 8MB */
+#define INITRD_PAGE_MASK (~((1 << 23) - 1))
+#define DTB_PAGE_MASK (~((1 << 12) -1))
 
 #include "exec/memory.h"
 
@@ -29,4 +31,24 @@
                   qemu_irq irq, void* mem_opaque,
                   void (*memory_rw)(void *opaque, hwaddr addr, uint8_t *buf, int len, int is_write));
 
+struct mips_boot_info;
+
+struct mips_boot_info {
+    int board_id;
+    uint64_t ram_size;
+    const char *kernel_filename;
+    const char *kernel_cmdline;
+    const char *initrd_filename;
+    const char *dtb_filename;
+    hwaddr dtb_start;
+    hwaddr dtb_offset;
+    hwaddr dtb_limit;
+    int is_linux;
+    hwaddr initrd_start;
+    hwaddr initrd_size;
+    hwaddr entry;
+};
+
+int mips_load_dtb(hwaddr addr, struct mips_boot_info *binfo,
+                  hwaddr addr_limit, AddressSpace *as);
 #endif
diff -rNu qemu-2.3.0.orig/include/hw/misc/autoboard_utils.h qemu-2.3.0/include/hw/misc/autoboard_utils.h
--- qemu-2.3.0.orig/include/hw/misc/autoboard_utils.h	1970-01-01 00:00:00.000000000 +0000
+++ qemu-2.3.0/include/hw/misc/autoboard_utils.h	2020-08-10 11:36:22.888388289 +0000
@@ -0,0 +1,93 @@
+/*
+ * autoboard timer common utility header file
+ */
+
+#ifndef TYPE_AUTOBOARD_UTILS_H
+#define TYPE_AUTOBOARD_UTILS_H
+
+#include "hw/sysbus.h"
+
+
+/*
+ * bit ops
+ */ 
+
+#define __bit(b) (1 << b)
+
+
+/*
+ * MMIO region related
+ */
+
+#define __u32_native(p) (*(uint32_t *) (p))
+#define __u32_big(p) \
+    ((uint32_t) \
+    (((*(uint8_t *) (p)) << 24) | \
+     ((*(uint8_t *) (p)) << 16) | \
+     ((*(uint8_t *) (p)) << 8) | \
+     ((*(uint8_t *) (p)) << 0)) )
+#define __u32_little(p) \
+    ((uint32_t) \
+    (((*(uint8_t *) (p)) << 0) | \
+     ((*(uint8_t *) (p)) << 8) | \
+     ((*(uint8_t *) (p)) << 16) | \
+     ((*(uint8_t *) (p)) << 24)) )
+
+#define __swap32(num) \
+    (((num)>>24)&0xff) | \
+    (((num)<<8)&0xff0000) | \
+    (((num)>>8)&0xff00) | \
+    (((num)<<24)&0xff000000)
+
+#define AUTOBOARD_MAKE_MMIO_RANGE_RW_FUNCS(name, idx) \
+static uint64_t autoboard_##name##_read_range##idx(void *opaque, hwaddr offset, unsigned size)\
+{\
+    return autoboard_##name##_read(opaque, offset, size, idx);\
+}\
+static void autoboard_##name##_write_range##idx(void *opaque, hwaddr offset, uint64_t val, unsigned size)\
+{\
+    autoboard_##name##_write(opaque, offset, val, size, idx);\
+}
+
+#define AUTOBOARD_MMIO_OPS_STATIC_STRUCT(name, idx) \
+    {\
+        .read = autoboard_##name##_read_range##idx,\
+        .write = autoboard_##name##_write_range##idx,\
+        .endianness = DEVICE_LITTLE_ENDIAN,\
+    },
+
+#define AUTOBOARD_INTC_MMIO_REGION_NUM 2
+#define AUTOBOARD_TIMER_MMIO_REGION_NUM 1
+
+typedef struct autoboard_mmio {
+    uint32_t mmio_len;
+    unsigned char *caches;
+    uint32_t (* read)(struct autoboard_mmio *mmio, hwaddr off);
+    uint32_t (* write)(struct autoboard_mmio *mmio, hwaddr off, uint64_t val);
+} autoboard_mmio;
+
+
+/*
+ * Definition of the trifle, presenting an outside event
+ */
+
+#define TRIFLE_INVALID       0
+#define TRIFLE_KER_READ      1
+#define TRIFLE_KER_WRITE     2
+#define TRIFLE_HW_EVT        3
+
+typedef struct auto_trifle {
+    int type;
+    // kernel read & write use the off & old value
+    // this specifies the index of mmio regions
+    uint32_t mmio_idx;
+    hwaddr off;
+    uint64_t old_val;
+    // only kernel write use the new value
+    uint64_t new_val;
+    // onlt hw event use the following
+    uint32_t hw_evt;
+    uint32_t evt_arg;
+} auto_trifle;
+
+#endif /* TYPE_AUTOBOARD_UTILS_H */
\ No newline at end of file
diff -rNu qemu-2.3.0.orig/include/hw/timer/autoboard_clkevt.h qemu-2.3.0/include/hw/timer/autoboard_clkevt.h
--- qemu-2.3.0.orig/include/hw/timer/autoboard_clkevt.h	1970-01-01 00:00:00.000000000 +0000
+++ qemu-2.3.0/include/hw/timer/autoboard_clkevt.h	2020-08-10 11:22:35.445872736 +0000
@@ -0,0 +1,114 @@
+/*
+ * autoboard timer clock event device stat machine header file
+ */
+
+#ifndef TYPE_AUTOBOARD_CLKDEV_H
+#define TYPE_AUTOBOARD_CLKDEV_H
+
+#include "hw/sysbus.h"
+#include "hw/timer/autoboard_timer.h"
+#include "hw/timer/autoboard_timer_gen.h"
+#include "hw/timer/autoboard_timer_utils.h"
+#include "hw/misc/autoboard_utils.h"
+
+/*
+ * CLKEVT STAT MACHINE
+ * 
+ * "-" means all the other events
+ * 
+ *             OFF   UNUSED  PERIO  ONESHOT 
+ * OFF                                     
+ * UNUSED                                  
+ * PERIO                                  
+ * ONESHOT                                
+ * 
+ */
+typedef enum {
+    CLKEVT_STAT_OFF = 0,
+    CLKEVT_STAT_UNUSED,
+    CLKEVT_STAT_PERIODIC,
+    CLKEVT_STAT_ONESHOT,
+    // TODO: for ACK EVT, actually the behaviors are different when 
+    //       clkevt device works on different stats (oneshot/perio/...)
+    //       we should consider introduce more detail stats to supp this when free
+    //       now there only has timer running on periodic mode as far as I know
+    CLKEVT_STAT_NUM,
+    CLKEVT_STAT_INVALID = -1,
+} clkevt_stat;
+
+/*
+ * 
+ */
+typedef enum {
+    CLKEVT_EVT_OFF = 0,
+    CLKEVT_EVT_ON,
+    CLKEVT_EVT_INIT,
+    CLKEVT_EVT_RESET,
+    CLKEVT_EVT_SET_UNUSED,
+    CLKEVT_EVT_SET_PERIO,
+    CLKEVT_EVT_SET_ONESHOT,
+    CLKEVT_EVT_ACK,
+    CLKEVT_EVT_ONESHOT_SET_NEXT,
+    CLKEVT_HW_EVT_ONE_CYCLE,
+    // The following are not valid events
+    CLKEVT_ALL_EVT_NUM,
+    CLKEVT_EVT_INVALID = -1,
+} clkevt_event;
+
+typedef struct clkevt_cfg {
+    auto_config_action *is_off;
+    auto_config_action *is_on;
+    auto_config_action *is_init;
+    auto_config_action *is_reset;
+    auto_config_action *is_set_unused;
+    auto_config_action *is_set_perio;
+    auto_config_action *is_set_oneshot;
+    auto_config_action *is_ack;
+    auto_config_action *is_oneshot_set_next;
+} clkevt_cfg;
+
+typedef struct clkevt_stat_mach {
+    uint32_t clk_idx;
+
+    const char *name;
+
+    clkevt_cfg *cfg;
+
+    clkevt_stat stat;
+
+    AUTOBOARD_TIMERState *s;
+
+    bool on;
+    bool enable;
+    bool repeat;
+
+    uint32_t delta;
+    uint32_t load;
+    uint32_t countdown;
+
+    uint32_t step;
+
+    uint32_t progs[CLKEVT_ALL_EVT_NUM];
+
+    uint8_t (* is_evt_off) (struct clkevt_stat_mach *, auto_trifle *);
+    uint8_t (* is_evt_on) (struct clkevt_stat_mach *, auto_trifle *);
+    uint8_t (* is_evt_init) (struct clkevt_stat_mach *, auto_trifle *);
+    uint8_t (* is_evt_reset) (struct clkevt_stat_mach *, auto_trifle *);
+    uint8_t (* is_evt_set_unused) (struct clkevt_stat_mach *, auto_trifle *);
+    uint8_t (* is_evt_set_perio) (struct clkevt_stat_mach *, auto_trifle *);
+    uint8_t (* is_evt_set_oneshot) (struct clkevt_stat_mach *, auto_trifle *);
+    uint8_t (* is_evt_ack) (struct clkevt_stat_mach *, auto_trifle *);
+    uint8_t (* is_evt_oneshot_set_next) (struct clkevt_stat_mach *, auto_trifle *);
+
+    void (* act_irq) (AUTOBOARD_TIMERState *s);
+    void (* deact_irq) (AUTOBOARD_TIMERState *s);
+
+    void (* handle_event)(struct clkevt_stat_mach *, clkevt_event);
+    int (* dispatch)(struct clkevt_stat_mach *, auto_trifle *);
+
+    void (* pass_one_cycle)(struct clkevt_stat_mach *);
+} clkevt_stat_mach;
+
+clkevt_stat_mach *init_clkevt_stat_mach(AUTOBOARD_TIMERState *s, uint32_t cfg_idx);
+
+#endif /* TYPE_AUTOBOARD_CLKDEV_H */
\ No newline at end of file
diff -rNu qemu-2.3.0.orig/include/hw/timer/autoboard_clksrc.h qemu-2.3.0/include/hw/timer/autoboard_clksrc.h
--- qemu-2.3.0.orig/include/hw/timer/autoboard_clksrc.h	1970-01-01 00:00:00.000000000 +0000
+++ qemu-2.3.0/include/hw/timer/autoboard_clksrc.h	2020-08-10 11:22:35.445872736 +0000
@@ -0,0 +1,90 @@
+/*
+ * autoboard timer clock source device stat machine header file
+ */
+
+#ifndef TYPE_AUTOBOARD_CLKSRC_H
+#define TYPE_AUTOBOARD_CLKSRC_H
+
+#include "hw/sysbus.h"
+#include "hw/timer/autoboard_timer.h"
+#include "hw/timer/autoboard_timer_gen.h"
+#include "hw/timer/autoboard_timer_utils.h"
+#include "hw/misc/autoboard_utils.h"
+
+/*
+ * CLKSRC STAT MACHINE
+ * 
+ * "-" means all the other events
+ * 
+ *             OFF   UNUSED  PERIO  ONESHOT 
+ * OFF                                     
+ * UNUSED                                  
+ * PERIO                                  
+ * ONESHOT                                
+ * 
+ */
+typedef enum {
+    CLKSRC_STAT_OFF = 0,
+    CLKSRC_STAT_RUN,
+    CLKSRC_STAT_NUM,
+    CLKSRC_STAT_INVALID = -1,
+} clksrc_stat;
+
+/*
+ * 
+ */
+typedef enum {
+    CLKSRC_EVT_OFF = 0,
+    CLKSRC_EVT_ON,
+    CLKSRC_EVT_INIT,
+    CLKSRC_EVT_RESET,
+    CLKSRC_EVT_KERNEL_READ,
+    CLKSRC_HW_EVT_ONE_CYCLE,
+    // The following are not valid events
+    CLKSRC_ALL_EVT_NUM,
+    CLKSRC_EVT_INVALID = -1,
+} clksrc_event;
+
+typedef struct clksrc_cfg {
+    bool increment;
+    auto_config_action *is_off;
+    auto_config_action *is_on;
+    auto_config_action *is_init;
+    auto_config_action *is_reset;
+    auto_config_action *is_kernel_read;
+} clksrc_cfg;
+
+typedef struct clksrc_stat_mach {
+    uint32_t clk_idx;
+
+    const char *name;
+
+    clksrc_cfg *cfg;
+
+    clksrc_stat stat;
+
+    AUTOBOARD_TIMERState *s;
+
+    bool on;
+    bool increment;
+
+    uint32_t delta;
+    uint64_t cycles;
+
+    uint32_t progs[CLKSRC_ALL_EVT_NUM];
+
+    uint8_t (* is_evt_off) (struct clksrc_stat_mach *, auto_trifle *);
+    uint8_t (* is_evt_on) (struct clksrc_stat_mach *, auto_trifle *);
+    uint8_t (* is_evt_init) (struct clksrc_stat_mach *, auto_trifle *);
+    uint8_t (* is_evt_reset) (struct clksrc_stat_mach *, auto_trifle *);
+    uint8_t (* is_kernel_read) (struct clksrc_stat_mach *, auto_trifle *);
+
+    void (* handle_event)(struct clksrc_stat_mach *, clksrc_event);
+    int (* dispatch)(struct clksrc_stat_mach *, auto_trifle *);
+
+    void (* pass_one_cycle)(struct clksrc_stat_mach *);
+} clksrc_stat_mach;
+
+clksrc_stat_mach *init_clksrc_stat_mach(AUTOBOARD_TIMERState *s, uint32_t cfg_idx);
+
+#endif /* TYPE_AUTOBOARD_CLKSRC_H */
\ No newline at end of file
diff -rNu qemu-2.3.0.orig/include/hw/timer/autoboard_timer.h qemu-2.3.0/include/hw/timer/autoboard_timer.h
--- qemu-2.3.0.orig/include/hw/timer/autoboard_timer.h	1970-01-01 00:00:00.000000000 +0000
+++ qemu-2.3.0/include/hw/timer/autoboard_timer.h	2020-08-10 11:22:35.445872736 +0000
@@ -0,0 +1,109 @@
+/*
+ * autoboard timer header file
+ */
+
+#ifndef TYPE_AUTOBOARD_TIMER_H
+#define TYPE_AUTOBOARD_TIMER_H
+
+#include "hw/sysbus.h"
+#include "qemu/timer.h"
+#include "hw/timer/autoboard_timer_utils.h"
+#include "hw/misc/autoboard_utils.h"
+
+#define TYPE_AUTOBOARD_TIMER "autoboard_timer"
+#define AUTOBOARD_TIMER(obj) \
+    OBJECT_CHECK(AUTOBOARD_TIMERState, (obj), TYPE_AUTOBOARD_TIMER)
+
+//#define AUTOBOARD_TIMER_NS_PER_CYCLE 4096
+// 100 HZ, this now only used for clkevt
+#define AUTOBOARD_TIMER_NS_PER_CYCLE 10000000
+
+typedef enum {
+    STAT_MACH_CLKDEV_EMPTY = 0,
+    STAT_MACH_CLKDEV_EVENT,
+    STAT_MACH_CLKDEV_SOURCE,
+} autoboard_clkdev_stat_mach_type;
+
+typedef struct timer_bundle {
+    autoboard_clkdev_stat_mach_type     type;
+    void                                *stat_mach;
+} timer_bundle;
+
+typedef enum {
+    AUTOBOARD_TIMER_INVALID = -1,
+    AUTOBOARD_TIMER_MARVELL_ORION,
+    AUTOBOARD_TIMER_OXNAS_GENERIC_RPS,
+    AUTOBOARD_TIMER_OXNAS_GENERIC_MPTIMER,
+    AUTOBOARD_TIMER_NUM,
+} autoboard_timer_cfg_id;
+
+typedef struct auto_config_one_timer {
+    // this chooses the state machine that timer belongs to
+    uint8_t timer_type;
+    void *timer_stat_mach_cfg;
+} auto_config_one_timer;
+
+typedef struct auto_one_timer_cfg {
+    auto_config_one_timer *timer_cfgs;
+    uint32_t *mm_lens;
+    uint32_t mm_amount;
+    bool is_level_irq;
+    uint32_t ns_per_cycle;
+    uint32_t clkdev_num;
+} auto_one_timer_cfg;
+
+typedef struct AUTOBOARD_TIMERState {
+    /*< private >*/
+    SysBusDevice sys_bus;
+
+    /*< public >*/
+
+    /*
+     * string tag used for labeling intc in log
+     */
+    const char *name;
+
+    /*
+     * cfg pointer for autoboard timer
+     */
+    struct auto_one_timer_cfg *cfg;
+
+    /*
+     * amount of memory region
+     */
+    int32_t mm_amount;
+
+    /*
+     * mmio is the memory layout of the timer
+     */
+    MemoryRegion *mmios;
+
+    /*
+     * cache of the mmio, internal read & write should use this
+     */
+    autoboard_mmio *aummios;
+
+    /* the inner timer */
+    QEMUTimer *timer;
+    // this is inited as the lowest multiply of s->cfg->ns_per_cycle 
+    //         which is greater than AUTOBOARD_TIMER_NS_PER_CYCLE
+    uint32_t ns_per_cycle;
+    uint64_t last_tick;
+    uint64_t first_tick_off;
+
+    /* out irq of the timer */
+    qemu_irq irq;
+    bool is_level_irq;
+    void (* act_irq) (struct AUTOBOARD_TIMERState *s);
+    void (* deact_irq) (struct AUTOBOARD_TIMERState *s);
+
+    /* clock devices */
+    uint32_t clkdev_num;
+    timer_bundle *clkdevs;
+
+} AUTOBOARD_TIMERState;
+
+// this needs to be called before real initialization of an autoboard timer instance
+void set_autoboard_timer_cfg(autoboard_timer_cfg_id id, const char *name);
+
+#endif /* TYPE_AUTOBOARD_TIMER_H */
\ No newline at end of file
diff -rNu qemu-2.3.0.orig/include/hw/timer/autoboard_timer_gen.h qemu-2.3.0/include/hw/timer/autoboard_timer_gen.h
--- qemu-2.3.0.orig/include/hw/timer/autoboard_timer_gen.h	1970-01-01 00:00:00.000000000 +0000
+++ qemu-2.3.0/include/hw/timer/autoboard_timer_gen.h	2020-08-10 11:22:35.445872736 +0000
@@ -0,0 +1,67 @@
+/*
+ * autoboard timer auto-generated header file
+ */
+
+#ifndef TYPE_AUTOBOARD_TIMER_GEN_H
+#define TYPE_AUTOBOARD_TIMER_GEN_H
+
+#include "hw/timer/autoboard_timer.h"
+#include "hw/timer/autoboard_timer_utils.h"
+#include "hw/misc/autoboard_utils.h"
+
+// type for acu
+// acu is for auto config unit
+#define ACU_DO_INVALID      0
+#define ACU_DO_WATCH_READ   (1 << 0)
+#define ACU_DO_WATCH_WRITE  (1 << 1)
+#define ACU_DO_WATCH_HWEVT (1 << 2)
+#define ACU_DO_REACT        (1 << 3)
+
+#define ACU_IS_DO_WATCH(d)  ((d) & (ACU_DO_WATCH_READ | ACU_DO_WATCH_WRITE | ACU_DO_WATCH_HWEVT))
+#define ACU_IS_DO_KER_WATCH(d)  ((d) & (ACU_DO_WATCH_READ | ACU_DO_WATCH_WRITE))
+#define ACU_IS_DO_HW_WATCH(d)  ((d) & (ACU_DO_WATCH_HWEVT))
+#define ACU_IS_DO_REACT(d)  ((d) & (ACU_DO_REACT))
+
+// status for acu func result
+// done with right reaction or match an event
+#define ACU_ST_DONE      0
+// not match
+#define ACU_ST_MISMATCH  1
+// in progress
+#define ACU_ST_NEXT      2
+
+struct auto_config_unit;
+
+typedef uint8_t (* acu_func) (AUTOBOARD_TIMERState *s, struct auto_config_unit *, auto_trifle *);
+
+typedef struct auto_config_unit {
+    uint8_t type;
+
+    uint32_t midx;
+    uint32_t moff;
+
+    uint32_t irq;
+
+    uint32_t hw_evt;
+
+    // this function actually returns true/false
+    acu_func match_write_cnt;
+    // this function actually returns nothing
+    acu_func do_react;
+
+    uint32_t next;
+} auto_config_unit;
+
+typedef struct auto_config_action {
+    // progress
+    uint32_t prog;
+
+    auto_config_unit acus[];
+} auto_config_action;
+
+uint8_t timer_try_process_at_on_acu(AUTOBOARD_TIMERState *s, auto_config_unit *acu, auto_trifle *at);
+
+// This init func should be called at the very beginning as it will init the above global variables
+auto_one_timer_cfg *get_autoboard_timer_config(autoboard_timer_cfg_id id);
+
+#endif /* TYPE_AUTOBOARD_TIMER_GEN_H */
\ No newline at end of file
diff -rNu qemu-2.3.0.orig/include/hw/timer/autoboard_timer_utils.h qemu-2.3.0/include/hw/timer/autoboard_timer_utils.h
--- qemu-2.3.0.orig/include/hw/timer/autoboard_timer_utils.h	1970-01-01 00:00:00.000000000 +0000
+++ qemu-2.3.0/include/hw/timer/autoboard_timer_utils.h	2020-08-10 11:22:35.445872736 +0000
@@ -0,0 +1,9 @@
+/*
+ * autoboard timer common utility header file
+ */
+
+#ifndef TYPE_AUTOBOARD_TIMER_UTILS_H
+#define TYPE_AUTOBOARD_TIMER_UTILS_H
+
+
+#endif /* TYPE_AUTOBOARD_TIMER_UTILS_H */
\ No newline at end of file
diff -rNu qemu-2.3.0.orig/target-arm/cpu.c qemu-2.3.0/target-arm/cpu.c
--- qemu-2.3.0.orig/target-arm/cpu.c	2015-04-27 14:08:26.000000000 +0000
+++ qemu-2.3.0/target-arm/cpu.c	2020-08-10 12:24:35.839213649 +0000
@@ -565,6 +565,25 @@
 /* CPU models. These are not needed for the AArch64 linux-user build. */
 #if !defined(CONFIG_USER_ONLY) || !defined(TARGET_AARCH64)
 
+static void feroceon_initfn(Object *obj)
+{
+    ARMCPU *cpu = ARM_CPU(obj);
+     
+    cpu->dtb_compatible = "marvell,feroceon";
+    set_feature(&cpu->env, ARM_FEATURE_V5);
+    set_feature(&cpu->env, ARM_FEATURE_VFP);
+    set_feature(&cpu->env, ARM_FEATURE_DUMMY_C15_REGS);
+    set_feature(&cpu->env, ARM_FEATURE_CACHE_TEST_CLEAN);
+    cpu->midr = 0x56055310; // 88fr531
+    /* others
+     * cpu->midr = 0x56155710; // 88fr731
+     * cpu->midr = 0x56151310; // 88fr131
+     */
+    cpu->reset_fpsid = 0x41011090;
+    cpu->ctr = 0x1dd20d2;
+    cpu->reset_sctlr = 0x00090078;
+}
+
 static void arm926_initfn(Object *obj)
 {
     ARMCPU *cpu = ARM_CPU(obj);
@@ -1150,6 +1169,7 @@
 
 static const ARMCPUInfo arm_cpus[] = {
 #if !defined(CONFIG_USER_ONLY) || !defined(TARGET_AARCH64)
+    { .name = "feroceon",    .initfn = feroceon_initfn }, /* same as arm926 except cpuid */
     { .name = "arm926",      .initfn = arm926_initfn },
     { .name = "arm946",      .initfn = arm946_initfn },
     { .name = "arm1026",     .initfn = arm1026_initfn },
