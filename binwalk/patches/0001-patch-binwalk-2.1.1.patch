From fba78dca9bebe5094268aa75b41653617052a777 Mon Sep 17 00:00:00 2001
From: cyrus <cyruscyliu@gmail.com>
Date: Tue, 3 Sep 2019 19:29:40 +0800
Subject: [PATCH] patch binwalk-2.1.1

---
 src/binwalk/core/magic.py            | 326 +++++++++++++++++++++--------------
 src/binwalk/magic/firmware           |  28 +++
 src/binwalk/modules/general.py       |  44 ++---
 src/binwalk/plugins/uimageextract.py |  23 +++
 src/scripts/extract_uimage.py        |  11 ++
 5 files changed, 287 insertions(+), 145 deletions(-)
 create mode 100644 src/binwalk/plugins/uimageextract.py
 create mode 100644 src/scripts/extract_uimage.py

diff --git a/src/binwalk/core/magic.py b/src/binwalk/core/magic.py
index 0c398a4..a7a0757 100644
--- a/src/binwalk/core/magic.py
+++ b/src/binwalk/core/magic.py
@@ -9,17 +9,14 @@ import struct
 import datetime
 import binwalk.core.common
 import binwalk.core.compat
+from binwalk.core.exceptions import ParserException
 
-class ParserException(Exception):
-    '''
-    Exception thrown specifically for signature file parsing errors.
-    '''
-    pass
 
 class SignatureResult(binwalk.core.module.Result):
     '''
     Container class for signature results.
     '''
+
     def __init__(self, **kwargs):
         # These are set by signature keyword tags.
         # Keyword tags can also set any other object attributes,
@@ -32,6 +29,7 @@ class SignatureResult(binwalk.core.module.Result):
         self.invalid = False
         self.once = False
         self.overlap = False
+        self.end = False
 
         # These are set by code internally
         self.id = 0
@@ -41,6 +39,7 @@ class SignatureResult(binwalk.core.module.Result):
 
         self.valid = (not self.invalid)
 
+
 class SignatureLine(object):
     '''
     Responsible for parsing signature lines from magic signature files.
@@ -106,16 +105,19 @@ class SignatureLine(object):
                 self.operator = operator
 
                 # Try to convert the operator value into an integer. This works for
-                # simple operator values, but not for complex types (e.g., '(4.l+12)').
+                # simple operator values, but not for complex types (e.g.,
+                # '(4.l+12)').
                 try:
                     self.opvalue = int(self.opvalue, 0)
                 except ValueError as e:
                     pass
 
-                # Only one operator type is supported, so break as soon as one is found
+                # Only one operator type is supported, so break as soon as one
+                # is found
                 break
 
-        # If the specified type starts with 'u' (e.g., 'ubelong'), then it is unsigned; else, it is signed
+        # If the specified type starts with 'u' (e.g., 'ubelong'), then it is
+        # unsigned; else, it is signed
         if self.type[0] == 'u':
             self.signed = False
             self.type = self.type[1:]
@@ -123,16 +125,17 @@ class SignatureLine(object):
             self.signed = True
 
         # Big endian values start with 'be' ('belong'), little endian values start with 'le' ('lelong').
-        # The struct module uses '>' to denote big endian and '<' to denote little endian.
+        # The struct module uses '>' to denote big endian and '<' to denote
+        # little endian.
         if self.type.startswith('be'):
             self.type = self.type[2:]
-            self.endianess = '>'
+            self.endianness = '>'
         elif self.type.startswith('le'):
-            self.endianess = '<'
+            self.endianness = '<'
             self.type = self.type[2:]
-        # Assume big endian if no endianess was explicitly specified
+        # Assume big endian if no endianness was explicitly specified
         else:
-            self.endianess = '>'
+            self.endianness = '>'
 
         # Check the comparison value for the type of comparison to be performed (e.g.,
         # '=0x1234', '>0x1234', etc). If no operator is specified, '=' is implied.
@@ -146,9 +149,11 @@ class SignatureLine(object):
         # If this is a wildcard value, explicitly set self.value to None
         if self.value == 'x':
             self.value = None
-        # String values need to be decoded, as they may contain escape characters (e.g., '\x20')
+        # String values need to be decoded, as they may contain escape
+        # characters (e.g., '\x20')
         elif self.type == 'string':
-            # String types support multiplication to easily match large repeating byte sequences
+            # String types support multiplication to easily match large
+            # repeating byte sequences
             if '*' in self.value:
                 try:
                     p = self.value.split('*')
@@ -158,7 +163,8 @@ class SignatureLine(object):
                 except KeyboardInterrupt as e:
                     raise e
                 except Exception as e:
-                    raise ParserException("Failed to expand string '%s' with integer '%s' in line '%s'" % (self.value, n, line))
+                    raise ParserException(
+                        "Failed to expand string '%s' with integer '%s' in line '%s'" % (self.value, n, line))
             try:
                 self.value = binwalk.core.compat.string_decode(self.value)
             except ValueError as e:
@@ -180,26 +186,32 @@ class SignatureLine(object):
             except ValueError as e:
                 raise ParserException("Failed to convert value '%s' to an integer on line '%s'" % (self.value, line))
 
-        # Sanity check to make sure the first line of a signature has an explicit value
+        # Sanity check to make sure the first line of a signature has an
+        # explicit value
         if self.level == 0 and self.value is None:
             raise ParserException("First element of a signature must specify a non-wildcard value: '%s'" % (line))
 
         # Set the size and struct format value for the specified data type.
-        # This must be done, obviously, after the value has been parsed out above.
+        # This must be done, obviously, after the value has been parsed out
+        # above.
         if self.type == 'string':
-            # Strings don't have a struct format value, since they don't have to be unpacked
+            # Strings don't have a struct format value, since they don't have
+            # to be unpacked
             self.fmt = None
 
-            # If a string type has a specific value, set the comparison size to the length of that string
+            # If a string type has a specific value, set the comparison size to
+            # the length of that string
             if self.value:
                 self.size = len(self.value)
             # Else, truncate the string to self.MAX_STRING_SIZE
             else:
                 self.size = self.MAX_STRING_SIZE
         elif self.type == 'regex':
-            # Regular expressions don't have a struct format value, since they don't have to be unpacked
+            # Regular expressions don't have a struct format value, since they
+            # don't have to be unpacked
             self.fmt = None
-            # The size of a matching regex is unknown until it is applied to some data
+            # The size of a matching regex is unknown until it is applied to
+            # some data
             self.size = self.MAX_STRING_SIZE
         elif self.type == 'byte':
             self.fmt = 'b'
@@ -210,10 +222,12 @@ class SignatureLine(object):
         elif self.type == 'quad':
             self.fmt = 'q'
             self.size = 8
-        # Assume 4 byte length for all other data types
-        else:
+        # Assume 4 byte length for all other supported data types
+        elif self.type in ['long', 'date']:
             self.fmt = 'i'
             self.size = 4
+        else:
+            raise ParserException("Unknown data type '%s' in line '%s'" % (self.type, line))
 
         # The struct module uses the same characters for specifying signed and unsigned data types,
         # except that signed data types are upper case. The above if-else code sets self.fmt to the
@@ -222,9 +236,9 @@ class SignatureLine(object):
             self.fmt = self.fmt.upper()
 
         # If a struct format was identified, create a format string to be passed to struct.unpack
-        # which specifies the endianess and data type format.
+        # which specifies the endianness and data type format.
         if self.fmt:
-            self.pkfmt = '%c%c' % (self.endianess, self.fmt)
+            self.pkfmt = '%c%c' % (self.endianness, self.fmt)
         else:
             self.pkfmt = None
 
@@ -241,7 +255,8 @@ class SignatureLine(object):
                 # Get rid of the curly braces.
                 tag = match.group().replace('{', '').replace('}', '')
 
-                # If the tag specifies a value, it will be colon delimited (e.g., '{name:%s}')
+                # If the tag specifies a value, it will be colon delimited
+                # (e.g., '{name:%s}')
                 if ':' in tag:
                     (n, v) = tag.split(':', 1)
                 else:
@@ -256,22 +271,23 @@ class SignatureLine(object):
         else:
             self.format = ""
 
+
 class Signature(object):
     '''
     Class to hold signature data and generate signature regular expressions.
     '''
 
-    def __init__(self, id, first_line):
+    def __init__(self, sid, first_line):
         '''
         Class constructor.
 
-        @id         - A ID value to uniquely identify this signature.
+        @sid        - A ID value to uniquely identify this signature.
         @first_line - The first SignatureLine of the signature (subsequent
                       SignatureLines should be added via self.append).
 
         Returns None.
         '''
-        self.id = id
+        self.id = sid
         self.lines = [first_line]
         self.title = first_line.format
         self.offset = first_line.offset
@@ -294,7 +310,7 @@ class Signature(object):
 
         # Strings and single byte signatures are taken at face value;
         # multi-byte integer values are turned into regex strings based
-        # on their data type size and endianess.
+        # on their data type size and endianness.
         if line.type == 'regex':
             # Regex types are already compiled expressions.
             # Note that since re.finditer is used, unless the specified
@@ -305,40 +321,40 @@ class Signature(object):
         elif line.size == 1:
             restr = chr(line.value)
         elif line.size == 2:
-            if line.endianess == '<':
+            if line.endianness == '<':
                 restr = chr(line.value & 0xFF) + chr(line.value >> 8)
-            elif line.endianess == '>':
+            elif line.endianness == '>':
                 restr = chr(line.value >> 8) + chr(line.value & 0xFF)
         elif line.size == 4:
-            if line.endianess == '<':
-                restr =          (chr(line.value & 0xFF) +
-                                  chr((line.value >> 8) & 0xFF) +
-                                  chr((line.value >> 16) & 0xFF) +
-                                  chr(line.value >> 24))
-            elif line.endianess == '>':
-                restr =          (chr(line.value >> 24) +
-                                  chr((line.value >> 16) & 0xFF) +
-                                  chr((line.value >> 8) & 0xFF) +
-                                  chr(line.value & 0xFF))
+            if line.endianness == '<':
+                restr = (chr(line.value & 0xFF) +
+                         chr((line.value >> 8) & 0xFF) +
+                         chr((line.value >> 16) & 0xFF) +
+                         chr(line.value >> 24))
+            elif line.endianness == '>':
+                restr = (chr(line.value >> 24) +
+                         chr((line.value >> 16) & 0xFF) +
+                         chr((line.value >> 8) & 0xFF) +
+                         chr(line.value & 0xFF))
         elif line.size == 8:
-            if line.endianess == '<':
-                restr =          (chr(line.value & 0xFF) +
-                                  chr((line.value >> 8) & 0xFF) +
-                                  chr((line.value >> 16) & 0xFF) +
-                                  chr((line.value >> 24) & 0xFF) +
-                                  chr((line.value >> 32) & 0xFF) +
-                                  chr((line.value >> 40) & 0xFF) +
-                                  chr((line.value >> 48) & 0xFF) +
-                                  chr(line.value >> 56))
-            elif line.endianess == '>':
-                restr =          (chr(line.value >> 56) +
-                                  chr((line.value >> 48) & 0xFF) +
-                                  chr((line.value >> 40) & 0xFF) +
-                                  chr((line.value >> 32) & 0xFF) +
-                                  chr((line.value >> 24) & 0xFF) +
-                                  chr((line.value >> 16) & 0xFF) +
-                                  chr((line.value >> 8) & 0xFF) +
-                                  chr(line.value & 0xFF))
+            if line.endianness == '<':
+                restr = (chr(line.value & 0xFF) +
+                         chr((line.value >> 8) & 0xFF) +
+                         chr((line.value >> 16) & 0xFF) +
+                         chr((line.value >> 24) & 0xFF) +
+                         chr((line.value >> 32) & 0xFF) +
+                         chr((line.value >> 40) & 0xFF) +
+                         chr((line.value >> 48) & 0xFF) +
+                         chr(line.value >> 56))
+            elif line.endianness == '>':
+                restr = (chr(line.value >> 56) +
+                         chr((line.value >> 48) & 0xFF) +
+                         chr((line.value >> 40) & 0xFF) +
+                         chr((line.value >> 32) & 0xFF) +
+                         chr((line.value >> 24) & 0xFF) +
+                         chr((line.value >> 16) & 0xFF) +
+                         chr((line.value >> 8) & 0xFF) +
+                         chr(line.value & 0xFF))
 
         # Since re.finditer is used on a per-signature basis, signatures should be crafted carefully
         # to ensure that they aren't potentially self-overlapping (e.g., a signature of "ABCDAB" could
@@ -350,7 +366,7 @@ class Signature(object):
         # spit out a warning about any self-overlapping signatures.
         if not binwalk.core.compat.has_key(line.tags, 'overlap'):
             for i in range(1, line.size):
-                if restr[i:] == restr[0:(line.size-i)]:
+                if restr[i:] == restr[0:(line.size - i)]:
                     binwalk.core.common.warning("Signature '%s' is a self-overlapping signature!" % line.text)
                     break
 
@@ -364,9 +380,11 @@ class Signature(object):
 
         Returns None.
         '''
-        # This method is kind of useless, but may be a nice wrapper for future code.
+        # This method is kind of useless, but may be a nice wrapper for future
+        # code.
         self.lines.append(line)
 
+
 class Magic(object):
     '''
     Primary class for loading signature files and scanning
@@ -383,11 +401,14 @@ class Magic(object):
 
         Returns None.
         '''
-        # Used to save the block of data passed to self.scan (see additional comments in self.scan)
+        # Used to save the block of data passed to self.scan (see additional
+        # comments in self.scan)
         self.data = ""
-        # A list of Signature class objects, populated by self.parse (see also: self.load)
+        # A list of Signature class objects, populated by self.parse (see also:
+        # self.load)
         self.signatures = []
-        # A set of signatures with the 'once' keyword that have already been displayed once
+        # A set of signatures with the 'once' keyword that have already been
+        # displayed once
         self.display_once = set()
         self.dirty = True
 
@@ -406,6 +427,9 @@ class Magic(object):
         # Regex rule to find periods (see self._do_math)
         self.period = re.compile("\.")
 
+    def reset(self):
+        self.display_once = set()
+
     def _filtered(self, text):
         '''
         Tests if a string should be filtered out or not.
@@ -443,7 +467,7 @@ class Magic(object):
 
         return filtered
 
-    def _do_math(self, offset, expression):
+    def _do_math(self, offset, expression, previous_line_start):
         '''
         Parses and evaluates complex expressions, e.g., "(4.l+12)", "(6*32)", etc.
 
@@ -457,53 +481,66 @@ class Magic(object):
             replacements = {}
 
             for period in [match.start() for match in self.period.finditer(expression)]:
-                # Separate the offset field into the integer offset and type values (o and t respsectively)
+                # Separate the offset field into the integer offset and type
+                # values (o and t respsectively)
                 s = expression[:period].rfind('(') + 1
-                # The offset address may be an evaluatable expression, such as '(4+0.L)', typically the result
-                # of the original offset being something like '(&0.L)'.
-                o = binwalk.core.common.MathExpression(expression[s:period]).value
-                t = expression[period+1]
+                if s == period:
+                    # The > in >.L indicates the current offset.
+                    # It must follow a normal signature which handles the value at the same offset.
+                    # >(8.L)+8+8          ubelong   x           offset to name %d
+                    # >(12.L)+(>.L)       string    x           %s
+                    o = previous_line_start
+                else:
+                    # The offset address may be an evaluatable expression, such as '(4+0.L)', typically the result
+                    # of the original offset being something like '(&0.L)'.
+                    o = binwalk.core.common.MathExpression(expression[s:period]).value
+                t = expression[period + 1]
 
                 # Re-build just the parsed offset portion of the expression
                 text = "%s.%c" % (expression[s:period], t)
 
-                # Have we already evaluated this offset expression? If so, skip it.
+                # Have we already evaluated this offset expression? If so, skip
+                # it.
                 if binwalk.core.common.has_key(replacements, text):
                     continue
 
-                # The offset specified in the expression is relative to the starting offset inside self.data
+                # The offset specified in the expression is relative to the
+                # starting offset inside self.data
                 o += offset
 
                 # Read the value from self.data at the specified offset
                 try:
                     # Big and little endian byte format
                     if t in ['b', 'B']:
-                        v = struct.unpack('b', binwalk.core.compat.str2bytes(self.data[o:o+1]))[0]
+                        v = struct.unpack('b', binwalk.core.compat.str2bytes(self.data[o:o + 1]))[0]
                     # Little endian short format
                     elif t == 's':
-                        v = struct.unpack('<h', binwalk.core.compat.str2bytes(self.data[o:o+2]))[0]
+                        v = struct.unpack('<h', binwalk.core.compat.str2bytes(self.data[o:o + 2]))[0]
                     # Little endian long format
                     elif t == 'l':
-                        v = struct.unpack('<i', binwalk.core.compat.str2bytes(self.data[o:o+4]))[0]
+                        v = struct.unpack('<i', binwalk.core.compat.str2bytes(self.data[o:o + 4]))[0]
                     # Big endian short format
                     elif t == 'S':
-                        v = struct.unpack('>h', binwalk.core.compat.str2bytes(self.data[o:o+2]))[0]
+                        v = struct.unpack('>h', binwalk.core.compat.str2bytes(self.data[o:o + 2]))[0]
                     # Bit endian long format
                     elif t == 'L':
-                        v = struct.unpack('>i', binwalk.core.compat.str2bytes(self.data[o:o+4]))[0]
-                # struct.error is thrown if there is not enough bytes in self.data for the specified format type
+                        v = struct.unpack('>i', binwalk.core.compat.str2bytes(self.data[o:o + 4]))[0]
+                # struct.error is thrown if there is not enough bytes in
+                # self.data for the specified format type
                 except struct.error as e:
                     v = 0
 
                 # Keep track of all the recovered values from self.data
                 replacements[text] = v
 
-            # Finally, replace all offset expressions with their corresponding text value
+            # Finally, replace all offset expressions with their corresponding
+            # text value
             v = expression
             for (text, value) in binwalk.core.common.iterator(replacements):
                 v = v.replace(text, "%d" % value)
 
-        # If no offset, then it's just an evaluatable math expression (e.g., "(32+0x20)")
+        # If no offset, then it's just an evaluatable math expression (e.g.,
+        # "(32+0x20)")
         else:
             v = expression
 
@@ -522,18 +559,22 @@ class Magic(object):
         Returns a dictionary of tags parsed from the data.
         '''
         description = []
-        tag_strlen = None
         max_line_level = 0
         previous_line_end = 0
-        tags = {'id' : signature.id, 'offset' : offset, 'invalid' : False, 'once' : False}
+        previous_line_size = 0
+        non_printable_char = False
+        tags = {'id': signature.id, 'offset':
+            offset, 'invalid': False, 'once': False}
 
-        # Apply each line of the signature to self.data, starting at the specified offset
+        # Apply each line of the signature to self.data, starting at the
+        # specified offset
         for n in range(0, len(signature.lines)):
             line = signature.lines[n]
 
             # Ignore indentation levels above the current max indent level
             if line.level <= max_line_level:
-                # If the relative offset of this signature line is just an integer value, use it
+                # If the relative offset of this signature line is just an
+                # integer value, use it
                 if isinstance(line.offset, int):
                     line_offset = line.offset
                 # Else, evaluate the complex expression
@@ -546,7 +587,7 @@ class Magic(object):
                     # replace both with the ple text.
                     line_offset_text = line.offset.replace('&+', ple).replace('&', ple)
                     # Evaluate the expression
-                    line_offset = self._do_math(offset, line_offset_text)
+                    line_offset = self._do_math(offset, line_offset_text, previous_line_end - previous_line_size)
 
                 # Sanity check
                 if not isinstance(line_offset, int):
@@ -561,7 +602,8 @@ class Magic(object):
                 if line.pkfmt:
                     try:
                         dvalue = struct.unpack(line.pkfmt, binwalk.core.compat.str2bytes(self.data[start:end]))[0]
-                    # Not enough bytes left in self.data for the specified format size
+                    # Not enough bytes left in self.data for the specified
+                    # format size
                     except struct.error as e:
                         dvalue = 0
                 # Else, this is a string
@@ -570,22 +612,27 @@ class Magic(object):
                     if line.value is None:
                         # Check to see if this is a string whose size is known and has been specified on a previous
                         # signature line.
-                        if binwalk.core.compat.has_key(tags, 'strlen') and binwalk.core.compat.has_key(line.tags, 'string'):
-                            dvalue = self.data[start:(start+tags['strlen'])]
-                        # Else, just terminate the string at the first newline, carriage return, or NULL byte
+                        if binwalk.core.compat.has_key(tags, 'strlen') and binwalk.core.compat.has_key(line.tags,
+                                                                                                       'string'):
+                            dvalue = self.data[start:(start + tags['strlen'])]
+                            non_printable_char = True
+                        # Else, just terminate the string at the first newline,
+                        # carriage return, or NULL byte
                         else:
                             dvalue = self.data[start:end].split('\x00')[0].split('\r')[0].split('\n')[0]
-                    # Non-wildcard strings have a known length, specified in the signature line
+                    # Non-wildcard strings have a known length, specified in
+                    # the signature line
                     else:
                         dvalue = self.data[start:end]
 
                 # Some integer values have special operations that need to be performed on them
                 # before comparison (e.g., "belong&0x0000FFFF"). Complex math expressions are
                 # supported here as well.
-                #if isinstance(dvalue, int) and line.operator:
+                # if isinstance(dvalue, int) and line.operator:
                 if line.operator:
                     try:
-                        # If the operator value of this signature line is just an integer value, use it
+                        # If the operator value of this signature line is just
+                        # an integer value, use it
                         if isinstance(line.opvalue, int) or isinstance(line.opvalue, long):
                             opval = line.opvalue
                         # Else, evaluate the complex expression
@@ -612,25 +659,36 @@ class Magic(object):
                     except KeyboardInterrupt as e:
                         raise e
                     except Exception as e:
-                        raise ParserException("Operation '" + str(dvalue) + " " + str(line.operator) + "= " + str(line.opvalue) + "' failed: " + str(e))
+                        raise ParserException("Operation '" +
+                                              str(dvalue) +
+                                              " " +
+                                              str(line.operator) +
+                                              "= " +
+                                              str(line.opvalue) +
+                                              "' failed: " + str(e))
 
                 # Does the data (dvalue) match the specified comparison?
                 if ((line.value is None) or
-                    (line.regex and line.value.match(dvalue)) or
-                    (line.condition == '=' and dvalue == line.value) or
-                    (line.condition == '>' and dvalue > line.value) or
-                    (line.condition == '<' and dvalue < line.value) or
-                    (line.condition == '!' and dvalue != line.value) or
-                    (line.condition == '~' and (dvalue == ~line.value)) or
-                    (line.condition == '^' and (dvalue ^ line.value)) or
-                    (line.condition == '&' and (dvalue & line.value)) or
-                    (line.condition == '|' and (dvalue | line.value))):
+                        (line.regex and line.value.match(dvalue)) or
+                        (line.condition == '=' and dvalue == line.value) or
+                        (line.condition == '>' and dvalue > line.value) or
+                        (line.condition == '<' and dvalue < line.value) or
+                        (line.condition == '!' and dvalue != line.value) or
+                        (line.condition == '~' and (dvalue == ~line.value)) or
+                        (line.condition == '^' and (dvalue ^ line.value)) or
+                        (line.condition == '&' and (dvalue & line.value)) or
+                        (line.condition == '|' and (dvalue | line.value))):
 
                     # Up until this point, date fields are treated as integer values,
                     # but we want to display them as nicely formatted strings.
                     if line.type == 'date':
-                        ts = datetime.datetime.utcfromtimestamp(dvalue)
-                        dvalue = ts.strftime("%Y-%m-%d %H:%M:%S")
+                        try:
+                            ts = datetime.datetime.utcfromtimestamp(dvalue)
+                            dvalue = ts.strftime("%Y-%m-%d %H:%M:%S")
+                        except KeyboardInterrupt as e:
+                            raise e
+                        except Exception:
+                            dvalue = "invalid timestamp"
 
                     # Generate the tuple for the format string
                     dvalue_tuple = ()
@@ -640,12 +698,14 @@ class Magic(object):
                     # Format the description string
                     desc = line.format % dvalue_tuple
 
-                    # If there was any description string, append it to the list of description string parts
+                    # If there was any description string, append it to the
+                    # list of description string parts
                     if desc:
                         description.append(desc)
 
                     # Process tag keywords specified in the signature line. These have already been parsed out of the
-                    # original format string so that they can be processed separately from the printed description string.
+                    # original format string so that they can be processed
+                    # separately from the printed description string.
                     for (tag_name, tag_value) in binwalk.core.compat.iterator(line.tags):
                         # If the tag value is a string, try to format it
                         if isinstance(tag_value, str):
@@ -660,9 +720,13 @@ class Magic(object):
                         else:
                             tags[tag_name] = tag_value
 
-                        # Some tag values are intended to be integer values, so try to convert them as such
+                        # Some tag values are intended to be integer values, so
+                        # try to convert them as such.
+                        # Use eval() to support arithmetic operators to tagged metadata.
                         try:
-                            tags[tag_name] = int(tags[tag_name], 0)
+                            tags[tag_name] = eval(tags[tag_name])
+                        except SyntaxError:
+                            tags[tag_name] = 0
                         except KeyboardInterrupt as e:
                             raise e
                         except Exception as e:
@@ -670,7 +734,8 @@ class Magic(object):
 
                     # Abort processing soon as this signature is marked invalid, unless invalid results
                     # were explicitly requested. This means that the sooner invalid checks are made in a
-                    # given signature, the faster the scan can filter out false positives.
+                    # given signature, the faster the scan can filter out false
+                    # positives.
                     if not self.show_invalid and tags['invalid']:
                         break
 
@@ -679,16 +744,19 @@ class Magic(object):
                     # so that subsequent lines can use the '>>&0' offset syntax to specify relative offsets
                     # from previous lines.
                     try:
-                        next_line = signature.lines[n+1]
+                        next_line = signature.lines[n + 1]
                         if next_line.level > line.level:
                             if line.type == 'string':
                                 previous_line_end = line_offset + len(dvalue)
+                                previous_line_size = len(dvalue)
                             else:
                                 previous_line_end = line_offset + line.size
+                                previous_line_size = line.size
                     except IndexError as e:
                         pass
 
-                    # If this line satisfied its comparison, +1 the max indentation level
+                    # If this line satisfied its comparison, +1 the max
+                    # indentation level
                     max_line_level = line.level + 1
                 else:
                     # No match on the first line, abort
@@ -699,7 +767,8 @@ class Magic(object):
                         # indentation levels will not be accepted.
                         max_line_level = line.level
 
-        # Join the formatted description strings and remove backspace characters (plus the preceeding character as well)
+        # Join the formatted description strings and remove backspace
+        # characters (plus the preceeding character as well)
         tags['description'] = self.bspace.sub('', " ".join(description))
 
         # This should never happen
@@ -707,8 +776,11 @@ class Magic(object):
             tags['display'] = False
             tags['invalid'] = True
 
-        # If the formatted string contains non-printable characters, consider it invalid
-        if self.printable.match(tags['description']).group() != tags['description']:
+        # If the formatted string contains non-printable characters, consider it invalid.
+        if non_printable_char:
+            tags['description'] = tags['description'].replace('\0', '')
+
+        if not non_printable_char and self.printable.match(tags['description']).group() != tags['description']:
             tags['invalid'] = True
 
         return tags
@@ -745,18 +817,20 @@ class Magic(object):
             dlen = len(data)
 
         for signature in self.signatures:
-            # Use regex to search the data block for potential signature matches (fast)
+            # Use regex to search the data block for potential signature
+            # matches (fast)
             for match in signature.regex.finditer(data):
                 # Take the offset of the start of the signature into account
                 offset = match.start() - signature.offset
 
                 # Signatures are ordered based on the length of their magic bytes (largest first).
                 # If this offset has already been matched to a previous signature, ignore it unless
-                # self.show_invalid has been specified. Also ignore obviously invalid offsets (<1)
+                # self.show_invalid has been specified. Also ignore obviously invalid offsets (<0)
                 # as well as those outside the specified self.data range (dlen).
                 if (offset not in matched_offsets or self.show_invalid) and offset >= 0 and offset < dlen:
-                #if offset >= 0 and offset < dlen:
-                    # Analyze the data at this offset using the current signature rule
+                    # if offset >= 0 and offset < dlen:
+                    # Analyze the data at this offset using the current
+                    # signature rule
                     tags = self._analyze(signature, offset)
 
                     # Generate a SignatureResult object and append it to the results list if the
@@ -806,7 +880,8 @@ class Magic(object):
         signature = None
 
         for line in lines:
-            # Split at the first comment delimiter (if any) and strip the result
+            # Split at the first comment delimiter (if any) and strip the
+            # result
             line = line.split('#')[0].strip()
             # Ignore blank lines and lines that are nothing but comments.
             # We also don't support the '!mime' style line entries.
@@ -826,10 +901,11 @@ class Magic(object):
                     signature = Signature(len(self.signatures), sigline)
                 # Else, just append this line to the existing signature
                 elif signature:
-                    #signature.append(sigline)
+                    # signature.append(sigline)
                     signature.lines.append(sigline)
                 # If this is not the first line of a signature entry and there is no other
-                # existing signature entry, something is very wrong with the signature file.
+                # existing signature entry, something is very wrong with the
+                # signature file.
                 else:
                     raise ParserException("Invalid signature line: '%s'" % line)
 
@@ -838,6 +914,6 @@ class Magic(object):
             if not self._filtered(signature.lines[0].format):
                 self.signatures.append(signature)
 
-        # Sort signatures by confidence (aka, length of their magic bytes), largest first
+        # Sort signatures by confidence (aka, length of their magic bytes),
+        # largest first
         self.signatures.sort(key=lambda x: x.confidence, reverse=True)
-
diff --git a/src/binwalk/magic/firmware b/src/binwalk/magic/firmware
index 53fc9cc..ccdb0bb 100644
--- a/src/binwalk/magic/firmware
+++ b/src/binwalk/magic/firmware
@@ -8,6 +8,7 @@
 >8     bedate    x              created: %s,
 >12    belong    <1             {invalid}
 >12    ubelong   x              image size: %d bytes,
+>12    ubelong   x              {size:%d+64}
 >16    ubelong   x              Data Address: 0x%X,
 >20    ubelong   x              Entry Point: 0x%X,
 >24    ubelong   x              data CRC: 0x%X,
@@ -699,4 +700,31 @@
 >20   ulelong    x             \b, ramdisk addr: 0x%X
 >48   string     x             \b, product name: "%s"
 
+# flattened image tree
+0                   ubelong   0xd00dfeed  flattened image tree, # fit_header
+>4                  ubelong   x           total size: %d bytes,
+>4                  ubelong   x           {size:%d}
+>(8.L)              ubelong   0           {invalid}
+# >8                ubelong   x           offset to dt_struct: 0x%x,
+>(12.L)             ubelong   0           {invalid} # enlarge block size and try again, default=0x100000 (1M)
+# >12               ubelong   x           offset to strings: 0x%x,
+>(16.L)             ubelong   !0          {invalid}
+# >16               ubelong   x           offset to memory reserve map: 0x%x,
+# >20               ubelong   x           version: %d,
+# >24               ubelong   x           last compatiable version: %d,
+# >28               ubelong   x           booting on CPU %d,
+>(32.L)             ubelong   0           {invalid}
+# >32               ubelong   x           size of the strings block: %d bytes,
+>(36.L)             ubelong   0           {invalid}
+# >36               ubelong   x           size of the structure block: %d bytes,
+>(8.L)+0            ubelong   !1          {invalid} # fit_structure->root_node_header
+>(8.L)+8+0          ubelong   !3          {invalid} # fit_structure->root_timestamp
+>(8.L)+8+8          ubelong   x           # offset to name,
+>(12.L)+(>.L)       string    !timestamp  {invalid}
+>(8.L)+8+12         ubedate   x           timestamp: %s,
+>(8.L)+24+0         ubelong   3           # fit_structure->root_description
+>>(8.L)+24+4        ubelong   x           {strlen:(%d+3)&~3}
+>>(8.L)+24+8        ubelong   x           # offset to name,
+>>(12.L)+(>.L)      string    x           %s:
+>>(8.L)+24+12       string    x           {string}%s
 
diff --git a/src/binwalk/modules/general.py b/src/binwalk/modules/general.py
index 0549a97..49205c2 100644
--- a/src/binwalk/modules/general.py
+++ b/src/binwalk/modules/general.py
@@ -1,4 +1,5 @@
-# Module to process general user input options (scan length, starting offset, etc).
+# Module to process general user input options (scan length, starting
+# offset, etc).
 
 import io
 import os
@@ -12,6 +13,7 @@ import binwalk.core.settings
 from binwalk.core.compat import *
 from binwalk.core.module import Module, Option, Kwarg, show_help
 
+
 class General(Module):
 
     TITLE = "General"
@@ -23,77 +25,77 @@ class General(Module):
         Option(long='length',
                short='l',
                type=int,
-               kwargs={'length' : 0},
+               kwargs={'length': 0},
                description='Number of bytes to scan'),
         Option(long='offset',
                short='o',
                type=int,
-               kwargs={'offset' : 0},
+               kwargs={'offset': 0},
                description='Start scan at this file offset'),
         Option(long='base',
                short='O',
                type=int,
-               kwargs={'base' : 0},
+               kwargs={'base': 0},
                description='Add a base address to all printed offsets'),
         Option(long='block',
                short='K',
                type=int,
-               kwargs={'block' : 0},
+               kwargs={'block': 0},
                description='Set file block size'),
         Option(long='swap',
                short='g',
                type=int,
-               kwargs={'swap_size' : 0},
+               kwargs={'swap_size': 0},
                description='Reverse every n bytes before scanning'),
         Option(long='log',
                short='f',
                type=argparse.FileType,
-               kwargs={'log_file' : None},
+               kwargs={'log_file': None},
                description='Log results to file'),
         Option(long='csv',
                short='c',
-               kwargs={'csv' : True},
+               kwargs={'csv': True},
                description='Log results to file in CSV format'),
         Option(long='term',
                short='t',
-               kwargs={'format_to_terminal' : True},
+               kwargs={'format_to_terminal': True},
                description='Format output to fit the terminal window'),
         Option(long='quiet',
                short='q',
-               kwargs={'quiet' : True},
+               kwargs={'quiet': True},
                description='Suppress output to stdout'),
         Option(long='verbose',
                short='v',
-               kwargs={'verbose' : True},
+               kwargs={'verbose': True},
                description='Enable verbose output'),
         Option(short='h',
                long='help',
-               kwargs={'show_help' : True},
+               kwargs={'show_help': True},
                description='Show help output'),
         Option(short='a',
                long='finclude',
                type=str,
-               kwargs={'file_name_include_regex' : ""},
+               kwargs={'file_name_include_regex': ""},
                description='Only scan files whose names match this regex'),
         Option(short='p',
                long='fexclude',
                type=str,
-               kwargs={'file_name_exclude_regex' : ""},
+               kwargs={'file_name_exclude_regex': ""},
                description='Do not scan files whose names match this regex'),
         Option(short='s',
                long='status',
                type=int,
-               kwargs={'status_server_port' : 0},
+               kwargs={'status_server_port': 0},
                description='Enable the status server on the specified port'),
         Option(long=None,
                short=None,
                type=binwalk.core.common.BlockFile,
-               kwargs={'files' : []}),
+               kwargs={'files': []}),
 
         # Hidden, API-only arguments
         Option(long="string",
                hidden=True,
-               kwargs={'subclass' : binwalk.core.common.StringFile}),
+               kwargs={'subclass': binwalk.core.common.StringFile}),
     ]
 
     KWARGS = [
@@ -160,7 +162,8 @@ class General(Module):
         Must be called after self._test_target_files so that self.target_files is properly set.
         '''
         # If more than one target file was specified, enable verbose mode; else, there is
-        # nothing in some outputs to indicate which scan corresponds to which file.
+        # nothing in some outputs to indicate which scan corresponds to which
+        # file.
         if len(self.target_files) > 1 and not self.verbose:
             self.verbose = True
 
@@ -190,6 +193,8 @@ class General(Module):
             offset = self.offset
         if swap is None:
             swap = self.swap_size
+        if self.block != 0:
+            block = self.block
 
         return binwalk.core.common.BlockFile(fname,
                                              subclass=self.subclass,
@@ -216,5 +221,4 @@ class General(Module):
                 except KeyboardInterrupt as e:
                     raise e
                 except Exception as e:
-                    self.error(description="Cannot open file : %s" % str(e))
-
+                    self.error(description="Cannot open file %s (CWD: %s) : %s" % (tfile, os.getcwd(), str(e)))
diff --git a/src/binwalk/plugins/uimageextract.py b/src/binwalk/plugins/uimageextract.py
new file mode 100644
index 0000000..d703a25
--- /dev/null
+++ b/src/binwalk/plugins/uimageextract.py
@@ -0,0 +1,23 @@
+import os
+import binwalk.core.plugin
+
+
+class uImageExtractPlugin(binwalk.core.plugin.Plugin):
+    """
+    uImage extractor plugin.
+    """
+    MODULES = ['Signature']
+
+    def init(self):
+        if self.module.extractor.enabled:
+            self.module.extractor.add_rule(txtrule=None,
+                                           regex='^uimage',
+                                           extension='uimage',
+                                           cmd=self.extractor)
+            self.module.extractor.add_rule(txtrule=None,
+                                           regex='^flattened image tree',
+                                           extension='uimage.fit',
+                                           cmd=self.extractor)
+
+    def extractor(self, fname):
+        pass
diff --git a/src/scripts/extract_uimage.py b/src/scripts/extract_uimage.py
new file mode 100644
index 0000000..3a1f657
--- /dev/null
+++ b/src/scripts/extract_uimage.py
@@ -0,0 +1,11 @@
+#!/usr/bin/env python
+
+import sys
+import binwalk
+
+for module in binwalk.scan(*sys.argv[1:], signature=True, quit=False, extract=False):
+    print('%s Results:' % module.name)
+    # for result in module.results:
+    #     if result.file.path in module.extractor.output:
+    #         if module.extractor.output[result.file.path].extracted.has_key(result.offset):
+    #             pass
-- 
2.7.4

