Table of Contents
=================

   * [Template and Parameters](#template-and-parameters)
      * [Overview](#overview)
      * [QEMU hw implementation](#qemu-hw-implementation)
         * [State transition of Interrupt Controller](#state-transition-of-interrupt-controller)
         * [State transition of Timer](#state-transition-of-timer)
      * [Fixed Parameters](#fixed-parameters)
         * [Interrupt Controller](#interrupt-controller)
         * [Timer](#timer)
         * [MMIO Region](#mmio-region)
      * [Manual Analysis](#manual-analysis)

Created by [gh-md-toc](https://github.com/ekalinin/github-markdown-toc)

# Template and Parameters

## Overview

A QEMU virtual machine is automatically generated by
abstract representations of peripherals on a SoC.
We have three types of abstract representations for Interrupt Controller, Timer,
and any other peripherals. Each abstract representation consists of
a QEMU registration APIs template and a QEMU hardware implementation template.
If we reuse a peripheral in QEMU, then the QEMU hardware implementation is already there;
otherwise, we have to concretize the abstract representation of each peipheral
by manually and automatically infer parameters used in the abstraction

Here is the flow of the QEMU virtual machine synthesis.
It is clear that the parameters are generated from a device tree file and Linux kernel source code.
The QEMU registeration APIs are already or can be automatically prepared.
The QEMU hw implementation template is prepared manually.
The dynamic parameters can be extracted from the device tree automatically.
However, the fixed parameters have to be infered manullay or automatically, and
we will talk about this later.
The concretization is automatic and the code generation is also automatic.


```txt
                         +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+ 
                         | CPU (model, ...)                  | <model, dynamic parameters> |
+------+-----+-----+     | Memory ('ram', base, size, ...)   +-----+-----+-----+-----+-----+
| device tree file | --->| Interrupt Controller (model, base, size, ...)                   |
+------+-----+-----+     | Timer  (model, base, size, interrupt, ...)                      |
                         | Serial (model, base, size, reg_shift, interrupt, ...)           |
                         | Others (model, base, size, ...)                                 |
                         +-----+-----+-----+-----+-----+--+--+-----+-----+-----+-----+-----+
                                       |                                                            
                                       | 
                                       |                                                           
+-----+-----+-----+-----+-----+-----+  v   +--+--+-----+-----+-----+-----+-----+            
| <model, QEMU registration APIs*>  | ---> | <model, QEMU registration APIs^>  | -----------+
+-----+-----+-----+-----+-----+-----+      +-----+-----+-----+-----+-----+-----+            |    +-----+-----+----+
                                *template                                  ^implementation  |    |  machine.c/h   | 
                                                                                            +--->+-----+-----+----+
                                *template                                  ^implementation  |    | peripheral.c/h |
+*****+*****+*****+*****+*****+*****+      +-----+-----+-----+-----+-----+-----+            |    +-----+-----+----+
| <model, QEMU hw implementation*>  | ---> | <model, QEMU hw implementation^>  | -----------+
+*****+*****+*****+*****+*****+*****+  ^   +-----+-----+-----+-----+-----+-----+            
                                       |
                                       |
                                 +*****+*****+*****+*****+*****+*****+*****+*****+*****+***+ 
                                 |                             | <model, fixed parameters> |
+------+-----+-----+-----+-+     |                             +-----+-----+-----+-----+---+
| Linux kernel source code | --->| Interrupt Controller (r/w seqs)                         |
+------+-----+-----+-----+-+     | Timer  (r/w seqs, semantics)                            |
                                 | Others (initial values)                                 |
                                 +*****+*****+*****+*****+*****+*****+*****+*****+*****+***+
                                                      (We automated this part in out paper.)
```

## QEMU hw implementation

### State transition of Interrupt Controller

REST: The Interrupt Controller is idle.  
NOISE: There exist some interrupt requests.  
ALARM:  The interrupt Controller should file the interrupt to a processor.  

pending: The property of an interrupt request indicates
that there exist a interrupt request pending.  
masked: The property of an interrupt request indicates
whether or not it is allowed to file the interrupt to a processor.  
set_irqn_to_regs will set the pending register to a specific value.
Linux kernel will read this register, calculate the interrupt request number,
and call its interrupt servise routine.  

| state_from | pending | masked | state_to |                   action                   |
|:----------:|:-------:|:------:|:--------:|:------------------------------------------:|
|    REST    |    0    |    0   |   REST   |                                            |
|    REST    |    0    |    1   |   REST   |                                            |
|    REST    |    1    |    0   |   ALARM  |  set_irqn_to_regs(irqn) qemu_setup_irq(1)  |
|    REST    |    1    |    1   |   NOISE  |                                            |
|    NOISE   |    0    |    0   |   REST   | clear_irqn_to_regs(irqn) qemu_setup_irq(0) |
|    NOISE   |    0    |    1   |   REST   | clear_irqn_to_regs(irqn) qemu_setup_irq(0) |
|    NOISE   |    1    |    0   |   ALARM  |  set_irqn_to_regs(irqn) qemu_setup_irq(1)  |
|    NOISE   |    1    |    1   |   NOISE  |                                            |
|    ALARM   |    0    |    0   |   REST   | clear_irqn_to_regs(irqn) qemu_setup_irq(0) |
|    ALARM   |    0    |    1   |   REST   | clear_irqn_to_regs(irqn) qemu_setup_irq(0) |
|    ALARM   |    1    |    0   |   ALARM  |                                            |
|    ALARM   |    1    |    1   |   NOISE  | clear_irqn_to_regs(irqn) qemu_setup_irq(0) |

pending is set when 
+ other peripheral has an interrrupt request

pending is clear when
+ other peripheral cancles its interrrupt request
+ mask_ack_action happens
+ ack_action happens

masked is set when
+ the interrupt controller is reset
+ mask_ack_action happens
+ mask_action happens

masked is clear when
+ unmask_action happens

xxx_action from Interrupt Controller driver callbacks indicates
which property of a certain interrupt request will be set or clear.

### State transition of Timer

There are two internal timers in the template of Timer.
The first one is a fixed rate timer (clockevent), 100HZ.
The second timer (clocksource) is configured by four properties,
timer_freq, timer_bits, timer_increasing, timer_decreasing, and timer_counters.

timer_freq: The frequence(rate) of a timer.  
timer_bits: The number of valid bits of a timer counter.  
timer_increasing/timer_descreasing: Whether or not the value of the timer counter is stored
in reverse.  
timer_counters: The offset of the timer counters.  

The state transition of Timer is quite simple. After configuration,
the first timer will file the interrupt periodically;
the second timer will be acquired by Linux kernel to maintain
a precise time.

## Fixed Parameters 

### Interrupt Controller

|parameter|description|
|:---:|:---|
|{regs_addr, regs_value}|The address of the MMIO and its initial value|
|{irqn, set_handler, clear_handler}|IRQ and the regs set/clear handlers when it happens.|
|{ack_hint, mask_hint, unmask_hint}|The hint of the state `ack`, `mask`, `unmask`.|

Where to find them?
+ irq_domain_add_simple
+ irq_domain_add_legacy
+ irq_domain_add_linear
+ __irq_domain_add
+ __irq_set_handler
+ irq_set_chained_handler
+ irq_set_chip_and_handler_name
+ irq_set_chained_handler_and_data
+ set_handle_irq (ARM)
+ plat_irq_dispatch (MIPS)

### Timer

|parameter|description|
|:---:|:---|
|rate|The rate of the clock source/event device|
|counter_addr|The address of the counter for timekeeping and scheduled clock.|
|n_bits|The number of bits of the counter.|
|monotone|Whether the counter counts down or not.|

Where to find them?
+ clocksource_register_hz
+ clocksource_mmio_init
+ clocksource_register
+ __clocksource_register_scale
+ sched_clock_register
+ clockevents_config_and_register
+ clockevents_register_device
+ clk_register
+ clk_hw_register
+ clk_get_sys
+ clkdev_add
+ register_current_timer_delay

### MMIO Region

|parameter|description|
|:---:|:---|
|addr|The address of the MMIO to be manipulated.|
|size|The size of the MMIO to be manipulated.|
|value|The initial value of the MMIO.|

Where to find them?
+ setup_arch
+ do_initcall_level

## Manual Analysis

We provide several subcommands for manual analysis.

First, try `traversrc` to pricisely traverse kernel function from `start_kernel`
to `rest_init`. The traversal in implemented by `sparse` in AST level.
We only care about functions, such that global/local variables are ignored
in the traversal. Because of simple implementation, conditions are also
ignored, such that each callee in the caller will be visited.
After the traversal, we will save all interesting functions as `.slicing`.
Each recored in `.slicing` consists of the function name, in which file the function is,
and its line number.

However, manual efforts are needed during the traversal because of indirect calls.
You can use `-dtb` to solve indirect calls that go to intc/timer initialization functions.
For remaining indirect calls you have to update them manually by
adding a record in `x.fcbs` in your working directory.

In the traversal, we will list all interesting functions by `[unknown]`,
For your convenience, `traversrc` will save all `unknown` functions in `0.fcbs`.
If `mach_desc.init_time` is an indirect call, 
add a record below after running `tranversrc` in `1.fcbs`.
At the same time, please `-a` to check intermediate functions whether they are visited,
otherwise, you should add file(s)/dir(s) that contain those functions and rerun `traversrc`.
At last, you will see all interesting functions in `.slicing`.

```
mach_desc.init_time:
  skipped: False,
  extend: [ox820_timer_init]
```

Second, use `analysrc` to locate interesting functions. 
It will preprocess the file that has interesting functions for your convenience.
