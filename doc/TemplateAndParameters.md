Table of Contents
=================

   * [Template and Parameters](#template-and-parameters)
      * [Overview](#overview)
      * [Fixed Parameters for Interrupt Controller](#fixed-parameters-for-interrupt-controller)
      * [Fixed Parameters for Timer](#fixed-parameters-for-timer)
      * [Fixed Parameters for MMIO Region](#fixed-parameters-for-mmio-region)
      * [Manual Analysis](#manual-analysis)

Created by [gh-md-toc](https://github.com/ekalinin/github-markdown-toc)

# Template and Parameters

## Overview

A QEMU virtual machine is automatically generated by an abstract representation
with respect to the device tree file of a SoC.
We have three types of abstract representations for Interrupt Controller, Timer,
and other peripherals. Each abstract representation consists of
a QEMU registration template and a QEMU hardware implementation template.
If we reuse a peripheral in QEMU, then the QEMU hardware implementation is already there;
otherwise, we have manually or automatically generate the QEMU hardware implementation
by filling parameters into the QEMU hardware implementation template 
(which is mainly talked about in the paper).

Here is the flow of the QEMU virtual machine synthesis.
Things in box with * are handled manually.


```txt
                         +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+ 
                         | CPU (model, ...)                  | <model, dynamic parameters> |
+------+-----+-----+     | Memory ('ram', base, size, ...)   +-----+-----+-----+-----+-----+
| device tree file | --->| Interrupt Controller (model, base, size, ...)                   |
+------+-----+-----+     | Timer  (model, base, size, interrupt, ...)                      |
                         | Serial (model, base, size, reg_shift, interrupt, ...)           |
                         | Others (model, base, size, ...)                                 |
                         +-----+-----+-----+-----+-----+--+--+-----+-----+-----+-----+-----+
                                       |                                                            
                                       | 
                                       |                                                           
+-----+-----+-----+-----+-----+-----+  v   +--+--+-----+-----+-----+-----+-----+            
| <model, QEMU registration APIs*>  | ---> | <model, QEMU registration APIs^>  | -----------+
+-----+-----+-----+-----+-----+-----+      +-----+-----+-----+-----+-----+-----+            |    +-----+-----+----+
                                *template                                  ^implementation  |    |  machine.c/h   | 
                                                                                            +--->+-----+-----+----+
                                *template                                  ^implementation  |    | peripheral.c/h |
+*****+*****+*****+*****+*****+*****+      +-----+-----+-----+-----+-----+-----+            |    +-----+-----+----+
| <model, QEMU hw implementation*>  | ---> | <model, QEMU hw implementation^>  | -----------+
+*****+*****+*****+*****+*****+*****+  ^   +-----+-----+-----+-----+-----+-----+            
```                                    |
                                       |
                                 +*****+*****+*****+*****+*****+*****+*****+*****+*****+***+ 
                                 |                             | <model, fixed parameters> |
+------+-----+-----+-----+-+     |                             +-----+-----+-----+-----+---+
| Linux kernel source code | --->| Interrupt Controller (r/w seqs)                         |
+------+-----+-----+-----+-+     | Timer  (r/w seqs, semantics)                            |
                                 | Others (initial values)                                 |
                                 +*****+*****+*****+*****+*****+*****+*****+*****+*****+***+
                                                      (We automated this part in out paper.)
```

## QEMU hw implementation

### State transition for Interrupt Controller

| state_from | pending | masked | state_to |                   action                   |
|:----------:|:-------:|:------:|:--------:|:------------------------------------------:|
|    REST    |    0    |    0   |   REST   |                                            |
|    REST    |    0    |    1   |   REST   |                                            |
|    REST    |    1    |    0   |   ALARM  |  set_irqn_to_regs(irqn) qemu_setup_irq(1)  |
|    REST    |    1    |    1   |   NOISE  |                                            |
|    NOISE   |    0    |    0   |   REST   | clear_irqn_to_regs(irqn) qemu_setup_irq(0) |
|    NOISE   |    0    |    1   |   REST   | clear_irqn_to_regs(irqn) qemu_setup_irq(0) |
|    NOISE   |    1    |    0   |   ALARM  |  set_irqn_to_regs(irqn) qemu_setup_irq(1)  |
|    NOISE   |    1    |    1   |   NOISE  |                                            |
|    ALARM   |    0    |    0   |   REST   | clear_irqn_to_regs(irqn) qemu_setup_irq(0) |
|    ALARM   |    0    |    1   |   REST   | clear_irqn_to_regs(irqn) qemu_setup_irq(0) |
|    ALARM   |    1    |    0   |   ALARM  |                                            |
|    ALARM   |    1    |    1   |   NOISE  | clear_irqn_to_regs(irqn) qemu_setup_irq(0) |

pending is set when 
+ other peripheral has an interrrupt request

pending is clean when
+ other peripheral cancles its interrrupt request
+ mask_ack_action happens
+ ack_action happens

masked is set when
+ the interrupt controller is reset
+ mask_ack_action happens
+ mask_action happens

masked is clear when
+ unmask_action happens

## QEMU hw implementation (autoboard)

## Fixed Parameters for Interrupt Controller

|parameter|description|
|:---:|:---|
|{regs_addr, regs_value}|The address of the MMIO and its initial value|
|{irqn, set_handler, clear_handler}|IRQ and the regs set/clear handlers when it happens.|
|{ack_hint, mask_hint, unmask_hint}|The hint of the state `ack`, `mask`, `unmask`.|

Where to find them?
+ irq_domain_add_simple
+ irq_domain_add_legacy
+ irq_domain_add_linear
+ __irq_domain_add
+ __irq_set_handler
+ irq_set_chained_handler
+ irq_set_chip_and_handler_name
+ irq_set_chained_handler_and_data
+ set_handle_irq (ARM)
+ plat_irq_dispatch (MIPS)

## Fixed Parameters for Timer

|parameter|description|
|:---:|:---|
|rate|The rate of the clock source/event device|
|counter_addr|The address of the counter for timekeeping and scheduled clock.|
|n_bits|The number of bits of the counter.|
|monotone|Whether the counter counts down or not.|

Where to find them?
+ clocksource_register_hz
+ clocksource_mmio_init
+ clocksource_register
+ __clocksource_register_scale
+ sched_clock_register
+ clockevents_config_and_register
+ clockevents_register_device
+ clk_register
+ clk_hw_register
+ clk_get_sys
+ clkdev_add
+ register_current_timer_delay

## Fixed Parameters for MMIO Region

|parameter|description|
|:---:|:---|
|addr|The address of the MMIO to be manipulated.|
|size|The size of the MMIO to be manipulated.|
|value|The initial value of the MMIO.|

Where to find them?
+ setup_arch
+ do_initcall_level

## Manual Analysis

We provide several subcommands for manual analysis.

First, try `traversrc` to pricisely traverse kernel function from `start_kernel`
to `rest_init`. The traversal in implemented by `sparse` in AST level.
We only care about functions, such that global/local variables are ignored
in the traversal. Because of simple implementation, conditions are also
ignored, such that each callee in the caller will be visited.
After the traversal, we will save all interesting functions as `.slicing`.
Each recored in `.slicing` consists of the function name, in which file the function is,
and its line number.

However, manual efforts are needed during the traversal because of indirect calls.
You can use `-dtb` to solve indirect calls that go to intc/timer initialization functions.
For remaining indirect calls you have to update them manually by
adding a record in `x.fcbs` in your working directory.

In the traversal, we will list all interesting functions by `[unknown]`,
For your convenience, `traversrc` will save all `unknown` functions in `0.fcbs`.
If `mach_desc.init_time` is an indirect call, 
add a record below after running `tranversrc` in `1.fcbs`.
At the same time, please `-a` to check intermediate functions whether they are visited,
otherwise, you should add file(s)/dir(s) that contain those functions and rerun `traversrc`.
At last, you will see all interesting functions in `.slicing`.

```
mach_desc.init_time:
  skipped: False,
  extend: [ox820_timer_init]
```

Second, use `analysrc` to locate interesting functions. 
It will preprocess the file that has interesting functions for your convenience.
